<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《秒杀系统架构设计》学习</title>
    <url>/arch-miao-sha/</url>
    <content><![CDATA[<ul>
<li>QQ 业务特点：细粒度数据查询<ul>
<li>即使并发量很大，锁冲突其实不大，数据水平切分后，因为带上了 uid，gid 等字段，用户层面几乎没有锁冲突</li>
</ul>
</li>
<li>weibo业务特点:读多写少，有少量读写锁冲突<ul>
<li>微博的核心业务是feed流:<ul>
<li>发消息，写操作</li>
<li>刷消息，读操作</li>
</ul>
</li>
<li>微博业务显然是读多写少的，在用户刷消息时，自己feed流里的消息，是由别人发出的。</li>
</ul>
</li>
<li>秒杀业务特点:数据量少，写多读多,极大锁冲突<ul>
<li>12306的核心业务是:<ul>
<li>查票，读操作</li>
<li>买票，写操作</li>
</ul>
</li>
<li>stock(id, num) //核心数据结构：某一列车有多少张余票</li>
<li>在用户量很大，并发量很大时，有极大的锁冲突。</li>
</ul>
</li>
<li>方向上“降低数据层锁冲突”，具体两大要点:<ul>
<li>(1)降读：用缓存</li>
<li>(2)降写：把请求拦截在系统上游</li>
</ul>
</li>
<li>用缓存降低数据层读请求，不展开<ul>
<li>秒杀买票，这是一个典型的读多写少的业务场景:<ul>
<li>车次查询，读，量大</li>
<li>余票查询，读，量大</li>
<li>下单和支付，写，量小</li>
</ul>
</li>
<li>一趟火车2000张票，200w个 人同时来买，最多2000个人下单成功，其他人都是查询库存，写.</li>
<li>比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。</li>
</ul>
</li>
<li>如何将请求，拦截在系统上游?<ul>
<li>先看看上下游分层架构，秒杀业务，常见的系统分层架构如何?<ul>
<li>浏览器-&gt;站点-&gt;服务-&gt;数据</li>
</ul>
</li>
<li>第一层，端上的请求拦截(浏览器/APP)，可以做一些限速策略，限制用户在 X 秒内只能做一次请求</li>
<li>第二层，站点层的请求拦截，使用 session，用户 uid 或 token 等识别同一用户，进行限速拦截，高级一点可以返回页面缓存，即返回上一次的内容</li>
<li>第三层，服务层的请求拦截，知道了业务层的抗压能力和库存，可以根据此进行限速，使用消息队列或内存中的队列</li>
<li>第四层，数据库闲庭信步，基本不需要做什么，因为到这里访问量应该很低了</li>
</ul>
</li>
<li>(1)按照上面的优化方案,其实压力最大的反而是站点层，假设真实有效的请求数是每秒100w，这部分的压力怎么处理?<ul>
<li>站点层的扩容非常容易，测算出机器的处理能力，直接加机器即可，此外其实不需要所有的请求都处理返回，可以服务降级，把大部分的请求失败掉即可，保护系统是最优先原则</li>
</ul>
</li>
<li>(2)站点层限速，是个每个uid的请求计数放到redis里么?吞吐量很大情况下，高并发访问redis，网络带宽会不会成为瓶颈?<ul>
<li>redis 可以做水平切分，如果担心网络带宽，可以使用内存队列</li>
</ul>
</li>
<li>任何脱离业务的架构设计都是耍流氓，产品+技术，不可分割，产品上，能够如何“优化”，以简化系统架构设计呢?<ul>
<li>case 1 下单与支付分离<ul>
<li>一般来说，下单和支付放在同一个流程里，能够提高转化率。</li>
<li>对于秒杀场景，产品上，下单流程和支付流程异步，放在两个环节里，能够降低数据库写压力。</li>
<li>12306， 下单成功后，系统占住库存，45分钟之内支付即可。</li>
</ul>
</li>
<li>case 2 分城市用户规则差异化<ul>
<li>一般来说，所有用户规则相同，体验会更好。</li>
<li>对于秒杀场景，产品上，不同地域分时售票，虽然不是所有用户规则相同，但能够极大降低系统压力。</li>
<li>北京9:00开始售票，上海9:30开始售票，广州XX开始售票，能够分担系统压力。</li>
</ul>
</li>
<li>case 3 按钮只能点一次<ul>
<li>秒杀场景，由于短时间内并发较大，系统返回较慢，用户心情十分焦急，可能会频繁点击按钮，对系统造成压力。</li>
<li>产品上可以优化为，一旦点击，不管系统是否返回，按钮立刻置灰，不给用户机会频繁点击。</li>
</ul>
</li>
<li>case 4 库存显示粒度加粗<ul>
<li>一般来说，显示具体的库存数量，能够加强用户体验。</li>
<li>对于秒杀场景，产品上，只显示有/无车票，而不是显示具体票数目，能够降低缓存淘汰率。</li>
<li>显示库存会淘汰N次，显示有无只会淘汰1次。更多的，用户关注是否有票，而不是票有几张。</li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>一、秒杀业务为什么难?数据量并不大，但锁冲突巨大</li>
<li>二、系统架构优化，方向上，降低数据层锁冲突<ul>
<li>(1) 降读:用缓存</li>
<li>(2) 降写:把请求拦截在系统上游</li>
</ul>
</li>
<li>三、架构难度大，产品要折衷</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第1章 - 技术选型</title>
    <url>/arch-sj-1/</url>
    <content><![CDATA[<h1 id="2、技术选型：创业初期，技术如何选型"><a href="#2、技术选型：创业初期，技术如何选型" class="headerlink" title="2、技术选型：创业初期，技术如何选型"></a>2、技术选型：创业初期，技术如何选型</h1><ul>
<li>no2：创业初期架构特点、选型依据、选型建议是什么？<ul>
<li>特点：<ul>
<li>1.单机系统(All in one)</li>
<li>2.程序耦合(All in one)</li>
<li>3.逻辑核心是 CURD</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20210823205116.png"></li>
<li>主要依据：选择技术合伙人会的，熟悉的，是早期技术选型的</li>
<li>选型建议：<ul>
<li>PHP体系：Linux、Apache、MySQL、PHP</li>
<li>Java 体系：Linux、Tomcat、MySQL、Java</li>
</ul>
</li>
</ul>
</li>
<li>no2：创业初期工程师的主要矛盾是什么？如何解决？<ul>
<li>矛盾：业务开发效率与质量低，CURD 频繁出错</li>
<li>解决：尽早引入 DAO/ORM 技术</li>
<li>DAO(Data Access Object)：像对象一样访问数据</li>
<li>ORM(Object Relation Mapping)：简化数据库查询过程</li>
<li><img src="https://img.shiqi-lu.tech/20210823205532.png"></li>
</ul>
</li>
</ul>
<h1 id="3、技术选型：框架组件要不要自研，什么时候自研？"><a href="#3、技术选型：框架组件要不要自研，什么时候自研？" class="headerlink" title="3、技术选型：框架组件要不要自研，什么时候自研？"></a>3、技术选型：框架组件要不要自研，什么时候自研？</h1><ul>
<li>no3：框架组件要不要自研，什么时候自研？有哪 4 个观点？<ul>
<li>1.早期不要自研，后期适当自定义</li>
<li>2.随着规模的扩大，要控制技术栈</li>
<li>3.建议浅浅的封装一层</li>
<li>4.随着业务规模，研发团队进一步扩大，适当造一些轮子</li>
</ul>
</li>
<li>no3：为什么说早期不建议自研？<ul>
<li>1.早期的业务以快速迭代为最高优先级，快速实现功能，让公司活下来最重要</li>
<li>2.技术栈选择技术合伙人最熟悉的<ul>
<li>研发语言：熟PHP选PHP，熟Java选Java</li>
<li>数据库：熟MySQL选MySQL，熟SQL-server选SQL-server</li>
<li>框架组件：熟Ruby on Rails选ROR，熟ThinkPHP选ThinkPHP，熟SSH选SSH</li>
</ul>
</li>
<li>3.此时技术栈的选择对合伙人的技术视野有要求，能在未来少踩坑</li>
</ul>
</li>
<li>no3：为什么要控制技术栈？<ul>
<li>1.绝对不能每个人想用什么就用什么，否则会造成混乱</li>
<li>2.即使用开源，技术栈也尽量统一</li>
</ul>
</li>
<li>no3：什么叫「浅浅封装一层」？好处是什么？<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">Memcache::get</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">String <span class="title">Memcache::set</span><span class="params">(String key, String value)</span></span></span><br><span class="line"><span class="function">String <span class="title">Memcache::del</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">String 58<span class="title">DaojiaKV::get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String result = Memcache::get(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>对调用方屏蔽底层实现细节</li>
<li>当底层变化的时候，调用方改动很小</li>
<li>能很方便实现统一的功能，如时间统计等</li>
</ul>
</li>
</ul>
</li>
<li>no3：为什么说随着业务规模和研发团队的扩大可以适当造一些轮子？而不能全部使用开源？<ul>
<li>不同技术团队，痛点是相似的</li>
<li>开源解决不了全部个性化需求<ul>
<li>有站点，监控服务的可用性，处理时间监控需求</li>
<li>有告警需求</li>
<li>有自动化发布，自动化运维需求</li>
<li>有服务治理，服务自动发现需求</li>
<li>有调用链跟踪需求</li>
<li>有SQL监控需求</li>
<li>有系统层面数据收集与可视化展现的需求</li>
</ul>
</li>
<li>自研解决痛点，更贴合团队实际情况<ul>
<li>开源框架/组件太重了，我们需要的可能只是一个轻量级的框架/组件</li>
<li>开源框架/组件，只能满足我们的一部分需求</li>
<li>不了解开源框架/组件的设计理念，要二次开发成本更高</li>
<li>有些通用的需求是和业务紧密结合的，开源框架/组件可能满足不了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4、容量设计：流量高低，对架构究竟有什么影响？"><a href="#4、容量设计：流量高低，对架构究竟有什么影响？" class="headerlink" title="4、容量设计：流量高低，对架构究竟有什么影响？"></a>4、容量设计：流量高低，对架构究竟有什么影响？</h1><ul>
<li>no4：什么时候要进行容量评估？<ul>
<li>1.容量有质变性增长</li>
<li>2.临时运营活动</li>
<li>3.新系统上线</li>
</ul>
</li>
<li>no4：哪些指标要进行容量预估？<ul>
<li>看具体业务，对应到系统侧的主要矛盾是什么，如：</li>
<li>1.数据量</li>
<li>2.并发量，吞吐量</li>
<li>3.带宽</li>
<li>4.CPU/MEM/DISK 等</li>
</ul>
</li>
<li>no4：如何进行容量评估(以吞吐量为例)<ul>
<li>1.评估总访问量：询问产品、运营</li>
<li>2.评估平均访问量：总量除以总时间，一天可算 4w 秒</li>
<li>3.评估高峰 QPS：可根据业务曲线图来</li>
<li>4.评估系统、单机极限 QPS：使用压测</li>
<li>5.根据线上冗余度做决策：计算需求和线上冗余度差值</li>
</ul>
</li>
</ul>
<h1 id="5、伪分布式：你以为，多机就是分布式？"><a href="#5、伪分布式：你以为，多机就是分布式？" class="headerlink" title="5、伪分布式：你以为，多机就是分布式？"></a>5、伪分布式：你以为，多机就是分布式？</h1><ul>
<li>no5：随着流量的提升，早期系统最先遇到的两大问题是什么？如何分析系统特点与瓶颈？<ul>
<li>现象：人多的时候会卡(即慢，性能下降)，压力会导致宕机(即一挂全挂，耦合严重)</li>
<li>瓶颈分析：网络带宽、内存、CPU 计算、磁盘 IO</li>
<li>初步结论：ALL in one 导致单机资源称为瓶颈</li>
</ul>
</li>
<li>no5：架构早期最快速地解决「单机资源瓶颈」问题的思路？做法？原因？<ul>
<li>思路：<ul>
<li>增加硬件资源(时间短)，避免大规模代码重构(时间长)</li>
</ul>
</li>
<li>做法：<ul>
<li>把「单机」变「多机」，用最小的成本，扩展资源</li>
</ul>
</li>
<li>原因：<ul>
<li>此时最大的成本，是时间成本</li>
<li>能用“钱”解决的系统问题，往往不是问题</li>
<li>老板最不愿见到的，是解决一个系统问题， 花很长的时间(市场和投资人等不起)</li>
</ul>
</li>
</ul>
</li>
<li>no5：「单机」变「多机」的伪分布式的「三大分离」应该怎么做？设计思路？没解决的问题？<ul>
<li><img src="https://img.shiqi-lu.tech/20210823225351.png"></li>
<li>三大分离<ul>
<li>1.读写分离(引发读写延时新问题)：将数据库的读写请求分散到不同的数据库机器上</li>
<li>2.动静分离：将静态文件(css、jpg、静态页面)和动态生成的站点分离</li>
<li>3.前台后台分离：前台即用户访问的系统，后台即运营使用的系统</li>
</ul>
</li>
<li>设计思路：用最快的速度，增加硬件资源，提升系统性能，增加访问速度</li>
<li>没解决的问题：<ul>
<li>1.耦合问题：一个子系统挂了，仍然是全站挂</li>
<li>2.主从延时新问题：读写分离只能提升读写性能，无法降低单库数据量</li>
</ul>
</li>
</ul>
</li>
<li>no5：如何解决「三大分离」的耦合问题和读写延时问题？设计思路？如何操作？<ul>
<li><img src="https://img.shiqi-lu.tech/20210823230403.png"></li>
<li>方案：业务垂直拆分，解耦</li>
<li>操作：<ul>
<li>1.业务垂直拆分</li>
<li>2.代码垂直拆分(子系统耦合)</li>
<li>3.数据库垂直拆分(数据量降低，延时缓解)</li>
<li>4.研发团队垂直拆分(专业化，效率提升)</li>
</ul>
</li>
<li>设计思路：用最快的速度，增加硬件资源，解耦</li>
<li>垂直拆分，会随着业务越来越复杂，不断持续地进行</li>
<li>存在问题<ul>
<li>1.对同一个垂直站点子系统，仍然是一个「单体架构」，每一个业务都并不是高可用的，子系统的性能仍然受到单机资源的限制无法扩展</li>
<li>2.子系统不是高可用的，只能保证一个挂了，另一个不受影响</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第2章 - 接入层架构</title>
    <url>/arch-sj-2/</url>
    <content><![CDATA[<h1 id="6、接入层：反向代理，负载均衡，我有话要说"><a href="#6、接入层：反向代理，负载均衡，我有话要说" class="headerlink" title="6、接入层：反向代理，负载均衡，我有话要说"></a>6、接入层：反向代理，负载均衡，我有话要说</h1><ul>
<li>no6：代理和反向代理是什么？<ul>
<li><img src="https://img.shiqi-lu.tech/20210902211250.png"></li>
</ul>
</li>
<li>no6：一般用什么做反向代理？<ul>
<li>软件层面：nginx/apache</li>
<li>操作系统层面：LVS</li>
<li>硬件：F5</li>
</ul>
</li>
<li>no6：反向代理能解决什么问题？带来了什么新的问题？<ul>
<li><img src="https://img.shiqi-lu.tech/20210902211738.png"></li>
<li>解决的问题<ul>
<li>1.子 web 系统的性能，不再受到单台机器资源限制，可以扩展</li>
<li>2.子 web 系统，实现了高可用(伪集群 -&gt; 真集群)</li>
</ul>
</li>
<li>新问题<ul>
<li>1.多个 web 节点，带来负载均衡问题</li>
<li>2.反向代理层需要解决 高可用</li>
</ul>
</li>
</ul>
</li>
<li>no6：反向代理如何实施负载均衡？<ul>
<li>负载均衡方法：随机、轮询、静态权重轮询、动态权重轮询，一致性哈希</li>
<li>负载均衡抓手：四层(转发/交换)，七层(转发/交换)</li>
</ul>
</li>
<li>no6：反向代理如何实现高可用呢？<ul>
<li><img src="https://img.shiqi-lu.tech/20210902213858.png"></li>
<li>使用两个节点使用相同的虚 IP，同时使用 keepalived 来检测 nginx 的可用性，由 nginx 把请求转发给后端实际处理的 web-server</li>
<li>缺点：两个 nginx 实际上只有一台在对外提供服务</li>
</ul>
</li>
</ul>
<h1 id="7、DNS轮询-以及接入层架构演进"><a href="#7、DNS轮询-以及接入层架构演进" class="headerlink" title="7、DNS轮询,以及接入层架构演进"></a>7、DNS轮询,以及接入层架构演进</h1><ul>
<li>no7：接入层的单体架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210905173449.png"></li>
</ul>
</li>
<li>no7：接入层的单体架构-&gt;DNS 轮询<ul>
<li><img src="https://img.shiqi-lu.tech/20210905173524.png"></li>
</ul>
</li>
<li>no7：DNS轮询的缺点是？<ul>
<li>1.系统仍然是非高可用的，只是局部高可用</li>
<li>2.扩容不是实时的</li>
<li>3.暴露了太多的外网 IP</li>
</ul>
</li>
<li>no7：接入层的DNS 轮询-&gt;反向代理<ul>
<li><img src="https://img.shiqi-lu.tech/20210905174112.png"></li>
</ul>
</li>
<li>no7：接入层的反向代理-&gt;高可用反向代理<ul>
<li><img src="https://img.shiqi-lu.tech/20210905174223.png"></li>
</ul>
</li>
<li>no7：接入层的高可用反向代理-&gt;多层高可用反向代理<ul>
<li><img src="https://img.shiqi-lu.tech/20210905174340.png"></li>
<li>反向代理层可使用 lvs 和 f5</li>
</ul>
</li>
<li>no7：接入层的多层高可用反向代理 -&gt; 多层高可用反向代理+DNS 轮询<ul>
<li><img src="https://img.shiqi-lu.tech/20210905174600.png"></li>
</ul>
</li>
</ul>
<h1 id="8、接入层：session一致性，要如何保证？"><a href="#8、接入层：session一致性，要如何保证？" class="headerlink" title="8、接入层：session一致性，要如何保证？"></a>8、接入层：session一致性，要如何保证？</h1><ul>
<li>no8：什么是 session？<ul>
<li>服务器会为每个用户创建一个会话，存储用户的相关信息，以便多次请求，能够定位到同一个上下文</li>
<li>web 开发中，web-server 可以自动地为同一个浏览器的访问用户自动创建 session，提供数据存储功能</li>
<li>最常见的，会把用户登录信息，用户信息存储到 session 中，以保持登录状态</li>
</ul>
</li>
<li>no8：什么是 session 一致性问题？<ul>
<li>只要用户不重启浏览器，用户的每一次 http 短连接都能定位到session，定位到同一台 web-server 以保持会话</li>
</ul>
</li>
<li>no8：解决一致性问题的方案？<ul>
<li>all in one 架构</li>
<li>反向代理架构<ul>
<li>session 同步法</li>
<li>客户端存储法</li>
<li>反向代理 hash 一致性</li>
<li>后端统一存储法</li>
</ul>
</li>
</ul>
</li>
<li>no8：反向代理架构，保证高可用的同时，保证 session 路由的一致性的session 同步法，即站点集群 session 同步<ul>
<li><img src="https://img.shiqi-lu.tech/20210905175525.png"></li>
<li>优点<ul>
<li>由 web-server 支持，应用程序不需要修改任何代码</li>
</ul>
</li>
<li>缺点<ul>
<li>session 的同步需要占用带宽，且数据量受到内存限制，无法进行水平扩展，仅有少量服务器没问题，多台 web-server 性能急剧下降</li>
</ul>
</li>
</ul>
</li>
<li>no8：反向代理架构，保证高可用的同时，保证 session 路由的一致性的客户端存储法，把 session 存储在客户端，把 session 存储在浏览器的 cookie<ul>
<li><img src="https://img.shiqi-lu.tech/20210905175851.png"></li>
<li>优点<ul>
<li>web-server 不需要存储 sesssion</li>
</ul>
</li>
<li>缺点<ul>
<li>每次 http 请求都需要携带 session，占用外网带宽</li>
<li>存在泄露、篡改、窃取等的安全隐患</li>
<li>存储量的大小受到浏览器端上的限制</li>
</ul>
</li>
</ul>
</li>
<li>no8：反向代理架构，保证高可用的同时，保证 session 路由的一致性的反向代理 hash 一致性(四层，七层)，使用反向代理路由来保障<ul>
<li>使用 ip_hash 或 session_id hash 等</li>
<li><img src="https://img.shiqi-lu.tech/20210905222045.png"></li>
<li>优点<ul>
<li>仅需要修改 nginx 的配置，不需要修改应用层的代码，负载是均衡的</li>
<li>能很好支持 web-server 水平扩展</li>
</ul>
</li>
<li>缺点<ul>
<li>一旦 web-server 重启，会丢失一部分 session</li>
<li>如果 web-server 水平扩展，nginx 会进行重新 hash，session 重新分布，会导致一部分用户路由不到正确的 session</li>
<li>以上两点等同于 session 失效，也是可以接受的</li>
</ul>
</li>
<li>建议<ul>
<li>推荐使用四层的 hash，让专业的软件做专业的事情，反向代理负责路由转发，尽量不要引入业务层的业务属性，http 请求中的属性最好不要让 nginx 关注</li>
</ul>
</li>
</ul>
</li>
<li>no8：反向代理架构，保证高可用的同时，保证 session 路由的一致性的后端统一存储法，不存储在站点，统一存储在后端(数据库，缓存)<ul>
<li><img src="https://img.shiqi-lu.tech/20210905222719.png"></li>
<li>优点<ul>
<li>没有安全隐患，session 不用在外网上传输了</li>
<li>可实现 web-server 层的任意水平扩展</li>
<li>当数据量增大时，数据库或缓存进行水平切分即可</li>
<li>web-server 扩容或重启时，都不会有 session 的丢失</li>
</ul>
</li>
<li>缺点<ul>
<li>增加了一次网络调用</li>
<li>需要修改应用层的代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="9、接入层：如何实现就近访问，CDN架构趣谈"><a href="#9、接入层：如何实现就近访问，CDN架构趣谈" class="headerlink" title="9、接入层：如何实现就近访问，CDN架构趣谈"></a>9、接入层：如何实现就近访问，CDN架构趣谈</h1><ul>
<li>no9：什么是 CDN(Content Delivery Network)<ul>
<li>即内容分发网络，它主要依靠部署在各地的服务器，通过内容分发，访问调度等技术，使用户就近获取所需的内容，降低网络阻塞，提高用户的访问速度</li>
<li>适合静态资源的加速访问(js，css，jpg 等)</li>
<li>核心是「就近访问」</li>
</ul>
</li>
<li>no9：什么是「智能 DNS」？<ul>
<li>根据用户的访问 IP 来决定返回的域名 IP</li>
</ul>
</li>
<li>no9：CDN 的架构组成有哪三部分？<ul>
<li>源：数据库</li>
<li>镜像：多个「穿透缓存」</li>
<li>智能 DNS：决定我们访问哪一个</li>
<li><img src="https://img.shiqi-lu.tech/20210906093657.png"></li>
</ul>
</li>
<li>no9：源里的abc.js更新了，镜像里的abc.js没更新，数据不一致,怎么办?<ul>
<li>方案一：源更新的时候，过期掉镜像里的abc.js (缓存淘汰)<ul>
<li>需要在源里维护一个镜像 list 的配置，每次源有静态文件更新的时候需要依次淘汰相关的镜像资源，是一个「反向依赖」的耦合设计，即源依赖了镜像，好的方案应该是源不需要知道镜像的配置</li>
</ul>
</li>
<li>方案二：等待镜像里的abc.js过期(缓存过期)</li>
<li>方案三：版本号，升级为 abc_v1.2.3.js，就能解决(推荐)</li>
</ul>
</li>
<li>no9：当资源更新，是采用源推送还是镜像拉取的方式？<ul>
<li>方案一：资源更新的时候，源一次性推送所有镜像(反向耦合设计)</li>
<li>方案二：发现资源缺失时，镜像主动去源拉取(推荐)</li>
</ul>
</li>
</ul>
<h1 id="10、TCP负载均衡，该怎么玩？"><a href="#10、TCP负载均衡，该怎么玩？" class="headerlink" title="10、TCP负载均衡，该怎么玩？"></a>10、TCP负载均衡，该怎么玩？</h1><ul>
<li>no10：TCP负载均衡的单体架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210906095210.png"></li>
<li>优点：可以保证请求的一致性</li>
<li>缺失：没办法扩展，没办法保证高可用</li>
</ul>
</li>
<li>no10：TCP负载均衡的客户端负载均衡(内置集群配置)<ul>
<li><img src="https://img.shiqi-lu.tech/20210906095522.png"></li>
<li>客户端内置服务器集群的配置，通过搭建 tcp 集群来保证高可用</li>
<li>缺点，每次连接前要多一次 DNS 访问，难以预防 DNS 劫持，解决方法是直接把 IP 配置到客户端中，但这样的扩展性比较差</li>
</ul>
</li>
<li>no10：TCP负载均衡的服务端负载均衡(静态 IP 列表)<ul>
<li><img src="https://img.shiqi-lu.tech/20210906100812.png"></li>
<li>新增一个 http 接口，将客户端的 IP 配置与负载均衡策略放到服务端的 http 接口上，客户端每一次访问 tcp-server 之前，首先调用新增的一个 http 的获取 tcp-server ip 的接口，对于客户端而言，这个 http 接口只返回一个可用的tcp 服务器的 ip</li>
<li>缺点：如果 tcp-server 挂了，web-server 是无法感知的</li>
</ul>
</li>
<li>no10：TCP负载均衡的服务端负载均衡(服务状态上报)<ul>
<li><img src="https://img.shiqi-lu.tech/20210906102011.png"></li>
<li>缺点：反向依赖耦合</li>
</ul>
</li>
<li>no10：TCP负载均衡的服务端负载均衡(服务状态拉取)<ul>
<li><img src="https://img.shiqi-lu.tech/20210906102148.png"></li>
<li>tcp-server就独立与解耦了，只需要专注于自身 tcp-server 业务相关的功能即可，而高可用，负载均衡，扩展性，存活性，都由 web-server 这个子系统去实施</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第3章 - 快速性能优化</title>
    <url>/arch-sj-3/</url>
    <content><![CDATA[<h1 id="11、性能优化：动静分离，互联网优化利器？"><a href="#11、性能优化：动静分离，互联网优化利器？" class="headerlink" title="11、性能优化：动静分离，互联网优化利器？"></a>11、性能优化：动静分离，互联网优化利器？</h1><ul>
<li>no11：与静态页面、动态页面匹配的加速技术有哪些？<ul>
<li>静态页面<ul>
<li>CDN</li>
<li>nginx</li>
<li>squid/varnish</li>
</ul>
</li>
<li>动态页面<ul>
<li>分层架构</li>
<li>服务化架构</li>
<li>数据库，缓存架构</li>
</ul>
</li>
</ul>
</li>
<li>no11：动静分离是什么？<ul>
<li>静态页面与动态页面分开不同的系统访问的架构设计方法</li>
<li><img src="https://img.shiqi-lu.tech/20210906113515.png"></li>
<li>静态页面，几毫秒返回</li>
<li>动态页面，几百毫秒返回</li>
</ul>
</li>
<li>no11：「页面静态化」是什么？如何实施？<ul>
<li><img src="https://img.shiqi-lu.tech/20210906113737.png"></li>
<li>把网页内容提前生成相关的 html，用静态页面相关的加速技术来进行加速</li>
<li>适合场景：返回页面结果集有限</li>
<li>不适合场景：返回页面结果集数据量过大，如帖子，搜索等</li>
</ul>
</li>
</ul>
<h1 id="12、性能优化：读写分离，前台与后台分离"><a href="#12、性能优化：读写分离，前台与后台分离" class="headerlink" title="12、性能优化：读写分离，前台与后台分离"></a>12、性能优化：读写分离，前台与后台分离</h1><ul>
<li>no12：什么是读写分离？能解决什么问题？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908205424.png"></li>
<li>一主多从，读写分离，主从同步，是一种常见的数据库架构</li>
<li>一般来说，主库，提供数据库的写服务，从库，提供数据库的读服务，主从之间通过某种机制来实现数据库的同步，如 MySQL 的 binlog，一个主从同步集群通常被称为一个「分组」</li>
<li>能解决什么问题？<ul>
<li>主要可以线性提升读的性能</li>
</ul>
</li>
</ul>
</li>
<li>no12：什么是水平切分？能解决什么问题？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908205943.png"></li>
<li>数据库水平切分后，数据库之间没有数据的重合，不需要同步</li>
<li>能解决什么问题？<ul>
<li>数据库存储容量提升</li>
</ul>
</li>
</ul>
</li>
<li>no12：什么是前台？什么是后台？<ul>
<li>前台，用户访问的对外系统</li>
<li>后台，运营访问的对内系统</li>
</ul>
</li>
</ul>
<h1 id="13、本章小结：百万流量，这些技术够用了"><a href="#13、本章小结：百万流量，这些技术够用了" class="headerlink" title="13、本章小结：百万流量，这些技术够用了"></a>13、本章小结：百万流量，这些技术够用了</h1><ul>
<li>no13：早期单体 ALL in one 架构，遇到什么问题？这阶段的优化思路是什么？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908211227.png"></li>
<li>性能问题：访问人数多的时候，希望系统快一点</li>
<li>耦合问题：当出现问题的时候，系统不要全部挂掉</li>
<li>思路：<ul>
<li>1.技术不炫技，以解决业务问题为导向</li>
<li>2.系统改造尽可能小的架构方案</li>
<li>3.以最快的速度，提升系统的性能，解决遇到的问题</li>
</ul>
</li>
</ul>
</li>
<li>no13：单体架构演进：伪分布式，提升性能<ul>
<li><img src="https://img.shiqi-lu.tech/20210908211506.png"></li>
<li>三大分离<ul>
<li>动静分离</li>
<li>读写分离(引发读写延时新问题)</li>
<li>前台后台分离</li>
</ul>
</li>
</ul>
</li>
<li>no13：单体架构演进：垂直拆分，解耦<ul>
<li><img src="https://img.shiqi-lu.tech/20210823230403.png"></li>
<li>业务垂直划分</li>
<li>代码垂直划分(子系统解耦)</li>
<li>数据库垂直划分(数据量降低,延时缓解)</li>
<li>研发团队垂直拆分(专业化，效率提升)</li>
</ul>
</li>
<li>no13：如何保证垂直拆分后，子系统的高可用？<ul>
<li>使用反向代理</li>
<li>子web系统的性能，不再受到单台机器资源限制，可以扩展</li>
<li>子web系统，实现了高可用(伪集群-&gt;真集群) </li>
<li><img src="https://img.shiqi-lu.tech/20210908212034.png"></li>
</ul>
</li>
<li>no13：真集群后，反向代理如何做负载均衡？<ul>
<li>负载均衡方法：随机、轮询、静态权重轮询、动态权重轮询，一致性哈希</li>
<li>负载均衡抓手：四层(转发/交换)，七层(转发/交换)</li>
</ul>
</li>
<li>no13：反向代理，如何保证高可用？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908212221.png"></li>
</ul>
</li>
<li>no13：反向代理技术出现之前，接入层如何扩展？<ul>
<li>DNS 轮询</li>
<li><img src="https://img.shiqi-lu.tech/20210908212329.png"></li>
</ul>
</li>
<li>no13：使用多层反向代理后，如何做到继续提升性能？<ul>
<li>DNS 轮询</li>
<li><img src="https://img.shiqi-lu.tech/20210908212439.png"></li>
</ul>
</li>
<li>no13：session 一致性如何保障？<ul>
<li>session 同步法</li>
<li>客户端存储法</li>
<li>反向代理 hash 一致性</li>
<li>后端统一存储法</li>
</ul>
</li>
<li>no13：如何加速静态资源？<ul>
<li>CDN</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第4章 - 微服务架构</title>
    <url>/arch-sj-4/</url>
    <content><![CDATA[<h1 id="14、服务化：微服务架构，究竟解决什么问题？"><a href="#14、服务化：微服务架构，究竟解决什么问题？" class="headerlink" title="14、服务化：微服务架构，究竟解决什么问题？"></a>14、服务化：微服务架构，究竟解决什么问题？</h1><ul>
<li>no14：在服务化前后的互联网的常见架构示意图<ul>
<li>服务化前</li>
<li><img src="https://img.shiqi-lu.tech/20210906114646.png"></li>
<li>服务化后</li>
<li><img src="https://img.shiqi-lu.tech/20210906200739.png"></li>
</ul>
</li>
<li>no14：没有服务化前的痛点<ul>
<li>1.代码到处拷贝<ul>
<li><img src="https://img.shiqi-lu.tech/20210906114751.png"></li>
</ul>
</li>
<li>2.底层复杂性扩散<ul>
<li><img src="https://img.shiqi-lu.tech/20210906114828.png"></li>
</ul>
</li>
<li>3.公共库耦合</li>
<li>4.SQL 质量无法保障<ul>
<li><img src="https://img.shiqi-lu.tech/20210906200420.png"></li>
</ul>
</li>
<li>5.不易扩展，数据库耦合<ul>
<li><img src="https://img.shiqi-lu.tech/20210906200628.png"></li>
</ul>
</li>
</ul>
</li>
<li>no14：服务化的好处<ul>
<li>1.复用性，消除代码拷贝<ul>
<li><img src="https://img.shiqi-lu.tech/20210906200847.png"></li>
</ul>
</li>
<li>2.专注性，防止复杂性扩散<ul>
<li><img src="https://img.shiqi-lu.tech/20210906200929.png"></li>
</ul>
</li>
<li>3.解耦合，消除公共库耦合</li>
<li>4.高质量，SQL 稳定性有保障<ul>
<li><img src="https://img.shiqi-lu.tech/20210906201132.png"></li>
</ul>
</li>
<li>5.易扩展，消除数据库解耦合</li>
<li>6.(最重要)高效，对业务调用方的研发效率提升了</li>
</ul>
</li>
<li>no14：服务化后的潜在问题有哪些？<ul>
<li>1.系统复杂性上升</li>
<li>2.层次间依赖关系变得复杂</li>
<li>3.运维，部署更麻烦</li>
<li>4.监控变得更复杂</li>
<li>5.定位问题更麻烦</li>
</ul>
</li>
</ul>
<h1 id="15、服务化：微服务架构，粒度多少合适？"><a href="#15、服务化：微服务架构，粒度多少合适？" class="headerlink" title="15、服务化：微服务架构，粒度多少合适？"></a>15、服务化：微服务架构，粒度多少合适？</h1><ul>
<li>no15：微服务化架构粒度拆分实践一：统一服务层<ul>
<li><img src="https://img.shiqi-lu.tech/20210907042437.png"></li>
<li>业务不是特别复杂的时候，统一整个服务层，所有数据都通过一个统一的服务层来进行访问</li>
<li>缺点：一旦代码出故障，就将影响整个服务</li>
</ul>
</li>
<li>no15：微服务化架构粒度拆分实践二：一个子业务一个服务(最佳实践)<ul>
<li><img src="https://img.shiqi-lu.tech/20210907042536.png"></li>
<li>在服务层进行垂直拆分，一个子业务抽象出一个服务，数据层也按照子业务垂直拆分</li>
<li>当业务连接关系变得复杂时，加入网关分发层来消除这个网状关系，并在协议设计的时候加入一个协议号服务号，分发层通过协议号服务号将请求路由到相关的子业务服务</li>
<li><img src="https://img.shiqi-lu.tech/20210907043051.png"></li>
</ul>
</li>
<li>no15：微服务化架构粒度拆分实践三：一个数据库一个服务<ul>
<li><img src="https://img.shiqi-lu.tech/20210907043722.png"></li>
</ul>
</li>
<li>no15：微服务化架构粒度拆分实践四：一个接口一个服务<ul>
<li><img src="https://img.shiqi-lu.tech/20210907044101.png"></li>
<li>需要语言特性的支持，如 go 可以这么使用</li>
</ul>
</li>
<li>no15：微服务化架构拆成细粒度优缺点<ul>
<li>优点<ul>
<li>服务能够独立部署，扩容缩容相对方便</li>
<li>能更有效地提高资源利用率</li>
<li>耦合度相对减小</li>
<li>容错性相对更好</li>
<li>扩展性也会更好</li>
</ul>
</li>
<li>缺点<ul>
<li>服务数量变多</li>
<li>系统复杂性增加</li>
<li>依赖关系复杂性增加</li>
<li>运维复杂性增加</li>
<li>监控更复杂</li>
<li>定位问题更复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="16、服务化：微服务架构，必须搞定高可用！"><a href="#16、服务化：微服务架构，必须搞定高可用！" class="headerlink" title="16、服务化：微服务架构，必须搞定高可用！"></a>16、服务化：微服务架构，必须搞定高可用！</h1><ul>
<li>no16：高可用是什么？<ul>
<li>减少系统不能提供服务的时间</li>
</ul>
</li>
<li>no16：如何判断是否高可用？<ul>
<li>随机关停一台线上服务器，如果对用户的服务不受影响，那么系统就是高可用的</li>
</ul>
</li>
<li>no16：如何保障系统的高可用<ul>
<li>1.集群化(冗余)</li>
<li>2.故障自动转移</li>
</ul>
</li>
<li>no16：常见微服务分层架构？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908092416.png"></li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「端」到「反向代理」的高可用<ul>
<li><img src="https://img.shiqi-lu.tech/20210908092543.png"></li>
<li>通过 keepalived + 虚 IP 来实现</li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「反向代理」到「站点应用」的高可用<ul>
<li><img src="https://img.shiqi-lu.tech/20210908092644.png"></li>
<li>通过站点层的冗余来实现</li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「站点应用」到「微服务」的高可用<ul>
<li><img src="https://img.shiqi-lu.tech/20210908092931.png"></li>
<li>通过服务层的冗余来实现，上游有服务连接池</li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「微服务」到「缓存」的高可用(memcache)<ul>
<li><img src="https://img.shiqi-lu.tech/20210908093051.png"></li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「微服务」到「缓存」的高可用(redis)<ul>
<li><img src="https://img.shiqi-lu.tech/20210908093155.png"></li>
<li>但很多时候缓存不需要保证高可用，只要不「雪崩」压垮数据库就行<ul>
<li><img src="https://img.shiqi-lu.tech/20210908093429.png"></li>
<li>将缓存进行水平切分，这也是个集群，但只是用来做分片，并不做数据冗余，在上游设置代理，即进行完水平切分的入口</li>
</ul>
</li>
</ul>
</li>
<li>no16：微服务分层架构如何保证「微服务」到「数据库」的高可用<ul>
<li>如果做了读写分离，必须保证</li>
<li>「微服务」到「读库」的高可用<ul>
<li><img src="https://img.shiqi-lu.tech/20210908094009.png"></li>
<li>通过读库的冗余化集群实现的</li>
</ul>
</li>
<li>「微服务」到「写库」的高可用<ul>
<li><img src="https://img.shiqi-lu.tech/20210908094226.png"></li>
<li>通过写库的冗余化集群实现的，如 MySQL 可通过设置双主相互同步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="17、服务化：微服务架构，必须搞定高并发！"><a href="#17、服务化：微服务架构，必须搞定高并发！" class="headerlink" title="17、服务化：微服务架构，必须搞定高并发！"></a>17、服务化：微服务架构，必须搞定高并发！</h1><ul>
<li>no17：什么是高并发？<ul>
<li>通过设计方案，保证系统能够同时并行的处理很多用户的很多请求</li>
</ul>
</li>
<li>no17：高并发相关的常见指标有哪些？<ul>
<li>1.响应时间(Response Time)</li>
<li>2.吞吐量(Throughput)</li>
<li>3.每秒查询率 QPS(Query Per Second)</li>
<li>4.并发用户数</li>
</ul>
</li>
<li>no17：提升系统并发处理能力的方法论？<ul>
<li>1.垂直扩展(Scale Up)<ul>
<li>1.提升单机硬件性能</li>
<li>2.提升单机架构性能</li>
<li>业务早期建议使用，因为速度最快</li>
</ul>
</li>
<li>2.水平扩展(Scale Out)</li>
</ul>
</li>
<li>no17：常见微服务分层架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210908104829.png"></li>
<li>要想做到整体的性能无限，就必须做到每一层都能够实现水平扩展性能无限</li>
</ul>
</li>
<li>no17：常见微服务分层架构的反向代理层的水平扩展<ul>
<li><img src="https://img.shiqi-lu.tech/20210908104951.png"></li>
<li>之前都是通过 lvs 和 f5 的垂直扩展的方式，这都是有性能上限的，反向代理的水平扩展是通过 DNS 轮询实现的，DNS server 对于同一个域名配置不同的 nginx 外网 IP</li>
</ul>
</li>
<li>no17：常见微服务分层架构的站点应用层的水平扩展<ul>
<li><img src="https://img.shiqi-lu.tech/20210908105303.png"></li>
<li>通过反向代理层实现</li>
</ul>
</li>
<li>no17：常见微服务分层架构的微服务的水平扩展<ul>
<li><img src="https://img.shiqi-lu.tech/20210908105640.png"></li>
<li>通过服务连接池去实现的，站点层通过 rpc client 调用下层的服务层 rpc server，rpc client 会建立多个服务连接，当服务称为瓶颈的时候，只要增加服务节点的数量，rpc client 会建立新的连接</li>
</ul>
</li>
<li>no17：常见微服务分层架构的数据层(缓存，数据库)的水平扩展<ul>
<li>需求<ul>
<li>1.存储容量的扩展，无限容量</li>
<li>2.处理能力的扩展，无限读性能，无限写性能</li>
</ul>
</li>
<li>根据数据的范围水平切分<ul>
<li><img src="https://img.shiqi-lu.tech/20210908110251.png"></li>
<li>优点<ul>
<li>规则简单</li>
<li>数据的均衡性比较好</li>
<li>容易扩展</li>
</ul>
</li>
<li>缺点<ul>
<li>虽然保证数据层是均衡的，但读写请求不一定是均衡的</li>
</ul>
</li>
</ul>
</li>
<li>按照哈希水平切分<ul>
<li><img src="https://img.shiqi-lu.tech/20210908110615.png"></li>
<li>优点<ul>
<li>规则简单</li>
<li>数据均衡性非常好</li>
<li>请求均衡性非常好</li>
</ul>
</li>
<li>缺点<ul>
<li>不容易扩展，扩展可能需要进行数据迁移</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="18、服务化：微服务架构，必须搞定负载均衡！"><a href="#18、服务化：微服务架构，必须搞定负载均衡！" class="headerlink" title="18、服务化：微服务架构，必须搞定负载均衡！"></a>18、服务化：微服务架构，必须搞定负载均衡！</h1><ul>
<li>no18：什么是负载均衡<ul>
<li>将请求或者数据均匀地分摊到多个操作单元上执行<ul>
<li>1.同构，重点在于「均匀」</li>
<li>2.异构，重点在于「负载与能力匹配」</li>
</ul>
</li>
</ul>
</li>
<li>no18：常见微服务分层架构，保证负载均衡的思路<ul>
<li><img src="https://img.shiqi-lu.tech/20210908104829.png"></li>
<li>实现每个上游都实现对下游的均匀访问，即可实现系统整体的均匀分摊</li>
</ul>
</li>
<li>no18：常见微服务分层架构，反向代理层的负载均衡<ul>
<li><img src="https://img.shiqi-lu.tech/20210908130356.png"></li>
<li>DNS 服务器使用 DNS 轮询的方式，即可实现 Nginx 的负载均衡</li>
</ul>
</li>
<li>no18：常见微服务分层架构，站点应用层的负载均衡<ul>
<li><img src="https://img.shiqi-lu.tech/20210908130502.png"></li>
<li>nginx 使用轮询的方式，将请求路由到多个站点应用的后端</li>
</ul>
</li>
<li>no18：常见微服务分层架构，微服务的负载均衡<ul>
<li><img src="https://img.shiqi-lu.tech/20210908135904.png"></li>
<li>通过连接池实现的，可使用随机或轮询等方式保证多个微服务的下游的请求是均匀的</li>
</ul>
</li>
<li>no18：常见微服务分层架构，数据层(缓存，数据库)的负载均衡<ul>
<li>1.数据，均衡</li>
<li>2.请求，均衡</li>
<li>按照数据范围水平切分<ul>
<li><img src="https://img.shiqi-lu.tech/20210908140119.png"></li>
<li>数据负载是均衡的，水平负载未必均衡，如新用户可能更活跃</li>
</ul>
</li>
<li>哈希水平切分<ul>
<li><img src="https://img.shiqi-lu.tech/20210908140647.png"></li>
<li>数据、请求的负载都比较均衡，同构节点的服务器的均衡比较容易</li>
</ul>
</li>
</ul>
</li>
<li>no18：常见微服务分层架构，异构服务器负载均衡，方案一：静态权重<ul>
<li><img src="https://img.shiqi-lu.tech/20210908141258.png"></li>
<li>为下游每个微服务节点设置一个静态权重，表示微服务的处理能力，来调配连接池</li>
<li>优点<ul>
<li>简单粗暴</li>
</ul>
</li>
<li>缺点<ul>
<li>无法自适应地去调节</li>
</ul>
</li>
</ul>
</li>
<li>no18：常见微服务分层架构，异构服务器负载均衡，方案二：动态权重<ul>
<li>1.如何标识服务的处理能力？(下游的处理能力是由调用方决定的)</li>
<li>2.如何设计动态权重？</li>
<li>对每一个微服务的连接使用一个权重来标识，这个权重决定分配给每个微服务请求的概率，获得相应连接的概率，当下游每成功处理一个请求的时候，就认为下游的微服务的处理能力足够，增加权重(缓慢)，当微服务超时处理一个请求的时候，就认为下游的处理能力，可能要跟不上了，权重就减少(快速)</li>
<li>可把权重的范围设置为[0，100]之间，初始值设置为 60，</li>
</ul>
</li>
<li>no18：什么是过载保护？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908142320.png"></li>
<li>如果不对微服务实施过载保护，随着上游的负载越来越高，在微服务的处理能力范围内，每秒处理的请求是越来越高的</li>
<li>但是达到一个负载的极限时，外部负载持续的增加，它的处理能力会掉底，瞬间降为 0，即「雪崩」</li>
<li><img src="https://img.shiqi-lu.tech/20210908142533.png"></li>
<li>如果实施了过载保护，那么随着外部负载的增加，处理能力到达一个 max 值后，会保持相对稳定的一个值，系统不会被完全压垮</li>
</ul>
</li>
<li>no18：如何实施过载保护？<ul>
<li>1.静态权重(粗暴，不优雅)<ul>
<li>给微服务的处理能力设置一个阈值，如果负载超过这个阈值，就将后续的请求全部抛弃</li>
</ul>
</li>
<li>2.动态权重<ul>
<li>1.连接表示服务，分值代表服务(连接)</li>
<li>2.处理成功加小分，处理失败扣大分</li>
<li>3.到达临界编译时，如有请求超时的时候，可判断快要处理不过来了，让它有请求处理失败的时候休息一会，再接下来 10 秒内不再给这个超时的服务器进行负载分配</li>
<li>4.如果仍然连续地超时，可能判定这个服务器完全处理不过来了，如 fullGC，根据经验，fullGC 差不多一分钟之后能回过神，则一分钟后给它分配请求</li>
<li>但如果整体负载超过了微服务集群的整体负载，最终还是要抛弃部分请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="20、服务化：连接池，高可用可扩展负载均衡都离不开他"><a href="#20、服务化：连接池，高可用可扩展负载均衡都离不开他" class="headerlink" title="20、服务化：连接池，高可用可扩展负载均衡都离不开他"></a>20、服务化：连接池，高可用可扩展负载均衡都离不开他</h1><ul>
<li>no20：微服务分层架构中，连接池的位置<ul>
<li><img src="https://img.shiqi-lu.tech/20210908201431.png"></li>
</ul>
</li>
<li>no20：高可用，故障转移，在连接池中是如何实现的？<ul>
<li><img src="https://img.shiqi-lu.tech/20210908201526.png"></li>
<li>当有节点失效时，连接池重试也连接不上，则连接池会把失败的连接剔除出去</li>
</ul>
</li>
<li>no20：扩展性，服务发现，在连接池的实现<ul>
<li>1.自动载入新服务节点的配置<ul>
<li>方案一：监控配置文件，并重新载入<ul>
<li>具体实现可以是启动一个进程，监控文件变化，循环检测文件 md5是否变化，如果变化则读取新服务节点的配置</li>
</ul>
</li>
<li>方案二：配置中心回调，并重新载入<ul>
<li>每当调用方站点集群向配置中心注册了下游所依赖的微服务集群的配置，如果微服务集群的节点发生了变化配置中心会给调用方的站点集群进行回调，会将变化后的节点通知站点集群，再实施连接池自动增删节点</li>
</ul>
</li>
</ul>
</li>
<li>2.动态连接池</li>
</ul>
</li>
<li>no20：负载均衡，连接池的实现的三个方案<ul>
<li>方案一：随机/轮询(同构服务器)<ul>
<li><img src="https://img.shiqi-lu.tech/20210908203120.png"></li>
</ul>
</li>
<li>方案二：静态权重法(异构服务器)<ul>
<li><img src="https://img.shiqi-lu.tech/20210908204445.png"></li>
</ul>
</li>
<li>方案二：动态权重法(异构服务器)<ul>
<li><img src="https://img.shiqi-lu.tech/20210908204559.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第5章 - 微服务架构</title>
    <url>/arch-sj-5/</url>
    <content><![CDATA[<h1 id="21、数据库：读性能要如何提升？"><a href="#21、数据库：读性能要如何提升？" class="headerlink" title="21、数据库：读性能要如何提升？"></a>21、数据库：读性能要如何提升？</h1><ul>
<li>no21：数据库工程架构，要设计些什么呢？<ul>
<li>1.根据「业务模式」设计库表结构</li>
<li>2.根据「访问模式」设计索引结构</li>
</ul>
</li>
<li>no21：数据库工程架构必须要考虑哪 5 个因素？<ul>
<li>读性能提升</li>
<li>高可用</li>
<li>一致性保障</li>
<li>扩展性</li>
<li>垂直拆分</li>
</ul>
</li>
<li>no21：提升数据的读性能的方案一：建立索引<ul>
<li>潜在问题<ul>
<li>写性能降低</li>
<li>索引占用内存大，buffer命中率降低， 读性能降低</li>
</ul>
</li>
<li>实践：可以为主实例不建立索引，从实例建立不同的索引<ul>
<li><img src="https://img.shiqi-lu.tech/20210909103013.png"></li>
</ul>
</li>
</ul>
</li>
<li>no21：提升数据的读性能的方案二：增加从库<ul>
<li>分组架构，主要解决的，就是读性能提升的问题，但没有解决数据容量的扩展以及写高可用的问题，分组会引发主从一致性问题，从库越多，同步越慢，主从一致性的问题就越严重</li>
<li><img src="https://img.shiqi-lu.tech/20210909103738.png"></li>
</ul>
</li>
<li>no21：提升数据的读性能的方案三：增加缓存<ul>
<li><img src="https://img.shiqi-lu.tech/20210909104021.png"></li>
<li>左边是服务化前，右边是服务化后，s 是从库，m 是主库</li>
</ul>
</li>
</ul>
<h1 id="22、数据库：垂直拆分与高可用"><a href="#22、数据库：垂直拆分与高可用" class="headerlink" title="22、数据库：垂直拆分与高可用"></a>22、数据库：垂直拆分与高可用</h1><ul>
<li>no22：数据库垂直拆分的方法论是什么？<ul>
<li>1.长度较短</li>
<li>2.访问频率较高</li>
<li>3.经常一起访问</li>
<li>的属性放在主表里，原因是，数据库缓冲池，逻辑上，以 row 为单位缓冲数据</li>
</ul>
</li>
<li>no22：数据库的高可用的思路和问题是什么？<ul>
<li>数据库的高可用设计，也是冗余+故障自动转移</li>
<li>但是，方法论上:数据库的冗余，会引发一致性问题！因为多个节点数据库没办法同时修改，中间会有个时间差，就有可能引发一致性的问题</li>
</ul>
</li>
<li>no22：读库高可用的方案<ul>
<li>读库高可用，冗余从库，可一主多从，主库会把主库的写序列通过 binlog 的方式同步给从库，重复执行相同的序列</li>
<li><img src="https://img.shiqi-lu.tech/20210909211447.png"></li>
</ul>
</li>
<li>no22：写库高可用的方案<ul>
<li>写库高可用，冗余写库，</li>
<li><img src="https://img.shiqi-lu.tech/20210909211821.png"></li>
<li>1.双主同步一个节点对外提供读写服务，另一个节点是备份节点，他们之间使用相同的 vip，通过 keepalived 去检测</li>
<li>2.在分组架构中加入一个双主节点，冗余写库，两边进行相互的同步，两个主库同时对线上提供服务</li>
</ul>
</li>
</ul>
<h1 id="23、数据库：主从一致性，主主一致性如何保障？"><a href="#23、数据库：主从一致性，主主一致性如何保障？" class="headerlink" title="23、数据库：主从一致性，主主一致性如何保障？"></a>23、数据库：主从一致性，主主一致性如何保障？</h1><ul>
<li>no23：主从数据冗余，主从数据不一致的情况是怎样？<ul>
<li><img src="https://img.shiqi-lu.tech/20210911164115.png"></li>
<li>应用写一个数据后，在主从数据库同步完成前读同一个数据，造成数据不一致</li>
</ul>
</li>
<li>no23：主从数据冗余，主从数据不一致的 3 个解决方案是什么？<ul>
<li>方案一：忽略不计<ul>
<li>中间时间估计约几百毫秒，业务允许的情况下，可不做处理</li>
</ul>
</li>
<li>方案二：强制读主<ul>
<li><img src="https://img.shiqi-lu.tech/20210911164509.png"></li>
<li>都读写主库，然后使用缓存来提升读性能，但主库和缓存间也有一致性问题</li>
</ul>
</li>
<li>方案三：选择性读主(需要缓存协助)<ul>
<li>写操作过程<ul>
<li><img src="https://img.shiqi-lu.tech/20210911164936.png"></li>
<li>写完后，使用哪个库、哪个表、哪个主键拼接一个 key，设置到缓存里，并将这个 key 的时间记录为主从同步的时延</li>
</ul>
</li>
<li>读操作过程<ul>
<li><img src="https://img.shiqi-lu.tech/20210911171749.png"></li>
<li>先读缓存，如果没有，再读从库</li>
<li>如果有，则读主库</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>no23：主主数据冗余，为什么主主数据会不一致？<ul>
<li>因为同时对外提供服务，并发的写入可能会造成数据同步失败，这个比主从的同步时延要严重，这个可能会造成数据丢失</li>
<li><img src="https://img.shiqi-lu.tech/20210911172110.png"></li>
</ul>
</li>
<li>no23：主主数据冗余，主主数据不一致的 3 种解决方案是什么？<ul>
<li>方案一：数据库层面解决，不同初始值，相同递增步长<ul>
<li><img src="https://img.shiqi-lu.tech/20210911172541.png"></li>
</ul>
</li>
<li>方案二：数据库上层应用程序控制 id 生成<ul>
<li><img src="https://img.shiqi-lu.tech/20210911172828.png"></li>
</ul>
</li>
<li>方案三：主主同时服务，升级为单主服务，影子主不服务<ul>
<li>即keepalived+vip</li>
<li><img src="https://img.shiqi-lu.tech/20210911173410.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="24、数据库：扩展性，要如何解决？"><a href="#24、数据库：扩展性，要如何解决？" class="headerlink" title="24、数据库：扩展性，要如何解决？"></a>24、数据库：扩展性，要如何解决？</h1><ul>
<li>no24：数据库扩展性有哪些场景？<ul>
<li>1.底层表结构变更<ul>
<li><img src="https://img.shiqi-lu.tech/20210911174223.png"></li>
</ul>
</li>
<li>2.水平扩展，分库个数变化<ul>
<li><img src="https://img.shiqi-lu.tech/20210912221639.png"></li>
</ul>
</li>
<li>3.底层存储介质变化<ul>
<li><img src="https://img.shiqi-lu.tech/20210912221613.png"></li>
</ul>
</li>
</ul>
</li>
<li>no24：数据库进行扩展有哪五个方案？<ul>
<li>1.停服扩展(离线，非高可用)</li>
<li>2.pt-online-schema-change(在线表结构变更)(平滑)</li>
<li>3.追日志方案(平滑)</li>
<li>4.双写方案(平滑)</li>
<li>5.秒级成倍扩容(平滑)</li>
</ul>
</li>
<li>no24：数据库扩展的停服扩展的步骤是怎样的？优缺点是什么？<ul>
<li>步骤<ul>
<li>1.挂公告</li>
<li>2.离线迁移数据</li>
<li>3.切到新库</li>
<li><img src="https://img.shiqi-lu.tech/20210912222521.png"></li>
</ul>
</li>
<li>优点<ul>
<li>直观和简单</li>
</ul>
</li>
<li>缺点<ul>
<li>对服务的可用性有影响</li>
<li>必须在指定的时间完成升级，对技术人员压力非常大，一旦出现问题必须在规定时间内解决，否则只能回滚</li>
</ul>
</li>
</ul>
</li>
<li>no24：数据库扩展的pt-online-schema-change(在线表结构变更)步骤、注意事项是什么？<ul>
<li>步骤<ul>
<li>1.创建一个扩展字段后的新表</li>
<li>2.在原表上创建三个触发器，对原表的所有写操作(insert、delete、update)都会对新表进行完全相同的操作</li>
<li>3.工具会分批地将原表中的数据分段地导入到新表</li>
<li>4.删除掉触发器，并将原表移走</li>
<li>5.将新建的新表重命名</li>
<li>整个过程不需要锁表，可以持续对外提供服务，rename 前是旧表，rename 前是新表</li>
</ul>
</li>
<li>注意事项<ul>
<li>1.变更过程中最重要的是处理冲突，原则是以触发器的最新数据为准，这要求被迁移的表必须有主键</li>
<li>2.在变更额度过程中，由于写操作要新建触发器，所以如果原表已有非常多的触发器，这个方案就不可行，但通常会禁用触发器</li>
<li>3.触发器的建立会影响原表的性能，这个操作必须在流量的低峰期进行</li>
<li>4.只适合 MySQL，也只适合表结构变更</li>
</ul>
</li>
</ul>
</li>
<li>no24：数据库扩展的追日志方案的步骤是什么？<ul>
<li>步骤<ul>
<li>1.由旧库继续提供服务，并对服务进行一次升级，记录对旧库上的修改的日志，不需记录详细数据，只需记录哪个库哪个表哪个主键在什么时间被修改即可<ul>
<li><img src="https://img.shiqi-lu.tech/20210914093745.png"></li>
<li>风险小，写接口的数量有限，改动点较少，升级过程增加了一些日志，对业务功能没有任何的影响</li>
</ul>
</li>
<li>2.研发数据迁移工具，将数据从旧库迁移到新库<ul>
<li><img src="https://img.shiqi-lu.tech/20210914093810.png"></li>
</ul>
</li>
<li>3.研发一个读取日志，看哪个库哪个表哪个主键发生了写操作，并将这些 key 从旧库再次覆盖到新库中，来对迁移数据过程里产生的数据差异进行追平，无论如何，当发生冲突时，以旧库中的数据为准，因为旧库的数据在实时更新<ul>
<li><img src="https://img.shiqi-lu.tech/20210914093830.png"></li>
</ul>
</li>
<li>4.研发数据比对工具，将旧库和新库的数据进行比对，直到数据完全一致，才能修改配置迁库<ul>
<li><img src="https://img.shiqi-lu.tech/20210914094907.png"></li>
</ul>
</li>
<li>5.迁移流量，对旧库进行一次秒级的 readonly，等日志重放程序完全追上之后，秒级的进行一个流量的切换<ul>
<li><img src="https://img.shiqi-lu.tech/20210914094828.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="25、数据库：扩展性，平滑扩容方案？"><a href="#25、数据库：扩展性，平滑扩容方案？" class="headerlink" title="25、数据库：扩展性，平滑扩容方案？"></a>25、数据库：扩展性，平滑扩容方案？</h1><ul>
<li>no25：数据库平滑迁移的双写方案的 4 个步骤<ul>
<li>1.首先旧库提供服务，先对服务进行升级，对数据修改写接口，并在新库上进行相同的操作<ul>
<li><img src="https://img.shiqi-lu.tech/20210914101758.png"></li>
</ul>
</li>
<li>2.研发数据迁移工具，对数据进行迁移<ul>
<li><img src="https://img.shiqi-lu.tech/20210914102216.png"></li>
</ul>
</li>
<li>3.数据比对<ul>
<li><img src="https://img.shiqi-lu.tech/20210914102317.png"></li>
</ul>
</li>
<li>4.流量迁移<ul>
<li><img src="https://img.shiqi-lu.tech/20210914102405.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="26、数据库：水平切分，数据库秒级扩容！"><a href="#26、数据库：水平切分，数据库秒级扩容！" class="headerlink" title="26、数据库：水平切分，数据库秒级扩容！"></a>26、数据库：水平切分，数据库秒级扩容！</h1><ul>
<li>no26：数据库水平切分，秒级成倍扩容的 3 个步骤<ul>
<li>前提条件<ul>
<li>实施了微服务的分层架构，大数据量进行了水平切分，高可用做了 keepalived 加 vip</li>
</ul>
</li>
<li>步骤<ul>
<li>1.修改配置(双虚 IP，微服务数据库路由)<ul>
<li><img src="https://img.shiqi-lu.tech/20210914103537.png"></li>
</ul>
</li>
<li>2.服务层 reload 配置，实例增倍完成<ul>
<li><img src="https://img.shiqi-lu.tech/20210914104206.png"></li>
<li>reload 配置方案<ul>
<li>1.重启服务，读新文件</li>
<li>2.配置中心给服务层发信号，重新读取配置文件</li>
</ul>
</li>
</ul>
</li>
<li>3.收尾：解除旧双主同步，新增新的双主同步，删除冗余数据，数据量减半完成<ul>
<li><img src="https://img.shiqi-lu.tech/20210914104102.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第6章 - 缓存架构</title>
    <url>/arch-sj-6/</url>
    <content><![CDATA[<h1 id="27、缓存：进程内缓存要怎么玩？"><a href="#27、缓存：进程内缓存要怎么玩？" class="headerlink" title="27、缓存：进程内缓存要怎么玩？"></a>27、缓存：进程内缓存要怎么玩？</h1><ul>
<li>no27：什么是进程内缓存？好处？不足？<ul>
<li>定义<ul>
<li>将数据缓存在站点或者服务的进程内，如 map 或 leveldb，可存 json、html、object 等</li>
</ul>
</li>
<li>好处<ul>
<li>1.节省内网带宽</li>
<li>2.时延更低</li>
</ul>
</li>
<li>不足：一致性难以保证</li>
</ul>
</li>
<li>no27：如何保证进程内缓存的一致性？<ul>
<li>方案一，单节点通知其它节点<ul>
<li><img src="https://img.shiqi-lu.tech/20210915183312.png"></li>
<li>缺点<ul>
<li>同一功能在集群内的多个节点相互耦合在一起，当节点比较多的时候，连接关系会相对比较复杂</li>
</ul>
</li>
</ul>
</li>
<li>方案二，MQ 解耦，通知其它节点<ul>
<li><img src="https://img.shiqi-lu.tech/20210915183448.png"></li>
<li>缺点<ul>
<li>接触了结点耦合，但引入了 mq，增加系统复杂度</li>
</ul>
</li>
</ul>
</li>
<li>方案三，放弃实时一致性，定期从后端更新数据<ul>
<li><img src="https://img.shiqi-lu.tech/20210915183706.png"></li>
<li>缺点<ul>
<li>必须一定程度上接受读旧数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>no27：使用进程内缓存的场景是哪些？为什么不能频繁使用进程内缓存？<ul>
<li>场景<ul>
<li>1.只读数据</li>
<li>2.并发极高，透传后端压力极大</li>
<li>3.允许一定程度上数据不一致</li>
</ul>
</li>
<li>原因<ul>
<li>违背了「站点无状态、服务无状态」的设计准则</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="28、缓存：很多时候我们都用错了！"><a href="#28、缓存：很多时候我们都用错了！" class="headerlink" title="28、缓存：很多时候我们都用错了！"></a>28、缓存：很多时候我们都用错了！</h1><ul>
<li>no28：缓存有哪 4 种误用的情况？<ul>
<li>1.服务与服务之间不要通过缓存传递数据，数据传递使用 MQ 更合适<ul>
<li><img src="https://img.shiqi-lu.tech/20210916114648.png"></li>
</ul>
</li>
<li>2.如果缓存挂掉，可能导致雪崩，此时要做高可用缓存，或者水平切分</li>
<li>3.调用方不宜再单独使用缓存存储服务底层的数据，容易出现数据不一致，以及反向依赖.</li>
<li>4.不同服务，缓存实例要做垂直拆分，不宜共用缓存<ul>
<li><img src="https://img.shiqi-lu.tech/20210916114908.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="29、缓存：互联网最佳实践！"><a href="#29、缓存：互联网最佳实践！" class="headerlink" title="29、缓存：互联网最佳实践！"></a>29、缓存：互联网最佳实践！</h1><ul>
<li>no29：互联网缓存最佳实践 Cache Aside Pattern 是什么？<ul>
<li>读实践<ul>
<li>先缓存，命中返回，未命中读数据库，再设置缓存</li>
<li><img src="https://img.shiqi-lu.tech/20210916205244.png"></li>
</ul>
</li>
<li>写实践<ul>
<li>淘汰缓存而不是修改缓存，先操作数据库，而不是先淘汰缓存</li>
<li><img src="https://img.shiqi-lu.tech/20210916210847.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="30、缓存：一致性优化！"><a href="#30、缓存：一致性优化！" class="headerlink" title="30、缓存：一致性优化！"></a>30、缓存：一致性优化！</h1><ul>
<li>no30：数据库主从、数据库缓存什么时候会发生数据不一致问题？<ul>
<li>数据库主从：写后立即读，短时间内，读旧数据<ul>
<li><img src="https://img.shiqi-lu.tech/20210916212948.png"></li>
</ul>
</li>
<li>数据库缓存：写后立即读，短时间内，旧数据入缓存<ul>
<li><img src="https://img.shiqi-lu.tech/20210916213008.png"></li>
</ul>
</li>
</ul>
</li>
<li>no30：缓存不一致的优化思路和两个方案是什么？<ul>
<li>思路：在从库同步完成之后，如果有旧数据入缓存，应该及时把这个旧数据淘汰掉</li>
<li>方案一：二次淘汰法(在从库异步淘汰，或服务中异步淘汰)<ul>
<li><img src="https://img.shiqi-lu.tech/20210916213215.png"></li>
<li>通过工具订阅从库的 binlog，如 DTS 或 canal，或自己订阅和分析 binlog，然后从库执行异步淘汰缓存的操作</li>
</ul>
</li>
<li>方案二：为允许 cache miss 的场景，设定超时时间</li>
</ul>
</li>
</ul>
<h1 id="31、缓存：并发更新的大坑！"><a href="#31、缓存：并发更新的大坑！" class="headerlink" title="31、缓存：并发更新的大坑！"></a>31、缓存：并发更新的大坑！</h1><ul>
<li>no31：缓存并发更新获取 token 会出现什么问题？如何解决？<ul>
<li>问题<ul>
<li>两个并发请求的token申请，可能导致 token 迭代过期了</li>
<li><img src="https://img.shiqi-lu.tech/20210917100503.png"></li>
</ul>
</li>
<li>解决<ul>
<li>线上服务 s1 和 s2 只从缓存中读取 token，token 的更新由一个异步的服务 asy-Master 定期更新，避免并发的更新</li>
<li>缺点<ul>
<li>读取服务和更新的服务会直接调用缓存实例，如果缓存实例变更，读的服务和写的服务配置同步变更，导致耦合，违背了两个服务不应访问同一服务的通用性原则，同时违反了 cache aside pattern 的淘汰而不是更新缓存的设计准则</li>
</ul>
</li>
<li>数据存储在 DB，缓存应该淘汰，有时候，数据不在数据库，缓存需要更新，如调用第三方服务需要申请 token</li>
<li><img src="https://img.shiqi-lu.tech/20210917100642.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="32、缓存：究竟选redis，还是memcache？"><a href="#32、缓存：究竟选redis，还是memcache？" class="headerlink" title="32、缓存：究竟选redis，还是memcache？"></a>32、缓存：究竟选redis，还是memcache？</h1><ul>
<li>no32，什么时候选 Redis，什么时候选 memcache？<ul>
<li>选 Redis<ul>
<li>1.复杂数据结构</li>
<li>2.持久化<ul>
<li>优点是，缓存挂了再重启，可以快速恢复，不需要 cache 的预热功能</li>
<li>但不建议使用，因为可能会导致缓存和数据库不一致</li>
</ul>
</li>
<li>3.天然高可用，支持主从复制，读写分离，提供了 sentinel 的集群管理工具，能够实现主从服务的监控，故障自动转移，mc 需要二次开发，但绝大多数缓存不需要做高可用</li>
<li>4.存储内容比较大，mc 的 kv 存储的 value 最大只支持 1M</li>
</ul>
</li>
<li>选 memcache<ul>
<li>纯 kv</li>
<li>原因：<ul>
<li>1.预分配内存池</li>
<li>2.redis 的 VM 机制更慢</li>
<li>3.redis 的 CPU 计算复杂</li>
<li>4.多线程可利用多核</li>
</ul>
</li>
</ul>
</li>
<li>其它<ul>
<li>1.redis 源码可读性好</li>
<li>2.redis 和 mc 都需要手动水平切分</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第7章 - 架构解耦</title>
    <url>/arch-sj-7/</url>
    <content><![CDATA[<h1 id="34、解耦：配置中心，与配置架构演进。"><a href="#34、解耦：配置中心，与配置架构演进。" class="headerlink" title="34、解耦：配置中心，与配置架构演进。"></a>34、解耦：配置中心，与配置架构演进。</h1><ul>
<li>no34：配置文件架构有什么核心痛点？<ul>
<li>1.上游痛：扩容的是下游，改配置重启的是上游(耦合，典型反向依赖)</li>
<li>2.下游痛：不知道谁依赖于自己(难以实施服务治理)</li>
</ul>
</li>
<li>no34：配置文件架构怎么解耦？<ul>
<li>1.「配置私藏」架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210919152754.png"></li>
<li>上游把下游的配置私藏在自己单独的配置文件里</li>
<li>不足：例如需要扩容时，下游需要通知所有的上游调用方去修改各自私藏的配置，并重启上游，将连接连到新的集群节点上去，将流量从下线的节点迁走</li>
</ul>
</li>
<li>2.「全局配置文件」架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210919153259.png"></li>
<li>运维制定一系列配置文件规范，将通用的服务的配置放到 global.conf 全局配置文件里，调用方升级，不再读取本地的私有配置文件，而是读取全局配置文件去获取通用服务的配置，配合文件监控组件和动态连接池组件能够实现自动的扩容与缩容，但依然解决不了下游服务治理的问题</li>
<li>优点<ul>
<li>下游容量变化时只需修改一个地方，调用方重启后会自动读取新配置，对架构的改动较小</li>
</ul>
</li>
<li>不足<ul>
<li>如果调用方一直不重启，就没办法迁移</li>
</ul>
</li>
</ul>
</li>
<li>3.「配置中心」架构<ul>
<li><img src="https://img.shiqi-lu.tech/20210919153652.png"></li>
<li>由服务、zookeeper、后台配置文件和落地的数据库组成</li>
<li>所有服务的配置都维护在配置中心里，所有调用方需要注册配置中心，去配置中心拉取相关的配置，此时全局调用关系图和服务治理，以及按照上游的调用方来限流，就容易实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="35、MQ，互联网架构解耦利器。"><a href="#35、MQ，互联网架构解耦利器。" class="headerlink" title="35、MQ，互联网架构解耦利器。"></a>35、MQ，互联网架构解耦利器。</h1><ul>
<li>no35：什么时候不用 MQ？什么时候用 MQ？<ul>
<li>不用<ul>
<li>上游实时关注执行结果，通常采用 RPC</li>
</ul>
</li>
<li>用<ul>
<li>1.数据驱动的任务依赖，如下一个任务依赖上一个任务的执行结果</li>
<li>2.上游不关心执行结果</li>
<li>3.上游关注结果，但执行时间很长，如是离线处理或者跨公网调用的时候，经常使用回调网关加 mq 解耦的方案</li>
<li>4.削峰填谷，流量控制，保护下游：使用 MQ 的拉取模式，消息的消费方根据自己的处理能力来拉取消息，可实现流量控制，能够达到自身保护的效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="36、解耦：MQ，平滑迁移。"><a href="#36、解耦：MQ，平滑迁移。" class="headerlink" title="36、解耦：MQ，平滑迁移。"></a>36、解耦：MQ，平滑迁移。</h1><ul>
<li>no36：如何实现 MQ 的平滑迁移？如何快速实现统一迁移？<ul>
<li>步骤<ul>
<li>1.消费方双向订阅<ul>
<li><img src="https://img.shiqi-lu.tech/20210919161429.png"></li>
</ul>
</li>
<li>2.生产方升级为新发布<ul>
<li><img src="https://img.shiqi-lu.tech/20210919161457.png"></li>
</ul>
</li>
<li>3.消费方下线旧订阅<ul>
<li><img src="https://img.shiqi-lu.tech/20210919161530.png"></li>
</ul>
</li>
</ul>
</li>
<li>快速实现统一迁移<ul>
<li>浅浅地封装一层后，可简单地升级一下组件即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="37、解耦：IP耦合，公共库耦合，解耦实践。"><a href="#37、解耦：IP耦合，公共库耦合，解耦实践。" class="headerlink" title="37、解耦：IP耦合，公共库耦合，解耦实践。"></a>37、解耦：IP耦合，公共库耦合，解耦实践。</h1><ul>
<li>no37：如何发现系统中的耦合？<ul>
<li>查找「被动联动」的点</li>
</ul>
</li>
<li>no37：「IP 耦合」如何解耦<ul>
<li>使用内网域名来替代内网 IP</li>
<li><img src="https://img.shiqi-lu.tech/20210919165206.png"></li>
</ul>
</li>
<li>no37：「公共库耦合」如何解耦<ul>
<li>1.代码各自拷贝一份</li>
<li>2.垂直拆分，个性业务代码「上浮」<ul>
<li><img src="https://img.shiqi-lu.tech/20210919165326.png"></li>
</ul>
</li>
<li>3.服务化，共性业务代码「下沉」<ul>
<li><img src="https://img.shiqi-lu.tech/20210919165415.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="38、解耦：数据库耦合，解耦实战！"><a href="#38、解耦：数据库耦合，解耦实战！" class="headerlink" title="38、解耦：数据库耦合，解耦实战！"></a>38、解耦：数据库耦合，解耦实战！</h1><ul>
<li>no38：如何对「数据库耦合」进行解耦？<ul>
<li>1.公共数据访问服务化，屏蔽底层数据访问的复杂性，屏蔽分库分表，屏蔽读写分离，屏蔽缓存与数据库，将数据私藏<ul>
<li><img src="https://img.shiqi-lu.tech/20210919171009.png"></li>
</ul>
</li>
<li>2.个性数据访问，自己家的数据自己管理，要么通过 DAO 访问数据库，要么子业也建立个性化数据访问的服务，本质是垂直拆分</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>《沈剑架构师训练营》第8章 - 架构分层</title>
    <url>/arch-sj-8/</url>
    <content><![CDATA[<h1 id="40、分层：互联网分层架构方法论"><a href="#40、分层：互联网分层架构方法论" class="headerlink" title="40、分层：互联网分层架构方法论"></a>40、分层：互联网分层架构方法论</h1><ul>
<li>no40：互联网分层架构的的本质是什么？<ul>
<li>这是一个「数据移动」，然后「被处理」，被「呈现」的过程</li>
</ul>
</li>
<li>no40：数据移动过程中最重要的两点是什么？<ul>
<li>1.数据传输的格式</li>
<li>2.数据在各个层次的形态</li>
</ul>
</li>
<li>no40：架构分层的方法论是什么？<ul>
<li>1.让上游更高效地获取与处理数据，复用</li>
<li>2.让下游能屏蔽数据的获取细节，封装</li>
</ul>
</li>
</ul>
<h1 id="41、分层：DAO与服务化。"><a href="#41、分层：DAO与服务化。" class="headerlink" title="41、分层：DAO与服务化。"></a>41、分层：DAO与服务化。</h1><ul>
<li>no41：何时应该引入 DAO<ul>
<li>为了屏蔽数据库数据细节时</li>
</ul>
</li>
<li>no41：何时需要基础数据服务化分层<ul>
<li>为了屏蔽垂直拆分，分库分表，缓存细节时</li>
</ul>
</li>
</ul>
<h1 id="42、分层：业务服务层，是否有必要？"><a href="#42、分层：业务服务层，是否有必要？" class="headerlink" title="42、分层：业务服务层，是否有必要？"></a>42、分层：业务服务层，是否有必要？</h1><ul>
<li>no42：何时需引入业务服务层<ul>
<li>为了屏蔽多个基础服务的调用时</li>
<li><img src="https://img.shiqi-lu.tech/20210919175852.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210919175921.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210919180000.png"></li>
</ul>
</li>
</ul>
<h1 id="43、分层：前后端分离"><a href="#43、分层：前后端分离" class="headerlink" title="43、分层：前后端分离"></a>43、分层：前后端分离</h1><ul>
<li>no43：什么时候需要前后端分离？<ul>
<li>为了屏蔽端上多变，PC/H5/APP 等产品复杂性时，因为设备兼容性，折磨着 MVC 的工程师，PC/H5/APP 等前端展现变化的频率，远大于后端业务逻辑变化的频率</li>
<li><img src="https://img.shiqi-lu.tech/20210919181925.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210919181845.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210919181858.png"></li>
</ul>
</li>
</ul>
<h1 id="44、分层：数据库中间件"><a href="#44、分层：数据库中间件" class="headerlink" title="44、分层：数据库中间件"></a>44、分层：数据库中间件</h1><ul>
<li>no44：何时需要数据库中间件？<ul>
<li>为了屏蔽数据库层面的复杂性时，如<ul>
<li>有些数据需要路由到特定的水平切分库</li>
<li>有些数据不确定落在哪一个水平切分库，就需要访问所有库</li>
<li>有些数据需要访问全局的库，拿到数据的全局视野，到service层进行额外处理</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20210919184348.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210919184210.png"></li>
<li>引入数据库中间件，基于客户端<ul>
<li><img src="https://img.shiqi-lu.tech/20210919184234.png"></li>
</ul>
</li>
<li>基于服务端，对上游而言，它就是数据库<ul>
<li><img src="https://img.shiqi-lu.tech/20210919184316.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>六种不同的二分查找全总结</title>
    <url>/binary-search/</url>
    <content><![CDATA[<h1 id="寻找一个数的二分查找-搜索区间两端都闭"><a href="#寻找一个数的二分查找-搜索区间两端都闭" class="headerlink" title="寻找一个数的二分查找(搜索区间两端都闭)"></a>寻找一个数的二分查找(搜索区间两端都闭)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间是左闭右闭[left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件时，left == right + 1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 计算mid时需要防止溢出</span></span><br><span class="line">        <span class="keyword">int</span>  mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 停止的终止条件，找到了target</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终止时仍未找到target</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么while循环的条件中是&lt;=，而不是&lt;？<ul>
<li>因为初始化right的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length</li>
<li>这两者会出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小为nums.length是越界的</li>
<li>这个算法使用的是前者[left, right]两端都闭的区间。这个区间其实就是每次进行搜索的区间</li>
<li>while(left &lt;= right)的终止条件是left == right + 1，写成区间的形式就是[right+1, right]，或者代个具体的数字进去[3,2]，可见这时区间为空，因为没有数组大于等于3且小于等于2。这时while循环终止是正确的，返回-1即可</li>
<li>while(left &lt; right)的终止条件是left == right，写成区间的形式是[left, right]，或者代个具体的数字进去[2,2]，这时区间非空，还有一个数2，但此时while循环终止了。即2被漏掉了，索引2没有被搜索，如果这时直接返回-1就是错的</li>
</ul>
</li>
</ul>
<h1 id="寻找一个数的二分查找-搜索区间左闭右开"><a href="#寻找一个数的二分查找-搜索区间左闭右开" class="headerlink" title="寻找一个数的二分查找(搜索区间左闭右开)"></a>寻找一个数的二分查找(搜索区间左闭右开)</h1><ul>
<li>当然，如果非要用while(left &lt; right)也可以，需要打一个补丁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="寻找左侧边界的二分查找-搜索区间左闭右开"><a href="#寻找左侧边界的二分查找-搜索区间左闭右开" class="headerlink" title="寻找左侧边界的二分查找(搜索区间左闭右开)"></a>寻找左侧边界的二分查找(搜索区间左闭右开)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找到的左侧边界的索引下标i即，nums 中小于 target 的数有 i 个</span></span><br><span class="line"><span class="comment">// 换句话说，如果 target 要插入到 nums 应插入到位置 i</span></span><br><span class="line"><span class="comment">// 如对有序数组nums=[2,3,3,5,7]</span></span><br><span class="line"><span class="comment">// target=1，算法会返回0，含义是：nums中小于1的元素有0个</span></span><br><span class="line"><span class="comment">// target=3，算法会返回1，含义是：nums中小于3的元素有1个</span></span><br><span class="line"><span class="comment">// target=8，算法会返回5，含义是：nums中小于8的元素有5个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为左闭右开[left, right)</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件时，left == right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到target时不要立即返回，而是收缩右侧边界</span></span><br><span class="line">            <span class="comment">// 在区间[left, mid)中继续搜索</span></span><br><span class="line">            <span class="comment">// 若此时 mid 已经达到了左侧边界，那后续只会变动 left,</span></span><br><span class="line">            <span class="comment">// 直到 left == right终止</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right)，此时 mid 和左侧数已被排除</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid)，此时 mid 和右侧数已被排除</span></span><br><span class="line">            <span class="comment">// 但 right == mid，可保证若 target 不存在 nums 中时，</span></span><br><span class="line">            <span class="comment">// 最终返回下标在 target 该插入的地方</span></span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到终止条件时，此时若需返回target需插入的索引下标直接返回</span></span><br><span class="line">    <span class="comment">// left 可返回的取值范围是[0, nums.length]闭区间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若需使 target 不存在 nums 中返回 -1, 则需分两种情况判断</span></span><br><span class="line">    <span class="comment">// 1. target 比所有数都大，数组已越界，需用长度来判断，</span></span><br><span class="line">    <span class="comment">//    其实left最大也就==长度，不会&gt;，此处是防御性编程</span></span><br><span class="line">    <span class="comment">// 2. target 不存在 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么while 中是&lt;而不是&lt;=<ul>
<li>因为right = nums.length而不是nums.length-1。因此每次循环的「搜索区间」是[left, right)左闭右开</li>
<li>while (left &lt; right)终止的条件是left == right，此时搜索区间[left, left)为空，所以可以正确终止</li>
<li>对于搜索左右侧边界的二分查找，这种写法比较普遍</li>
</ul>
</li>
</ul>
<h1 id="寻找左侧边界的二分查找-搜索区间两端都闭"><a href="#寻找左侧边界的二分查找-搜索区间两端都闭" class="headerlink" title="寻找左侧边界的二分查找(搜索区间两端都闭)"></a>寻找左侧边界的二分查找(搜索区间两端都闭)</h1><ul>
<li>可以，只要明白「搜索区间」的概念，就能有效避免漏掉元素</li>
<li>因为要求搜索区间两端都闭，所以right应该初始化为<code>nums.length - 1</code>，while的终止条件应该是<code>left == right + 1</code>，即用&lt;=<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 终止条件时，left == right + 1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界，若此时已达到左侧边界，那此时 right 指向</span></span><br><span class="line">            <span class="comment">// 左侧边界-1的索引，以后只会收缩左侧边界，直到left == right+1</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到终止条件时，此时若需返回target需插入的索引下标直接返回</span></span><br><span class="line">    <span class="comment">// left 可返回的取值范围是[0, nums.length]闭区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查越界情况和是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回 left 和 right+1均可</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之所以要检查越界情况，是因为由于while的退出条件是<code>left == right + 1</code>，所以当target比nums中所有元素都大时，会存在以下情况使得索引越界</li>
<li><img src="https://img.shiqi-lu.tech/20201107173917.png?imageView2/2/h/150"></li>
</ul>
<h1 id="寻找右侧边界的二分查找-搜索区间左闭右开"><a href="#寻找右侧边界的二分查找-搜索区间左闭右开" class="headerlink" title="寻找右侧边界的二分查找(搜索区间左闭右开)"></a>寻找右侧边界的二分查找(搜索区间左闭右开)</h1><ul>
<li>只有两处和搜索左侧边界不同<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 终止条件时，left == right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到target时不要立即返回，而是收缩左侧边界</span></span><br><span class="line">            <span class="comment">// 在区间[mid+1, right)中继续搜索</span></span><br><span class="line">            <span class="comment">// 若此时 mid 已经达到了右侧边界，那后续只会变动 right,</span></span><br><span class="line">            <span class="comment">// 直到 left == right终止，此时 left 指向右侧边界+1的下标</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 即 while 循环结束时，nums[left] 一定不等于 target 了</span></span><br><span class="line">            <span class="comment">// 而 nums[left-1] 可能是 target</span></span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 不同点1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到终止条件时，left==right 指向的是右侧边界+1的下标</span></span><br><span class="line">    <span class="comment">// left 可返回的取值范围是[0, nums.length]闭区间</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 若需使 target 不存在 nums 中返回 -1, 则需分两种情况判断</span></span><br><span class="line">    <span class="comment">// 1. target 比所有数都小，此时 left == 0，&lt; 号为防御性编程</span></span><br><span class="line">    <span class="comment">// 2. target 指向的右侧边界不存在 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt;= <span class="number">0</span> || nums[left-<span class="number">1</span>] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回右侧边界</span></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 不同点2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="寻找右侧边界的二分查找-搜索区间两端都闭"><a href="#寻找右侧边界的二分查找-搜索区间两端都闭" class="headerlink" title="寻找右侧边界的二分查找(搜索区间两端都闭)"></a>寻找右侧边界的二分查找(搜索区间两端都闭)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 终止条件时，left == right + 1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时，left - 1 == right</span></span><br><span class="line">    <span class="comment">// left 的含义仍是指向的是右侧边界+1的下标，可返回 left-1 或 right</span></span><br><span class="line">    <span class="comment">// left 可返回的取值范围是[0, nums.length]闭区间</span></span><br><span class="line">    <span class="comment">// right 是指向右侧边界，取值范围是[-1, nums.length-1]闭区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若需使 target 不存在 nums 中返回 -1, 则需分两种情况判断</span></span><br><span class="line">    <span class="comment">// 1. target 比所有数都小，此时 left == 0，&lt; 号为防御性编程</span></span><br><span class="line">    <span class="comment">// 2. target 指向的右侧边界不存在 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt;= <span class="number">0</span> || nums[left-<span class="number">1</span>] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 或直接返回 right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当target比所有元素都小时，right会被减到-1，所以需要在最后防止越界</li>
<li><img src="https://img.shiqi-lu.tech/20201107192235.png?imageView2/2/h/150"></li>
</ul>
<h1 id="记忆六种二分查找的函数方法"><a href="#记忆六种二分查找的函数方法" class="headerlink" title="记忆六种二分查找的函数方法"></a>记忆六种二分查找的函数方法</h1><ul>
<li>1.确定使用的是两端都闭还是左闭右开的写法<ul>
<li>采用两端都闭的写法时(除在查找左侧和右侧边界外4种，查找一个数的左闭右开当作两端都闭)<ul>
<li>初始化为<code>left = 0; right = nums.length - 1</code></li>
<li>循环判断规则为<code>left &lt;= right</code></li>
<li>结束时<code>left == right+1</code></li>
<li>判断规则如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>采用左闭右开的写法时(仅在查找左侧和右侧边界)<ul>
<li>初始化为<code>left = 0; right = nums.length</code></li>
<li>循环判断规则为<code>left &lt; right</code></li>
<li>结束时<code>left == right</code></li>
<li>判断规则如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>2.确定哪种二分查找以及查找过程中mid的意义<ul>
<li>查找一个数(两端都闭)+查找一个数(左闭右开)：判断当前mid是否为要找的数：是的话直接返回<code>return mid;</code></li>
<li>寻找左侧边界(左闭右开)：此时均应该收缩右边界，因右为开区间，即把 right 当作新边界，<code>right = mid;</code></li>
<li>寻找左侧边界(两端都闭)：此时均应该收缩右边界，因右为闭区间，需把 right-1 当作新边界，<code>right = mid - 1;</code></li>
<li>寻找右侧边界(左闭右开+两端都闭)：此时均应该收缩左边界，左边均为闭区间，即<code>left = mid + 1;</code></li>
</ul>
</li>
<li>3.确定哪种二分查找结束时left、right变量对应的意义和取值范围，以及不存在时需补判断的内容<ul>
<li>查找一个数(两端都闭)：此时区间已被搜索完，直接返回-1即可</li>
<li>查找一个数(左闭右开)：此时相比两端都闭，少判断了left元素，所以需补上：<code>return nums[left] == target ? left : -1;</code></li>
<li>寻找左侧边界(左闭右开)：此时 left == right 为返回 target 需插入的索引下标，所以需返回<code>left</code>，left 取值范围是[0, nums.length]闭区间，所以需补判断<code>left &gt;= nums.length || nums[left] != target</code>成立返回-1</li>
<li>寻找左侧边界(两端都闭)：除了结束时 left == right + 1 外，left 的意义、取值范围、补判断内容均同左闭右开</li>
<li>寻找右侧边界(左闭右开)：此时 left == right 指向的是右侧边界+1的下标，所以需返回<code>left-1</code>，left取值范围是[0, nums.length]闭区间，需补判断<code>left &lt;= 0 || nums[left-1] != target</code>成立返回-1</li>
<li>寻找右侧边界(两端都闭)：此时 left == right + 1，left 的意义、取值范围、补判断内容均同左闭右开，但此处可返回<code>left-1</code>或<code>right</code>，或以 right 判断<code>right &lt; 0 || nums[right] != target</code>也可</li>
</ul>
</li>
</ul>
<h1 id="现有语言的二分查找库函数调用"><a href="#现有语言的二分查找库函数调用" class="headerlink" title="现有语言的二分查找库函数调用"></a>现有语言的二分查找库函数调用</h1><ul>
<li>C++<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::binary_search(nums.begin(), nums.end(), 待查找数)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not Found!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 找第一个大于待找元素的元素，事实等于找右侧边界+1</span></span><br><span class="line">    <span class="keyword">auto</span> upper = <span class="built_in">std</span>::upper_bound(nums.begin(), nums.end(), 待查找数);</span><br><span class="line">    <span class="keyword">if</span> (upper != data.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; upper &lt;&lt; <span class="string">&quot; at index &quot;</span> </span><br><span class="line">          &lt;&lt; <span class="built_in">std</span>::distance(data.begin(), upper) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 待查找数超过范围</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not Found!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找第一个小于等于待找元素的元素，事实等于找左侧边界</span></span><br><span class="line">    <span class="keyword">auto</span> lower = <span class="built_in">std</span>::upper_bound(nums.begin(), nums.end(), 待查找数);</span><br><span class="line">    <span class="keyword">if</span> (lower != data.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; lower &lt;&lt; <span class="string">&quot; at index &quot;</span> </span><br><span class="line">          &lt;&lt; <span class="built_in">std</span>::distance(data.begin(), lower) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 待查找数超过范围</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not Found!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Python3<ul>
<li>参考：<a href="https://docs.python.org/zh-cn/3.6/library/bisect.html">https://docs.python.org/zh-cn/3.6/library/bisect.html</a></li>
<li>查找左侧边界并返回index：<code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></li>
<li>查找右侧边界+1并返回index：<code>bisect.bisect(a, x, lo=0, hi=len(a))</code></li>
<li>其中 a 是 list，x 为待查找的数，lo 和 hi 为 a 的上下界，拼合起来意思为：在数组a[lo, hi]中查找x，注意此处同python3列表是左闭右开</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect">我作了首诗，保你闭着眼睛也能写对二分查找</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>类别不平衡问题的方法汇总</title>
    <url>/class-imbalance/</url>
    <content><![CDATA[<h1 id="类别不平衡问题-class-imbalance-是什么"><a href="#类别不平衡问题-class-imbalance-是什么" class="headerlink" title="类别不平衡问题(class-imbalance)是什么"></a>类别不平衡问题(class-imbalance)是什么</h1><ul>
<li>指分类任务中不同类别的训练样例数目差别很大的情况</li>
<li>若不同类别的训练样例数目稍有差别，通常影响不大，但若差别很大，则会对学习过程造成困扰。例如有998个反例，但是正例只有2个，那么学习方法只需要返回一个永远将新样本预测为反例的学习器，就能达到99.8%的精度；然而这样的学习器往往没有价值，因为它不能预测出任何正例</li>
</ul>
<h1 id="上采样-过采样-Oversampling"><a href="#上采样-过采样-Oversampling" class="headerlink" title="上采样(过采样, Oversampling)"></a>上采样(过采样, Oversampling)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>对训练集中的少数类进行“过采样”，即增加一些少数类样本使得正、反例数目接近，然后再进行学习</li>
</ul>
<h2 id="Random-Oversampling-随机上采样"><a href="#Random-Oversampling-随机上采样" class="headerlink" title="Random Oversampling(随机上采样)"></a>Random Oversampling(随机上采样)</h2><ul>
<li>简单复制样本的策略来增加少数类样本，容易产生模型过拟合的问题</li>
</ul>
<h2 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h2><ul>
<li>即合成少数类过采样技术(Synthetic Minority Oversampling Technique)，是基于随机采样算法的一种改进，其基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中</li>
</ul>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li>1.对于少数类中每一个样本$x_i$，以欧氏距离为标准计算它到少数类样本集$S_{min}$中所有样本的距离，得到其k近邻</li>
<li>2.根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本$x_i$，从其k近邻中随机选择若干个样本，假设选择的近邻为$\tilde{x}$。</li>
<li>3.对于每一个随机选出的近邻$\tilde{x}$，分别于原样本按照如下的公式构建新的样本</li>
<li>$$x_{n e w}=x+\operatorname{rand}(0,1) \times |\tilde{x}-x|$$</li>
<li><img src="https://img.shiqi-lu.tech/20201019195529.png?imageView2/2/h/250"></li>
</ul>
<h3 id="SMOTE的问题"><a href="#SMOTE的问题" class="headerlink" title="SMOTE的问题"></a>SMOTE的问题</h3><ul>
<li>随机选取少数类样本用以合成新样本，而不考虑周边样本的情况<ul>
<li>1.如果选取的少数类样本周围都是少数类样本，则新合成的样本不会提供太多有用信息。就像SVM中远离margin的点对决策边界影响不大</li>
<li>2.如果选取的少数类样本周围都是多数类样本，这类的样本可能是噪声，则新合成的样本会与周围的多数类样本产生大部分重叠，导致分类困难</li>
</ul>
</li>
</ul>
<h2 id="Borderline-SMOTE"><a href="#Borderline-SMOTE" class="headerlink" title="Borderline-SMOTE"></a>Borderline-SMOTE</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>由于原始SMOTE算法的对所有少数类样本都是一视同仁的，我们希望新合成的少数类样本能处于两个类别的边界附近，因为在实际建模过程中那些处于边界位置的样本更容易被错分，因此利用边界位置的样本信息产生新样本可以给模型带来更大的体征，能提供足够的信息用以分类，即Borderline SMOTE算法做的事情</li>
</ul>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li>这个算法会先将所有的少数类样本分成三类，如图</li>
<li><img src="https://img.shiqi-lu.tech/20201019140912.png"></li>
<li>“noise”：所有的k近邻个样本都属于多数类，可认为是噪声不能生成合成样本</li>
<li>“danger”：超过一半的k近邻样本属于多数类</li>
<li>“safe”：超过一半的k近邻样本属于少数类</li>
<li>borderline smote算法只会从处于”danger”状态的样本中随机选择，然后用SMOTE算法产生新的样本。处于”danger”状态的样本代表靠近”边界”附近的少数类样本往往更容易被误分类。因而Border-line SMOTE只对那些靠近”边界”的少数类样本进行人工合成样本，而SMOTE则对所有少数类样本一视同仁</li>
</ul>
<h3 id="危险集的判断流程"><a href="#危险集的判断流程" class="headerlink" title="危险集的判断流程"></a>危险集的判断流程</h3><ul>
<li>1.对于每个$x_{i} \subset S_{\min }$确定一系列K近邻样本集，称该数据集为$S_{i-kNN}$，且$S_{i-kNN} \subset S$</li>
<li>2.对每个样本$x_i$，判断出最近邻样本集中属于多数类样本的个数，即$\left|S_{i-k N N} \cap S_{m a j}\right|$</li>
<li>3.选择满足不等式$\frac{k}{2} \leq\left|S_{i-k N N} \cap S_{m a j}\right| \leq k$，将其加入危险集DANGER</li>
</ul>
<h3 id="Borderline-SMOTE分类两种："><a href="#Borderline-SMOTE分类两种：" class="headerlink" title="Borderline SMOTE分类两种："></a>Borderline SMOTE分类两种：</h3><ul>
<li>Borderline-1 SMOTE：在合成样本时所选的近邻是一个少数类样本</li>
<li>Borderline-2 SMOTE：在合成样本时所选的近邻是任意一个样本</li>
</ul>
<h2 id="ADASYN-Adaptive-Synthetic-Sampling，自适应合成采用"><a href="#ADASYN-Adaptive-Synthetic-Sampling，自适应合成采用" class="headerlink" title="ADASYN(Adaptive Synthetic Sampling，自适应合成采用)"></a>ADASYN(Adaptive Synthetic Sampling，自适应合成采用)</h2><ul>
<li>根据数据分布情况为不同的少数类样本生成不同数量的新样本</li>
<li>首先根据最终的平衡程度设定总共需要生成的新少数类样本数量，然后为每个少数类样本x计算分布比例</li>
</ul>
<h1 id="下采样-降采样-UnserSampling"><a href="#下采样-降采样-UnserSampling" class="headerlink" title="下采样(降采样, UnserSampling)"></a>下采样(降采样, UnserSampling)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul>
<li>对训练集中多数类样本进行“下采样”(undersampling)，即去除一些多数类中的样本使得正例、反例数目接近，然后再学习</li>
</ul>
<h2 id="Random-Undersampling-随机下采样-或-原型选择-Prototype-Selection"><a href="#Random-Undersampling-随机下采样-或-原型选择-Prototype-Selection" class="headerlink" title="Random Undersampling(随机下采样) 或 原型选择(Prototype Selection)"></a>Random Undersampling(随机下采样) 或 原型选择(Prototype Selection)</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>从多数类$S_{maj}$中随机选择一些样本组成样本集E。然后将样本集E从$S_{maj}$中移除。新的数据集$S_{n e w-m a j}=S_{m a j}-E$</li>
<li>通过改变多数类样本比例以达到修改样本分布的目的，从而使样本分布较为均衡</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>操作简单，只依赖于样本分布，不依赖任何距离信息，属于非启发式方法</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于采样的样本集合要少于原来的样本集合，因此会造成一些信息缺失，即将多数类样本删除有可能导致分类器丢失有关多数类的重要信息</li>
</ul>
<h2 id="Ensemble-Methods"><a href="#Ensemble-Methods" class="headerlink" title="Ensemble Methods"></a>Ensemble Methods</h2><h3 id="EasyEnsemble"><a href="#EasyEnsemble" class="headerlink" title="EasyEnsemble"></a>EasyEnsemble</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>多次随机欠采样，尽可能全面地涵盖所有信息，特点是利用boosting减少偏差(Adaboost)、bagging减少方差(集成分类器)。实际应用的时候可尝试选用不同的分类器来提高分类的效果</li>
<li><img src="https://img.shiqi-lu.tech/20201020145429.png?imageView2/2/h/350"></li>
</ul>
<h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>1.把数据划分为两部分，分别是多数类样本$S_{maj}$和少数类样本$S_{min}$</li>
<li>2.从多数类$S_{maj}$中有放回的随机采样n次，每次选取与少数类数目相近的样本个数即$|S_{imaj}|=|S_{min}|$，可得到n个样本集合，记作$\{S_{1 m a j}, S_{2 m a j}, \ldots, S_{n m a j}\}$</li>
<li>3.将每一个多数类样本的子集$S_{imaj}$与少数类样本$S_{min}$合并后训练出Adaboost分类器$H_i$，阈值设置为$\theta_i$，可得到n个模型，即$H_{i}(x)=\operatorname{sgn}\left(\sum\limits_{j=1}^{s_{i}} \alpha_{i j} h_{i, j}(x)-\theta_{i}\right)$</li>
<li>4.将这些模型组合形成一个集成学习系统，最终的模型结果是这n个模型的投票值。此处采用加权多数表决的方法，加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用，减小分类误差率小的弱分类器的权值，使其在表决中起较小的作用，即最终分类器为$H(x)=\operatorname{sgn}\left(\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{s_{i}} \alpha_{i j} h_{i j}(x)-\sum\limits_{i=1}^{n} \theta_{i}\right)$</li>
</ul>
<h3 id="BalanceCascade"><a href="#BalanceCascade" class="headerlink" title="BalanceCascade"></a>BalanceCascade</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li>该算法得到的是一个级联分类器，基于Adaboost，将若干个强分类器由简单到复杂排列，只有和少数类样本特征比较接近的才有可能输入到后面的分类器，比如边界点，因此能更充分地利用多数类样本的信息，一定程度上解决随机欠采样的信息丢失问题</li>
</ul>
<h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>输入：一个包含少数类阳性样本P和多数类阴性样本集N的训练集D，定义T是从N中抽取的子集个数，$s_i$是训练Adaboost基分类器$H_i$时的循环次数</li>
<li>输出：一个组合分类器H(x)</li>
<li>1.$f=\sqrt[(\mathrm{T}-1)]{\left(\frac{|\mathrm{P}|}{|\mathrm{N}|}\right)}$，$f$是每一层级的分类器$H_i$该达到的假阳性率(False Positive Rate)，即把多数类样本误分为少数类的错误率</li>
<li>for i = 1 to T:<ul>
<li>从多数类N中随机抽取一个样本子集$N_i$，使得$|N_i| = |P|$</li>
<li>使用少数类样本集P和样本子集$N_i$训练一个Adaboost分类器$H_i$($H_i$由$s_i$个基分类器$h_{i,j}$及其权重$\alpha_{i,j}$构成，$\theta_i$是$H_i$的调节参数)</li>
<li>$\mathrm{H}_{\mathrm{i}}(x)=\operatorname{sgn}(\sum\limits_{j=1}^{s_{i}} \alpha_{i, j} h_{i, j}(x)-\theta_{i})$</li>
<li>调节阈值$\theta_i$令$H_i$的FP率为$f$</li>
<li>移除多数类样本集N中所有被$H_i$正确分类的样本</li>
</ul>
</li>
<li>输出一个集成分类器</li>
<li>$\mathrm{H}(\mathrm{x})=\operatorname{sgn}\left(\sum\limits_{i=1}^{T} \sum\limits_{j=1}^{s_{l}} \alpha_{i, j} h_{i, j}(x)-\sum\limits_{i=1}^{T} \theta_{i}\right)$</li>
</ul>
<h2 id="NearMiss"><a href="#NearMiss" class="headerlink" title="NearMiss"></a>NearMiss</h2><ul>
<li>本质上是一种原型选择(prototype selection)方法，即从多数类样本中选取最具代表性的样本用于训练，主要是为了缓解随机欠采样中的信息丢失问题。Nearmiss采用了3中不同的启发式规则来选择样本<ul>
<li>NearMiss-1：选择到最近的K个少数类样本平均距离最近的多数类样本，考虑的是与最近的k个少数类样本的平均距离，是局部的。该方法得到的多数类样本分布是“不均衡”的，它倾向于在比较集中的少数类附近找到更多的多数类样本，而在孤立的(离群的)少数类附近找到更少的多数类样本，原因是该方法考虑的局部性质和平均距离</li>
<li>NearMiss-2：选择到最远的K个少数类样本平均距离最近的多数类样本，考虑的是与最远的k个少数类样本的平均距离，是全局的。实验结果表明该方法的不均衡分类性能最优</li>
<li>NearMiss-3：对于每个少数类样本选择K个最近的多数类样本，目的是保证每个少数类样本都被多数类样本包围，该方法会使每一个少数类样本附近都有足够多的多数类样本，显然这会使得模型的精确度高、召回率低</li>
</ul>
</li>
</ul>
<h2 id="原型生成-Prototype-generation"><a href="#原型生成-Prototype-generation" class="headerlink" title="原型生成(Prototype generation)"></a>原型生成(Prototype generation)</h2><ul>
<li>给定数据集S，原型生成算法将生成一个子集S’，其中|S’|&lt;|S|，但是子集并非来自于原始数据，而是由原始数据集生成，方法是聚类成|S’|个类，然后取其中心点</li>
</ul>
<h2 id="Data-Cleaning-Techniques"><a href="#Data-Cleaning-Techniques" class="headerlink" title="Data Cleaning Techniques"></a>Data Cleaning Techniques</h2><h3 id="Tomek-Links"><a href="#Tomek-Links" class="headerlink" title="Tomek Links"></a>Tomek Links</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul>
<li>给定一个样本对$(x_i, x_j)$，其中$x_{i} \in S_{m a j}, x_{j} \in S_{\min }$，记$d(x_i, x_j)$是样本$x_i$和样本$x_j$之间的距离，如果不存在任何样本$x_k$，使得$d\left(x_{i}, x_{k}\right)&lt;d\left(x_{i}, x_{j}\right)$，那么样本对$(x_i, x_j)$即称为Tomek Links。即Tomek links为相反类最近邻样本之间的一对连接</li>
<li>不属于Tomek Links的情况有这个少数类样本最近的样本是同一类</li>
</ul>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul>
<li>如果两个样本来自Tomek Links，那么他们中的一个样本要么是噪声，要么它们都在两类的边界上</li>
</ul>
<h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><ul>
<li><img src="https://img.shiqi-lu.tech/20201021171029.png?imageView2/2/h/300"></li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>欠采样：将Tomek Links中属于是多数类的样本剔除</li>
<li>数据清洗：将Tomek Links中的两个样本都剔除</li>
</ul>
<h3 id="ENN-edited-nearest-neighborhood"><a href="#ENN-edited-nearest-neighborhood" class="headerlink" title="ENN(edited nearest neighborhood)"></a>ENN(edited nearest neighborhood)</h3><ul>
<li>这种方法应用knn来编辑(edit)数据集，对于每一个要进行下采样的样本，那些绝大多数近邻样本不属于该类的样本会被移除，而绝大多数的近邻样本属于同一类的样本会被保留</li>
</ul>
<h1 id="综合采样-Oversampling-Undersampling"><a href="#综合采样-Oversampling-Undersampling" class="headerlink" title="综合采样(Oversampling + Undersampling)"></a>综合采样(Oversampling + Undersampling)</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><ul>
<li>先过采样，然后再进行数据的清洗</li>
</ul>
<h2 id="SMOTE-Tomek-Links"><a href="#SMOTE-Tomek-Links" class="headerlink" title="SMOTE+Tomek Links"></a>SMOTE+Tomek Links</h2><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li>1.利用SMOTE方法生成新的少数类样本，得到扩充后的数据集T</li>
<li>2.剔除T中的Tomek Links对</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>普通的SMOTE方法生成的少数类样本是通过线性插值得到的，在平衡类别分布的同时也扩张了少数类的样本空间，产生的问题是可能原本属于多数类样本的空间被少数类“入侵”，容易造成模型的过拟合</li>
<li>Tomek Links对寻找的是那种噪声点或者边界点，可以很好地解决“入侵”问题，如图红色加号为SMOTE产生的少数类样本，可以看到红色样本“入侵”到原本属于多数类样本的空间，这种噪声数据问题可以通过Tomek Links很好地解决</li>
<li><img src="https://img.shiqi-lu.tech/20201021171629.png?imageView2/2/h/150"></li>
</ul>
<h2 id="SMOTE-ENN"><a href="#SMOTE-ENN" class="headerlink" title="SMOTE+ENN"></a>SMOTE+ENN</h2><ul>
<li>1.利用SMOTE方法生成新的少数类样本，得到扩充后的数据集T</li>
<li>2.对T中的每一个样本使用KNN(一般k取3)方法预测，若预测结果与实际类别标签不符，则剔除该样本</li>
</ul>
<h1 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h1><h2 id="基于异常检测的方法"><a href="#基于异常检测的方法" class="headerlink" title="基于异常检测的方法"></a>基于异常检测的方法</h2><ul>
<li>把小类的样本作为异常点(outliers)，因此该问题便转化为异常点检测(anomaly detection)与变化趋势检测问题(change detection)</li>
</ul>
<h2 id="分治ensemble"><a href="#分治ensemble" class="headerlink" title="分治ensemble"></a>分治ensemble</h2><ul>
<li>将大类中样本聚类到L个聚类中，然后训练L个分类器</li>
<li>每个分类器使用大类中的一个簇与所有的小类样本进行训练得到</li>
<li>最后对这L个分类器采取少数服从多数的方式对未知类别数据进行分类，如果是连续值，采用平均值</li>
</ul>
<h2 id="分层级ensemble"><a href="#分层级ensemble" class="headerlink" title="分层级ensemble"></a>分层级ensemble</h2><ul>
<li>使用原始数据集训练第一个学习器L1</li>
<li>将L1错分的数据集作为新的数据集训练L2</li>
<li>将L1和L2分类结果不一致的数据作为数据集训练L3</li>
<li>最后测试集上将三个分类器的结果汇总(结合这三个分类器，采用投票的方式来决定分类结果，因此只有当L2与L3都分类为false时，最终结果才为false，否则为true)</li>
</ul>
<h2 id="对小类错分进行加权惩罚"><a href="#对小类错分进行加权惩罚" class="headerlink" title="对小类错分进行加权惩罚"></a>对小类错分进行加权惩罚</h2><ul>
<li>对分类器的小类样本数据增加权值，降低大类样本的权重，从而使得分类器将重点集中在小类样本身上</li>
<li>一个具体做法是，在训练分类器时，若分类器将小类样本分错时，额外增加分类器一个小类样本分错代价，这个额外的代价可以使得分类器更加“关心”小类样本。如penalized-SVM和penalized-LDA算法</li>
<li>对小样本进行过采样(例如含L倍重复数据)，其实在计算小样本错分cost functions时会累加L倍的惩罚分数</li>
</ul>
<h2 id="尝试其它评价指标"><a href="#尝试其它评价指标" class="headerlink" title="尝试其它评价指标"></a>尝试其它评价指标</h2><ul>
<li>准确度这个评价指标在类别不均衡的分类任务中不够好，甚至会造成误导。可考虑更有说服力的评价指标。如混淆矩阵、精确度、召回率、F1得分，其中可关注Kappa和ROC曲线</li>
</ul>
<h2 id="尝试不同的分类算法"><a href="#尝试不同的分类算法" class="headerlink" title="尝试不同的分类算法"></a>尝试不同的分类算法</h2><ul>
<li>决策树在类别不均衡数据上表现不错。它使用基于类变量的划分规则去创建分类树，因此可以强制地将不同类别的样本分开</li>
<li>Lightgbm中有两个参数处理类别不平衡，分别是is_unbalance和scale_pos_weight</li>
<li>xgboost有一个参数类别不平衡，即scale_pos_weight</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://www.jiqizhixin.com/articles/021704">机器学习中如何处理不平衡数据？</a></li>
<li><a href="https://blog.csdn.net/jiede1/article/details/70215477">SMOTE算法(人工合成数据)</a></li>
<li><a href="https://www.jianshu.com/p/13fc0f7f5565">SMOTE算法</a></li>
<li><a href="https://blog.csdn.net/anshuai_aw1/article/details/89177406">分类问题中类别不平衡问题的有效解决方法</a></li>
<li><a href="http://freewill.top/2017/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8817%EF%BC%89%EF%BC%9A%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">机器学习算法系列（17）：非平衡数据处理</a></li>
<li><a href="https://blog.csdn.net/weixin_44871660/article/details/90600522">样本不平衡处理</a></li>
<li><a href="https://imbalanced-learn.readthedocs.io/en/stable/index.html">imbalanced官网</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36093594">非平衡分类问题 | BalanceCascade方法及其Python实现</a></li>
<li><a href="https://blog.csdn.net/songhk0209/article/details/71484469">解决样本不平衡问题的奇技淫巧 汇总</a></li>
<li><a href="https://machinelearningmastery.com/tactics-to-combat-imbalanced-classes-in-your-machine-learning-dataset/">8 Tactics to Combat Imbalanced Classes in Your Machine Learning Dataset</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
        <tag>数据预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据库设计那些事》学习笔记</title>
    <url>/db-design-thing/</url>
    <content><![CDATA[<ul>
<li>Q:什么是数据库设计？<ul>
<li>根据业务系统的具体需要，结合我们所选用的DBMS（数据库管理系统），为这个业务系统构造出最优的数据存储模型。并建立好数据库中的表结构及表与表之间关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行访问</li>
</ul>
</li>
<li>Q:优良和糟糕的数据库设计设怎样的？<ul>
<li>优良：</li>
<li>1.减少数据冗余</li>
<li>2.避免数据维护异常</li>
<li>3.节约存储空间</li>
<li>4.高效的访问</li>
<li>糟糕：</li>
<li>1.存在大量数据冗余</li>
<li>2.存在数据插入，更新，删除异常</li>
<li>3.浪费大量存储空间</li>
<li>4.访问数据低效</li>
</ul>
</li>
<li>Q:数据库设计的四个步骤是什么？<ul>
<li>1.需求分析</li>
<li>2.逻辑分析</li>
<li>3.物理设计</li>
<li>4.维护优化</li>
</ul>
</li>
<li>Q:数据库需求分析有什么？<ul>
<li>1.数据是什么</li>
<li>2.数据有哪些属性，存储特点</li>
<li>3.数据和属性各自的特点有哪些</li>
<li>4.数据的生命周期</li>
</ul>
</li>
<li>Q:数据库逻辑设计做什么？<ul>
<li>1.将需求转化为数据库的逻辑模型</li>
<li>2.通过ER图的形式对逻辑模型进行展示</li>
<li>3.同所选用的具体的DBMS系统无关</li>
</ul>
</li>
<li>Q:数据库物理设计要考虑什么？<ul>
<li>1.选择合适的数据库管理系统</li>
<li>2.定义数据库、表及字段的命名规范</li>
<li>3.根据所选的DBMS系统选择合适的字段类型</li>
<li>4.反范式化设计</li>
</ul>
</li>
<li>Q:数据库维护优化要做什么？<ul>
<li>1.维护数据字典</li>
<li>2.维护索引</li>
<li>3.维护表结构</li>
<li>4.在适当的时候对表进行水平拆分或垂直拆分</li>
</ul>
</li>
<li>Q:数据库需求分析中需要搞清楚数据的什么特点？<ul>
<li>1.实体及实体之间的关系（1对1，1对多，多对多）</li>
<li>2.实体所包含的属性有什么？</li>
<li>3.哪些属性或属性的组合可以唯一标识一个实体</li>
</ul>
</li>
<li>名词解释：<ul>
<li>关系：一个关系对应通常所说的一张表</li>
<li>元组：表中的一行即为一个元组</li>
<li>属性：表中的一列即为一个属性；每一个属性都有一个名称，称为属性名</li>
<li>候选码：表中的某个属性组，可以唯一确定一个元组</li>
<li>主码：一个关系有多个候选码，选定其中一个为主码</li>
<li>域：属性的取值范围</li>
<li>分量：元组中的一个属性值</li>
</ul>
</li>
<li>ER图例说明：<ul>
<li>矩形：表示实体集，矩形内写实体集的名字</li>
<li>菱形：表示联系集</li>
<li>椭圆：表示实体的属性</li>
<li>线段：将属性连接到实体集，或将实体集连接到联系集</li>
</ul>
</li>
<li>Q:数据库操作的插入异常是什么？<ul>
<li>如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体</li>
</ul>
</li>
<li>Q:数据库操作的更新异常是什么？<ul>
<li>如果更改表所对应的某个实体实例的单独属性时，需要将多行更新</li>
</ul>
</li>
<li>Q:数据库操作的删除异常是什么？<ul>
<li>如果删除表的某一行来反映某实体实例，失效时导致另一个不同实体实例信息丢失</li>
</ul>
</li>
<li>Q:数据库的数据冗余是什么？<ul>
<li>相同的数据再多个地方存在，或者说表中的某个列可以由其它列计算得到</li>
</ul>
</li>
<li>Q:数据库的第一范式（1NF）是什么？<ul>
<li>数据库表中的所有字段都是单一属性，不可再分的。这个单一属性是又基本的数据类型所构成的，如整数，浮点数，字符串等</li>
<li>即第一范式要求数据库中的表都是二维表</li>
<li><img src="https://img.shiqi-lu.tech/20200905201841.png"></li>
</ul>
</li>
<li>Q:数据库的第二范式（2NF）是什么？<ul>
<li>数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖</li>
<li>部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况</li>
<li>即所有单关键字段的表都符合第二范式</li>
<li>不符合的例子：</li>
<li><img src="https://img.shiqi-lu.tech/20200905201849.png"></li>
<li>由于供应商和商品之间是多对多的关系，所以只有使用商品名称和供应商名称才可以唯一标识出一件商品。也就是商品名称和供应商名称是一组组合关键字。上表中存在以下部分函数依赖关系：</li>
<li>（商品名称）-&gt;（价格，描述，重量，商品有效期）</li>
<li>（供应商名称）-&gt;（供应商电话）</li>
<li>存在问题：插入异常，删除异常，更新异常，数据冗余</li>
<li>解决办法：</li>
<li><img src="https://img.shiqi-lu.tech/20200905201858.png"></li>
</ul>
</li>
<li>Q:数据库的第三范式（3NF）是什么？<ul>
<li>在第二范式的基础上定义，如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式</li>
<li>不符合的例子：</li>
<li><img src="https://img.shiqi-lu.tech/20200905201907.png"></li>
<li>存在以下传递依赖关系：</li>
<li>（商品名称）-&gt;（分类）-&gt;（分类描述）</li>
<li>也就是说存在非关键字段“分类描述”对关键字段“商品名称”的传递函数依赖</li>
<li>存在问题：</li>
<li>（分类，分类描述）对对于每一个商品都会进行记录，所以存在着数据冗余，同时也还存在数据的插入，更新及删除异常</li>
<li>解决办法：</li>
<li><img src="https://img.shiqi-lu.tech/20200905201915.png"></li>
</ul>
</li>
<li>Q:数据库的BC范式（BCNF）是什么？<ul>
<li>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数则符合BC范式</li>
<li>即如果是复合关键字，则复合关键字之间也不能存在函数依赖关系</li>
<li>不符合的例子：</li>
<li><img src="https://img.shiqi-lu.tech/20200905201922.png"></li>
<li>假设供应商联系人只能受雇于一家供应商，每家供应商可以供应多个商品，则存在如下决定关系：</li>
<li>（供应商，商品ID）-&gt;（联系人，商品数量）</li>
<li>（联系人，商品ID）-&gt;（供应商，商品数量）</li>
<li>存在下列关系因此不符合BCNF要求：</li>
<li>（供应商）-&gt;（供应商联系人）</li>
<li>（供应商联系人）-&gt;（供应商）</li>
<li>并存在数据操作异常及输入冗余</li>
<li>解决办法：</li>
<li><img src="https://img.shiqi-lu.tech/20200905200111.png"></li>
</ul>
</li>
<li>Q:MySQL常用的存储引擎有哪些？<ul>
<li><img src="https://img.shiqi-lu.tech/20200905201930.png"></li>
</ul>
</li>
<li>Q:对象命名应该遵循什么原则？<ul>
<li>1.可读性原则：使用大写和小写来格式化的库对象名字以获得良好的可读性</li>
<li>2.表意性原则：对象的名字应该能够描述它所标识的对象。即表的名称能够体现表中存储的数据内容；存储过程名称能够体现存储过程的功能</li>
<li>3.长名原则：尽可能少使用或不使用缩写</li>
</ul>
</li>
<li>字段类型的选择原则<ul>
<li>列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型</li>
<li><img src="https://img.shiqi-lu.tech/20200905201936.png"></li>
<li>主要从以下两个角度考虑：</li>
<li>1.在对数据进行比较（查询条件、join条件及排序）操作时：同样的数据，字符处理往往比数字处理慢</li>
<li>2.在数据库中，数据处理以页为单位，列的长度越小，利于性能提升</li>
</ul>
</li>
<li>Q:char与varchar如何选择？<ul>
<li>1.如果列中要存储的数据长度差不多是一致的，则应该考虑用char；否则应该考虑用varchar</li>
<li>2.如果列中的最大数据长度小于50Byte，则一般也考虑用char(当然，如果这个列很少用，则基于节省空间和减少IO的考虑，还是可以选择用varchar)</li>
<li>3.一般不宜定义大于50Byte的char类型</li>
<li>注意UTF-8的字节是8Byte</li>
</ul>
</li>
<li>Q:decimal和float如何选择？<ul>
<li>1.decimal用于存储精确数据，而float只能用于存储非精确数据。故精确数据只能选择用decimal类型</li>
<li>2.由于float的存储空间开销一般比decimal小（精确到7位小数只需要4个字节，而精确到15位小数只需要8字节）故非精确数据优先选择float类型</li>
</ul>
</li>
<li>Q:时间类型如何存储？<ul>
<li>1.使用int来存储时间字段的优缺点</li>
<li>优点：字段长度比datetime小</li>
<li>缺点：使用不方便，要进行函数转换</li>
<li>限制：只能存储到2038-1-19 11:14:07即2^32为2147483648</li>
<li>2.需要存储的时间粒度</li>
<li>年 月 日 小时 分 秒 周</li>
</ul>
</li>
<li>Q:如何选择主键？<ul>
<li>1.区分业务主键和数据库主键：业务主键用于标识业务数据，进行表与表之间的关联；数据库主键为了优化数据存储（Innodb会生成6个字节的隐含主键）</li>
<li>2.根据数据库的类型，考虑主键是否要顺序增长：有些数据库是按主键的顺序逻辑存储的</li>
<li>3.主键的字段类型所占空间要尽可能的小：对于使用聚集索引方式存储的表，每个索引后都会附加主键信息</li>
</ul>
</li>
<li>Q:避免使用外键约束的原因？<ul>
<li>1.降低数据导入的效率</li>
<li>2.增加维护成本</li>
<li>3.虽然不建议使用外键约束，但是相关联的列上一定要建立索引</li>
</ul>
</li>
<li>Q:避免使用触发器的原因？<ul>
<li>1.降低数据导入的效率</li>
<li>2.可能会出现意想不到的数据异常</li>
<li>3.使业务逻辑变的复杂</li>
</ul>
</li>
<li>Q:关于预留字段<ul>
<li>1.无法准确的知道预留字段的类型</li>
<li>2.无法准确的指导预留字段中所存储的内容</li>
<li>3.后期维护预留字段所要的成本，同增加一个字段所需要的成本是相同的</li>
<li>4.严禁使用预留字段</li>
</ul>
</li>
<li>Q:什么是反范式化？<ul>
<li>针对范式化而言的，在前面介绍了数据库设计的第三范式，所谓的反范式化就是为了性能和读取效率的考虑而适当地对第三范式的要求进行违反，而允许存在少量的数据冗余</li>
<li>即反范式化是使用空间换取时间</li>
</ul>
</li>
<li>Q:为什么反范式化？<ul>
<li>1.减少表的关联数量</li>
<li>2.增加数据的读取效率</li>
<li>3.反范式化一定要适度</li>
</ul>
</li>
<li>Q:如何维护数据字典<ul>
<li>1.使用第三方工具对数据字典进行维护</li>
<li>2.利用数据库本身的备注字段来维护数据字典。以MySQL为例</li>
<li><img src="https://img.shiqi-lu.tech/20200905201947.png"></li>
<li>3.导出数据字典</li>
<li><img src="https://img.shiqi-lu.tech/20200905201954.png"></li>
</ul>
</li>
<li>Q:如何选择合适的列建立索引？<ul>
<li>1.出现在where从句，group by从句，order by从句中的列</li>
<li>2.可选择性高的列要放到索引的前面</li>
<li>3.索引中不要包括太长的数据类型</li>
<li>注意：</li>
<li>1.索引并不是越多越好，过多的索引不但会降低写效率而且会降低读的效率</li>
<li>2.定期维护索引碎片</li>
<li>3.在SQL语句中不要使用强制索引关键字</li>
</ul>
</li>
<li>Q:如何维护表结构？<ul>
<li>1.使用在线变更表结构的工具</li>
<li>2.同时对数据字典进行维护</li>
<li>3.控制表的宽度和大小</li>
</ul>
</li>
<li>Q:数据库中适合的操作<ul>
<li>1.批量操作 好于 逐条操作</li>
<li>2.禁止使用select *这样的查询</li>
<li>3.控制使用用户自定义函数</li>
<li>4.不要使用数据库中的全文索引</li>
</ul>
</li>
<li>Q:表的垂直拆分原则？<ul>
<li>1.经常一起查询的列放在一起</li>
<li>2.text, blob等大字段拆分出到附加表中</li>
<li>控制表的宽度可以进行表的垂直拆分</li>
<li>控制表的大小可以进行表的水平拆分</li>
</ul>
</li>
<li>Q:表的水平拆分方法？<ul>
<li>使用对主键进行hash key的方法</li>
<li><img src="https://img.shiqi-lu.tech/20200905202000.png"></li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.imooc.com/learn/117">数据库设计那些事</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《分布式技术原理与算法解析》课前必读 学习笔记</title>
    <url>/distrib-principal-algo-1/</url>
    <content><![CDATA[<h1 id="开篇词-四纵四横，带你透彻理解分布式技术"><a href="#开篇词-四纵四横，带你透彻理解分布式技术" class="headerlink" title="开篇词 | 四纵四横，带你透彻理解分布式技术"></a>开篇词 | 四纵四横，带你透彻理解分布式技术</h1><ul>
<li>Q：分布式技术涉及内容<ul>
<li><img src="https://img.shiqi-lu.tech/20200905201734.png"></li>
<li>按照业务的架构层次栈，自底向上按照资源、通信、数据与计算的维度，有4个技术层次：分布式资源池化、分布式通信、分布式数据存储于管理、分布式计算。即“在一定资源上，进行一定通信，通过一定计算，完成一定数据的加工和处理，从而对外提供特定的服务”</li>
<li>四条纵向技术是，在分布式环境下，无论是资源、通信、数据还是计算，都需要去解决协同、调度、追踪高可用，还有部署问题</li>
</ul>
</li>
</ul>
<h1 id="01-分布式缘何而起：从单兵，到游击队，到集团军"><a href="#01-分布式缘何而起：从单兵，到游击队，到集团军" class="headerlink" title="01 | 分布式缘何而起：从单兵，到游击队，到集团军"></a>01 | 分布式缘何而起：从单兵，到游击队，到集团军</h1><ul>
<li>Q:分布式的三个演进模式是什么？<ul>
<li>单机模式：所有业务和数据均部署到同一台机器上。这种模式的好处是功能、代码和数据集中，便于维护、管理和执行，但计算效率是瓶颈。即单机模式性能受限，存在单点失效的问题</li>
<li>数据并行（数据分布式）模式：对数据进行拆分，利用多台计算机并行执行多个相同任务，通过在相同的时间内完成多个相同任务，从而缩短所有任务的总体执行时间，但对提升单个任务的执行性能及降低时延无效</li>
<li>任务并行（任务分布式）：单任务拆分成多个子任务，多个子任务并行执行，只要一个复杂任务重的任意子任务的执行时间变短了，那么这个业务的整体执行时间也就变短了。该模式在提高性能、扩展性、可维护性等的同事，也带来了设计上的复杂性问题，比如复杂任务的拆分</li>
</ul>
</li>
<li>Q:分布式是什么？<ul>
<li>将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式</li>
</ul>
</li>
<li>Q:判断采取数据并行还是任务并行的方式：<ul>
<li>任务执行时间短，数据规模大，类型相同且无依赖：数据并行</li>
<li>任务复杂、执行时间长，且任务可拆分成多个子任务：任务并行</li>
</ul>
</li>
</ul>
<h1 id="02-分布式系统的指标：啥是分布式的三围"><a href="#02-分布式系统的指标：啥是分布式的三围" class="headerlink" title="02 | 分布式系统的指标：啥是分布式的三围"></a>02 | 分布式系统的指标：啥是分布式的三围</h1><ul>
<li>Q:分布式系统的目的是什么？<ul>
<li>为了用廉价的、普通的机器解决单个计算机处理复杂、大规模数据和任务时存在的性能问题、资源瓶颈问题，以及可用性和扩展性问题，即用更多的机器，处理更多的数据和更复杂的任务</li>
</ul>
</li>
<li>Q:分布式的性能(Performance)指标用来衡量什么？<ul>
<li>一个系统处理各种任务的能力</li>
</ul>
</li>
<li>Q:分布式的3个性能指标是什么？<ul>
<li>吞吐量（Throughput）、响应时间（Response Time）、完成时间（Turnaround Time）</li>
</ul>
</li>
<li>Q:吞吐量指的是什么？有哪3个指标？<ul>
<li>系统在一定时间内可以处理的任务数</li>
<li>QPS(Queries Per Second)、TPS(Transactions Per Second)、BPS(Bits Per Second)</li>
</ul>
</li>
<li>Q:QPS是什么？<ul>
<li>查询每秒数，用于衡量一个系统每秒处理的查询数。数值越高说明对读操作的支持越好</li>
</ul>
</li>
<li>Q:TPS是什么？<ul>
<li>事务每秒数，用于衡量一个系统每秒处理的事务数。数值越高说明对写操作的支持越好</li>
</ul>
</li>
<li>Q:BPS是什么？<ul>
<li>比特数每秒，用于衡量一个系统每秒处理的数据量。对于一些网络系统和数据管理系统，有的事务大需要写入更多数据，BPS更能客观反映系统吞吐量</li>
</ul>
</li>
<li>Q:响应时间是什么？<ul>
<li>系统相应一个请求或输入需要花费的时间，对于时延敏感的业务非常重要</li>
</ul>
</li>
<li>Q:完成时间是什么？<ul>
<li>系统真正完成一个请求或处理需要花费的时间</li>
</ul>
</li>
<li>Q:资源占用是什么？<ul>
<li>一个系统提供正常能力需要占用的硬件资源，如CPU、内存、硬盘等</li>
</ul>
</li>
<li>Q:空载资源占用和满载资源占用分别是什么？<ul>
<li>空载资源占用：一个系统在没有任何负载时的资源占用</li>
<li>满载资源占用：一个系统满额负载时的资源占用</li>
</ul>
</li>
<li>Q:可用性(Availability)和可靠性(Reliability)是什么？<ul>
<li>可用性：系统在面对各种异常时可以正确提供服务的能力，即允许部分组件失效的情况下，一个系统对外仍能正常提供服务的概率</li>
<li>可靠性：一个系统完全不出故障的概率，更多用在硬件领域</li>
</ul>
</li>
<li>Q:系统可用性的两个指标是什么？<ul>
<li>1.系统停止服务的时间与总的时间之比</li>
<li>2.某功能的失败次数与总的请求次数之比</li>
</ul>
</li>
<li>Q:可扩展性(Scalability)是什么?<ul>
<li>分布式系统通过扩展集群机器规模提高系统性能（吞吐、响应时间、完成时间）、存储容量、计算能力的特性</li>
</ul>
</li>
<li>Q:有哪两种扩展系统的方法？<ul>
<li>垂直/纵向扩展：增加单机的硬件能力</li>
<li>水平/横向扩展：增加计算机数量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>《分布式协议与算法实战》理论篇 学习笔记</title>
    <url>/distrib-protocal-algo-1/</url>
    <content><![CDATA[<h1 id="01-拜占庭将军问题：有叛徒的情况下，如何才能达成共识？"><a href="#01-拜占庭将军问题：有叛徒的情况下，如何才能达成共识？" class="headerlink" title="01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？"></a>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</h1><ul>
<li>Q:二忠一叛难题<ul>
<li>假设3个国家齐、楚、燕要攻打秦国，以只有半数以上的将军参与进攻，才能击败敌人，在这个期间，将军们彼此之间需要通过信使传递消息，然后协商一致之后，并让信使传递信息，按照“少数服从多数”的原则投票表决，然后在同一时间点发动进攻</li>
<li>但若有人暗通秦国出现作战计划不一致的情况。比如齐向楚、 燕分别发送了“撤退”的消息，燕向齐和楚发送了“进攻”的消息。撤退：进攻 =1:1，无 论楚投进攻还是撤退，都会成为 2:1，这个时候还是会形成一个一致性的作战方案</li>
<li>但是，楚这个叛徒在暗中配合秦国，让信使向齐发送了“撤退”，向燕发送了“进攻”，那么：</li>
<li>燕看到的是，撤退：进攻 =1:2</li>
<li>齐看到的是，撤退：进攻 =2:1。</li>
<li>按照“少数服从多数”的原则，就会出现燕单独进攻秦军，当然，最后肯定是因为寡不敌众，被秦军给灭了</li>
<li><img src="https://img.shiqi-lu.tech/20210223143644.png"></li>
</ul>
</li>
<li>Q:口信消息型拜占庭问题之解<ul>
<li>增加讨论中忠诚将军的数量，由3位将军变为4位将军。并约定如果没有收到命令，就执行预设的默认命令如“撤退”。以及进行两轮作战信息协商</li>
<li>第一轮<ul>
<li>先发送作战信息的将军作为指挥官，其他的将军作为副官</li>
<li>指挥官将他的作战信息发送给每位副官</li>
<li>每位副官，将从指挥官处收到的作战信息，作为他的作战指令；如果没有收到作战信 息，将把默认的“撤退”作为作战指令</li>
</ul>
</li>
<li>第二轮<ul>
<li>除了第一轮的指挥官外，剩余的 3 位将军将分别作为指挥官，向另外 2 位将军发送作战信息；</li>
<li>然后，这 3 位将军按照“少数服从多数”，执行收到的作战指令</li>
</ul>
</li>
<li>这个解决办法实现了作战计划的一致性</li>
<li>如果叛将人数为 m，将军人数不能少于 3m + 1 ，那么拜占庭将军问题就能解决了</li>
<li>这个算法的前提是，叛将人数m是已知的，这个算法中，叛将数m决定递归循环的次数，即m+1轮</li>
</ul>
</li>
<li>Q:签名消息型拜占庭问题之解<ul>
<li>通过签名的方式，可在不增加将军人数的情况下，解决二忠一叛的难题</li>
<li>签名的特性：<ul>
<li>忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现</li>
<li>任何人都能验证将军签名的真伪</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20210223145130.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210223145141.png"></li>
</ul>
</li>
<li>Q:拜占庭容错算法和非拜占庭容错算法<ul>
<li>拜占庭将军问题描述的是最困难的，也是最复杂的一种分布式故障场景，除了存在故障行为，还存在恶意行为的一个场景。必须使用拜占庭容错算法（Byzantine Fault Tolerance，BFT）。还有：PBFT 算法，PoW 算法</li>
<li>在计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（Crash Fault Tolerance，CFT）。CFT 解决的是分布式的系统中存在故障，但不存在恶意节点的场景下的共识问题。这个场景可能会丢失消息，或者有消息重复，但不存在错误消息，或者伪造消息的情况。常见的算法有 Paxos 算法、Raft 算法、ZAB 协议</li>
</ul>
</li>
</ul>
<h1 id="02-CAP理论：分布式系统的PH试纸，用它来测酸碱度"><a href="#02-CAP理论：分布式系统的PH试纸，用它来测酸碱度" class="headerlink" title="02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度"></a>02 | CAP理论：分布式系统的PH试纸，用它来测酸碱度</h1><ul>
<li>Q:CAP的三个指标<ul>
<li>一致性Consistency：客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败，强调的是各节点间的数据一致</li>
<li>可用性Availability：任何来自客户端的请求，不管访问哪个节点，都能得到相应数据，但不保证是同一份最新数据，强调的是服务可用，但不保证数据的一致</li>
<li>分区容错性Partition Tolerance：当节点间出现任意数量的消息丢失或高延迟时，系统仍然可以继续提供服务，强调的是集群对分区故障的容错能力</li>
</ul>
</li>
<li>Q:CAP不可能三角<ul>
<li>是对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个</li>
<li><img src="https://img.shiqi-lu.tech/20210224102536.png"></li>
<li>在不存在网络分区的情况下，即分布式系统正常运行时（这也是系统在绝大部分时候所处的状态），就是说在不需要 P 时，C 和 A 能够同时保证。只有当发生分区故障的时候，也就是说需要 P 时，才会在 C 和 A 之间做出选择。而且如果各节点数据不一致，影响到了系统运行或业务运行（也就是说会有负面的影响），推荐选择 C，否则选 A</li>
</ul>
</li>
<li>Q:CAP的三个模型<ul>
<li>CA 模型，在分布式系统中不存在。因为舍弃 P，意味着舍弃分布式系统，就比如单机版关系型数据库 MySQL，如果 MySQL 要考虑主备或集群部署时，它必须考虑 P</li>
<li>CP 模型，采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入，典型的应用是 ZooKeeper，Etcd 和 HBase</li>
<li>AP 模型，采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。典型应用就比如 Cassandra 和 DynamoDB</li>
</ul>
</li>
</ul>
<h1 id="03-ACID理论：CAP的酸，追求一致性"><a href="#03-ACID理论：CAP的酸，追求一致性" class="headerlink" title="03 | ACID理论：CAP的酸，追求一致性"></a>03 | ACID理论：CAP的酸，追求一致性</h1><ul>
<li>Q:二阶段提交协议<ul>
<li>提交请求阶段（又称投票阶段）<ul>
<li>协调者(Coordinator)向所有节点发起请求，各节点评估事务中需要操作的对象和对象状态，是否准备好，能否提交新操作。如果能，预留时间并锁定，不再安排其它事务</li>
<li>这个阶段每个参与者投票表决事务是放弃还是提交。一旦参与者投票要求提交事务，那么就不允许放弃事务。在一个参与者投票要求提交事务之前，它必须保证能够执行提交协议中它自己那一部分，即使参与者出现故障或者中途被替换掉。这个特性，是需要在代码实现时保障的</li>
</ul>
</li>
<li>提交执行阶段（又称完成阶段）<ul>
<li>事务的每个参与者执行最终统一的决定，提交事务或者放弃事务，这个是为了实现ACID中的原子性</li>
</ul>
</li>
</ul>
</li>
<li>Q:原始的二阶段提交协议和 XA 协议存在的问题是<ul>
<li>在提交请求阶段，需要预留资源，在资源预留期间，其他人不能操作（比如，XA 在第一阶段会将相关资源锁定）</li>
<li>数据库是独立的系统</li>
<li>因此无法根据业务特点弹性地调整锁的粒度，这些都会影响数据库的并发性能</li>
</ul>
</li>
<li>Q:TCC(Try预留-Confirm确认-Cancel取消)<ul>
<li>预留阶段<ul>
<li>协调者注册确认操作和撤销操作，各个节点预留资源，并返回消息答复</li>
</ul>
</li>
<li>确认阶段<ul>
<li>协调者执行确认操作，各节点收到确认操作的响应，完成分布式事务</li>
</ul>
</li>
<li>撤销阶段<ul>
<li>如果预留阶段出错，则进入撤销阶段</li>
<li>协调者执行撤销操作，通知各个节点取消事务执行，并返回撤销操作的响应</li>
</ul>
</li>
<li>TCC 本质上是补偿事务，核心思想是针对每个操作都要注册一个与其对应的确认操作和补偿操作（也就是撤销操作）</li>
<li>TCC 不依赖于数据库的事务，而是在业务中实现了分布式事务，这样能减轻数据库的压力，但对业务代码的入侵性也更强，实现的复杂度也更高</li>
<li>荐在需要分布式事务能力时，优先考虑现成的事务型数据库（比如 MySQL XA），当现有的事务型数据库不能满足业务的需求时，再考虑基于 TCC 实现分布式事务</li>
</ul>
</li>
</ul>
<h1 id="04-BASE理论：CAP的碱，追求可用性"><a href="#04-BASE理论：CAP的碱，追求可用性" class="headerlink" title="04 | BASE理论：CAP的碱，追求可用性"></a>04 | BASE理论：CAP的碱，追求可用性</h1><ul>
<li>Q:BASE理论<ul>
<li>基本可用(Basically Available)</li>
<li>最终一致性(Eventually consistent)</li>
<li>软状态(Soft state)：实现服务可用性的时候系统数据的一种过渡状态，即不同节点间，数据副本存在短暂的不一致</li>
</ul>
</li>
<li>Q:实现基本可用的 4 板斧<ul>
<li>流量削峰：将访问请求错开，削弱请求峰值</li>
<li>延迟响应：把请求放在队列中排队等待，一段时间后，系统开始处理，并响应处理结果</li>
<li>体验降级：通过降低图片清晰度和大小，提升系统的处理能力</li>
<li>过载保护：把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了，直接拒绝超时请求；队列满了之后，清楚队列中一定数量的排队请求，保护系统不过载</li>
</ul>
</li>
<li>Q:实际工程实践中何实现最终一致性以什么为准<ul>
<li>以最新写入的数据为准，比如 AP 模型的 KV 存储采用的就是这种方式</li>
<li>以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准</li>
</ul>
</li>
<li>Q:实现最终一致性的具体方式<ul>
<li>读时修复：在读取数据时，检测数据的不一致，进行修复。如 Cassandra 的 Read Repair 实现，即在向Cassandra系统查询数据时，如果检测到不同节点的副本数据不一致，系统就自动修复数据</li>
<li>写时修复：在写入数据时，检测数据的不一致，进行修复。如 Cassandra 的 Hinted Handoff 实现。即Cannandra集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性</li>
<li>异步修复：最常用的方式，通过定时对账检测副本数据的一致性，并修复</li>
<li>写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐你在实现最终一致性时优先实现这种方式。而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，在开发实际系统时，要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响</li>
<li>实现最终一致性的时候，推荐同时实现自定义写一致性级别（All、Quorum、One、Any）， 让用户可以自主选择相应的一致性级别，比如可以通过设置一致性级别为 All，来实现强一致性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择方法汇总</title>
    <url>/feature-selection/</url>
    <content><![CDATA[<h1 id="什么是特征选择"><a href="#什么是特征选择" class="headerlink" title="什么是特征选择"></a>什么是特征选择</h1><ul>
<li>对一个学习任务来说，给定属性集，有些属性很有用，另一些则可能没什么用。这里的属性即称为“特征”(feature)。对当前学习任务有用的属性称为“相关特征”(relevant feature)、没什么用的属性称为“无关特征”(irrelevant feature)。从给定的特征集合中选择出相关特征子集的过程，即“特征选择”(feature selection)</li>
</ul>
<h1 id="特征选择的目的"><a href="#特征选择的目的" class="headerlink" title="特征选择的目的"></a>特征选择的目的</h1><ul>
<li><p>1.简化模型，使模型更易于理解：去除不相关的特征会降低学习任务的难度。并且可解释性能对模型效果的稳定性有更多的把握</p>
</li>
<li><p>2.改善性能：节省存储和计算开销</p>
</li>
<li><p>3.改善通用性、降低过拟合风险：减轻维数灾难，特征的增多会大大增加模型的搜索空间，大多数模型所需要的训练样本随着特征数量的增加而显著增加。特征的增加虽然能更好地拟合训练数据，但也可能增加方差</p>
</li>
</ul>
<h1 id="使用特征选择的前提"><a href="#使用特征选择的前提" class="headerlink" title="使用特征选择的前提"></a>使用特征选择的前提</h1><ul>
<li><p>1.训练数据包含许多冗余或无用的特征，移除这些特征并不会导致丢失信息。其中冗余是指一个本身很有用的特征与另外一个有用的特征强相关，或它包含的信息能从其它特征推演出来</p>
</li>
<li><p>2.特征很多但样本相对较少</p>
</li>
</ul>
<h1 id="特征选择的4个步骤"><a href="#特征选择的4个步骤" class="headerlink" title="特征选择的4个步骤"></a>特征选择的4个步骤</h1><ul>
<li><p>1.产生过程：产生特征或特征子集候选集合</p>
</li>
<li><p>2.评价函数：衡量特征或特征子集的重要性或者好坏程度，即量化特征变量和目标变量之间的联系以及特征之间的相互联系。为了避免过拟合，可用交叉验证的方式来评估特征的好坏</p>
</li>
<li><p>3.停止准则：为了减少计算复杂度，需设定一个阈值，当评价函数值达到阈值后搜索停止</p>
</li>
<li><p>4.验证过程：在验证数据集上验证选出来的特征子集的有效性</p>
</li>
</ul>
<h1 id="特征选择的三个方法"><a href="#特征选择的三个方法" class="headerlink" title="特征选择的三个方法"></a>特征选择的三个方法</h1><ul>
<li><p>Filter(过滤法)</p>
</li>
<li><p>Wrapper(包装法)</p>
</li>
<li><p>Embedded(嵌入法)</p>
</li>
</ul>
<h1 id="Filter-过滤法"><a href="#Filter-过滤法" class="headerlink" title="Filter(过滤法)"></a>Filter(过滤法)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>按照发散性或相关性对各个特征进行评分，设定阈值或者待选择特征的个数进行筛选，分为单变量过滤方法和多变量过滤方法</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>单变量过滤方法：不需要考虑特征之间的相互关系，按照特征变量和目标变量之间的相关性或互信息对特征进行排序，过滤掉最不相关的特征变量。优点是计算效率高、不易过拟合</p>
</li>
<li><p>多变量过滤方法：考虑特征之间的相互关系，常用方法有基于相关性和一致性的特征选择</p>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>不依赖于任何机器学习方法，且不需要交叉验证，计算效率比较高</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>没有考虑机器学习算法的特点</li>
</ul>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li><img src="https://img.shiqi-lu.tech/20201014172426.png?imageView2/2/h/80"></li>
</ul>
<h2 id="常用的过滤方法"><a href="#常用的过滤方法" class="headerlink" title="常用的过滤方法"></a>常用的过滤方法</h2><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><ul>
<li>即特征在训练集中出现的比例。若覆盖率很小，如有10000个样本，但某个特征只出现了5次，则次覆盖率对模型的预测作用不大，可删除</li>
</ul>
<h3 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h3><ul>
<li>先计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"><span class="comment"># 方差选择法，返回值为特征选择后的数据</span></span><br><span class="line"><span class="comment"># 参数threshold为方差的阈值</span></span><br><span class="line">VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>


<h3 id="Pearson-皮尔森-相关系数"><a href="#Pearson-皮尔森-相关系数" class="headerlink" title="Pearson(皮尔森)相关系数"></a>Pearson(皮尔森)相关系数</h3><ul>
<li>用于度量两个变量X和Y之间的线性相关性，结果的取值区间为[-1, 1]， -1表示完全的负相关(这个变量下降，那个就会上升)，+1表示完全的正相关，0表示没有线性相关性</li>
<li>计算方法为两个变量之间的协方差和标准差的商</li>
<li>$$\rho_{X, Y}=\frac{\operatorname{cov}(X, Y)}{\sigma_{X} \sigma_{Y}}=\frac{E\left[\left(X-\mu_{X}\right)\left(Y-\mu_{Y}\right)\right]}{\sigma_{X} \sigma_{Y}}$$</li>
<li>样本上的相关系数为</li>
<li>$$r=\frac{\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)\left(Y_{i}-\bar{Y}\right)}{\sqrt{\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}} \sqrt{\sum_{i=1}^{n}\left(Y_{i}-\bar{Y}\right)^{2}}}$$</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"><span class="comment"># 选择K个最好的特征，返回选择特征后的数据</span></span><br><span class="line"><span class="comment"># 第一个参数为计算评估特征是否好的函数，该函数输入特征矩阵和目标向量，</span></span><br><span class="line"><span class="comment"># 输出二元组（评分，P值）的数组，数组第i项为第i个特征的评分和P值。</span></span><br><span class="line"><span class="comment"># 在此为计算相关系数</span></span><br><span class="line"><span class="comment"># 其中参数k为选择的特征个数</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:pearsonr(x, Y), X.T)).T, </span><br><span class="line">            k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h3 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h3><ul>
<li>检验定性自变量对定性因变量的相关性。假设自变量有N种取值，因变量有M种取值，考虑自变量等于i且因变量等于j的样本频数的观察值与期望的差距，构建统计量</li>
<li>$$\chi^{2}=\sum \frac{(A-E)^{2}}{E}$$</li>
<li>这个统计量的含义即自变量对因变量的相关性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据</span></span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h3 id="互信息法-KL散度、相对熵-和最大信息系数-Mutual-information-and-maximal-information-coefficient-MIC"><a href="#互信息法-KL散度、相对熵-和最大信息系数-Mutual-information-and-maximal-information-coefficient-MIC" class="headerlink" title="互信息法(KL散度、相对熵)和最大信息系数 Mutual information and maximal information coefficient (MIC)"></a>互信息法(KL散度、相对熵)和最大信息系数 Mutual information and maximal information coefficient (MIC)</h3><ul>
<li>评价定性自变量对定性因变量的相关性，评价类别型变量对类别型变量的相关性，互信息越大表明两个变量相关性越高，互信息为0时，两个变量相互独立。互信息的计算公式为</li>
<li>$$I(X ; Y)=\sum\limits_{x \in X} \sum\limits_{y \in Y} p(x, y) \log \frac{p(x, y)}{p(x) p(y)}=D_{K L}(p(x, y) | p(x) p(y))$$</li>
<li>其中，p(x)和p(y)为X和Y的边际概率分布函数，p(x,y)为X和Y的联合概率分布函数。直观上，互信息度量两个随机变量之间共享的信息，也可表示为由于X的引入而使Y的不确定性减少的量，这时互信息与信息增益相同</li>
<li>皮尔逊系数只能衡量线性相关性而互信息系数能够很好地度量各种相关性，但是计算相对复杂一些</li>
<li>互信息不能直接用于特征选择的两个原因<ul>
<li>1.不属于度量方式，不能归一化，在不同数据上的结果不能做比较</li>
<li>2.对于连续变量的计算不是很方便(X和Y都是集合，$x_i,y$都是离散值)，通常变量需要先离散化，而互信息的结果对离散化的方式很敏感</li>
</ul>
</li>
<li>为了处理定量数据，提出了最大信息系数法，它首先寻找一种最优的离散化方式，然后把互信息取值转换成一种度量方式，取值区间在[0, 1]</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"><span class="comment">#由于MINE的设计不是函数式的，定义mic方法将其为函数式的</span></span><br><span class="line"><span class="comment">#返回一个二元组，二元组的第2项设置成固定的P值0.5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mic</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    m = MINE()</span><br><span class="line">    m.compute_score(x, y)</span><br><span class="line">    <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#选择K个最好的特征，返回特征选择后的数据</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, </span><br><span class="line">            k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h3 id="Fisher得分"><a href="#Fisher得分" class="headerlink" title="Fisher得分"></a>Fisher得分</h3><ul>
<li>对于分类问题，好的特征应该是在同一个类别中的取值比较相似，而在不同类别之间的取值差异比较大。因此特征i的重要性可用Fiser得分$S_i$来表示</li>
<li>$$S_{i}=\frac{\sum_{j=1}^{K} n_{j}\left(\mu_{i j}-\mu_{i}\right)^{2}}{\sum_{j=1}^{K} n_{j} \rho_{i j}^{2}}$$</li>
<li>其中，$u_{ij}$和$\rho_{ij}$分别是特征i在类别j中均值和方差，$\mu_i$为特征i的均值，$n_j$为类别j中的样本数。Fisher得分越高，特征在不同类别之间的差异性越大、在同一类别中的差异性越小，则特征越重要</li>
</ul>
<h3 id="相关特征选择-Correlation-Feature-Selection-CFS"><a href="#相关特征选择-Correlation-Feature-Selection-CFS" class="headerlink" title="相关特征选择(Correlation Feature Selection, CFS)"></a>相关特征选择(Correlation Feature Selection, CFS)</h3><ul>
<li>该方法基于的假设是，好的特征集合包含跟目标变量非常相关的特征，但这些特征之间彼此不相关。对于包含k个特征的集合，CFS准则定义为</li>
<li>$$\mathrm{CFS}=\max \limits_{S_{k}}\left[\frac{r_{c f_{1}}+r_{c f_{2}}+\cdots+r_{c f_{k}}}{\sqrt{k+2\left(r_{f_{1} f_{2}}+\cdots+r_{f_{i} f_{j}}+\cdots+r_{f_{k} f_{1}}\right)}}\right]$$</li>
<li>其中，$r_{cf_i}$和$r_{f_i f_j}$是特征变量和目标变量之间，以及特征变量和特征变量之间的相关性，这里的相关性不一定是皮尔森相关系数或斯皮尔曼相关系数</li>
</ul>
<h3 id="最小冗余最大相关性-Minimum-Redundancy-Maximum-Relevance-mRMR"><a href="#最小冗余最大相关性-Minimum-Redundancy-Maximum-Relevance-mRMR" class="headerlink" title="最小冗余最大相关性(Minimum Redundancy Maximum Relevance, mRMR)"></a>最小冗余最大相关性(Minimum Redundancy Maximum Relevance, mRMR)</h3><ul>
<li>由于单变量过滤法只考虑了单特征变量和目标变量之间的相关性，因此选择的特征子集可能过于冗余。mRMR在进行特征时考虑到了特征之间的冗余性，具体做法是对跟已选择特征相关性较高的冗余特征进行惩罚</li>
<li>mRMR可以使用多种相关性的度量指标，如互信息、相关系数以及其它距离或相似度分数</li>
<li>以互信息为例，特征集合S和目标变量c之间的相关性可定义为，特征集合中所有单个特征变量$f_i$和目标变量c的互信息值$I(f_i;c)$的平均值：</li>
<li>$$D(S, c)=\frac{1}{|S|} \sum\limits_{f_{i} \in S} I\left(f_{i} ; c\right)$$</li>
<li>S中所有特征的冗余性为所有特征变量之间的互信息$I(f_i;f_i)$的平均值</li>
<li>$$R(S)=\frac{1}{|S|^{2}} \sum\limits_{f_{i}, f_{j} \in S} I\left(f_{i} ; f_{j}\right)$$</li>
<li>则mRMR准则为</li>
<li>$$\operatorname{mRMR}=\max \limits_{S}[D(S, c)-R(S)]$$</li>
<li>通过求解上述优化问题即可得到特征子集</li>
<li>在一些特定的情况下，mRMR算法可能对特征的重要性估计不足，它没有考虑到特征之间的组合可能与目标变量比较相关。如果单个特征的分类能力都比较弱，但进行组合后分类能力很强，这时mRMR方法效果一般比较差(如目标变量由特征变量之间进行XOR运算得到)</li>
<li>mRMR是一种典型的进行特征选择的增量贪心策略：某个特征一旦被选择了，在后续的步骤不会删除</li>
<li>mRMR可改写为全局的二次规划的优化问题(即特征集合为特征全集的情况)：</li>
<li>$$\mathrm{QPFS}=\min\limits_{x}\left[\alpha \boldsymbol{x}^{\mathrm{T}} \boldsymbol{H} \boldsymbol{x}-\boldsymbol{x}^{\mathrm{T}} \boldsymbol{F}\right] \mathrm{s.t.} \sum\limits_{i=1}^{n} x_{i}=1, x_{i} \geqslant 0$$</li>
<li>其中$\boldsymbol{F}$为特征变量和目标变量相关性向量，$\boldsymbol{H}$为度量特征变量之间的冗余性的矩阵。QPFS可通过二次规划求解，QPFS偏向于选择熵比较小的特征，这是因为特征自身的冗余性$I(f_i;f_j)$</li>
<li>另一种全局的基于互信息的方法是基于条件相关性的</li>
<li>$$\mathrm{SPEC}_{\mathrm{CMI}}=\max\limits_{x}\left[\boldsymbol{x}^{\mathrm{T}} \boldsymbol{Q} \boldsymbol{x}\right] \text { s.t. }|x|=1, x_{i} \geqslant 0$$</li>
<li>其中，$Q_{i i}=I\left(f_{i} ; c\right), Q_{i j}=I\left(f_{i} ; c \mid f_{j}\right), i \neq j$。$\mathrm{SPEC}_{\mathrm{CMI}}$方法的优点是可以通过求解矩阵Q的主特征向量来求解，而且可以处理二阶的特征组合</li>
</ul>
<h1 id="Wrapper-包装法"><a href="#Wrapper-包装法" class="headerlink" title="Wrapper(包装法)"></a>Wrapper(包装法)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul>
<li>使用机器学习算法评估特征子集的效果，可以检测两个或多个特征之间的交互关系，而且选择的特征子集让模型的效果达到最优。</li>
<li>这是特征子集搜索和评估指标相结合的方法。前者提供候选的新特征子集，后者基于新特征子集训练一个模型，并用验证集进行评估，为每一组特征子集进行打分</li>
<li>最简单的方法是在每一个特征子集上训练并评估模型，从而找出最优的特征子集</li>
</ul>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>1.需要对每一组特征子集训练一个模型，计算量很大</li>
<li>2.样本不够充分的情况下容易过拟合</li>
<li>3.特征变量较多时计算复杂度太高</li>
</ul>
<h2 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h2><p><img src="https://img.shiqi-lu.tech/20201014173616.png?imageView2/2/h/120"></p>
<h2 id="3种常用的特征子集搜索方法"><a href="#3种常用的特征子集搜索方法" class="headerlink" title="3种常用的特征子集搜索方法"></a>3种常用的特征子集搜索方法</h2><h3 id="1-完全搜索"><a href="#1-完全搜索" class="headerlink" title="1.完全搜索"></a>1.完全搜索</h3><ul>
<li>即穷举法，遍历所有可能的组合达到全局最优，时间复杂度$2^n$</li>
</ul>
<h3 id="2-启发式搜索"><a href="#2-启发式搜索" class="headerlink" title="2.启发式搜索"></a>2.启发式搜索</h3><ul>
<li>序列向前选择：特征子集从空集开始，每次只加入一个特征，时间复杂度为$O(n+(n-1)+(n-2)+\ldots+1)=O\left(n^{2}\right)$</li>
<li>序列向后选择：特征子集从全集开始，每次删除一个特征，时间复杂度为$O(n^{2})$</li>
</ul>
<h3 id="3-随机搜索"><a href="#3-随机搜索" class="headerlink" title="3.随机搜索"></a>3.随机搜索</h3><ul>
<li>执行序列向前或向后选择时，随机选择特征子集</li>
</ul>
<h3 id="4-递归特征消除法"><a href="#4-递归特征消除法" class="headerlink" title="4.递归特征消除法"></a>4.递归特征消除法</h3><ul>
<li>使用一个基模型进行多轮训练，每轮训练后通过学习器返回的coef_或者feature_importances_消除若干权重较低的特征，再基于新的特征集进行下一轮训练</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="comment">#递归特征消除法，返回特征选择后的数据</span></span><br><span class="line"><span class="comment">#参数estimator为基模型</span></span><br><span class="line"><span class="comment">#参数n_features_to_select为选择的特征个数</span></span><br><span class="line">RFE(estimator=LogisticRegression(), </span><br><span class="line">    n_features_to_select=<span class="number">2</span>).fit_transform(iris.data, </span><br><span class="line">                                          iris.target)</span><br></pre></td></tr></table></figure>


<h1 id="Embedded-嵌入法"><a href="#Embedded-嵌入法" class="headerlink" title="Embedded(嵌入法)"></a>Embedded(嵌入法)</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul>
<li>将特征选择嵌入到模型的构建过程中，具有包装法与机器学习算法相结合的优点，也具有过滤法计算效率高的优点</li>
</ul>
<h2 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h2><ul>
<li><img src="https://img.shiqi-lu.tech/20201014183741.png?imageView2/2/h/120"></li>
</ul>
<h2 id="LASSO方法"><a href="#LASSO方法" class="headerlink" title="LASSO方法"></a>LASSO方法</h2><ul>
<li>使用LASSO(Least Absolute Shrinkage and Selection Operator)方法</li>
<li>$$\min\limits_{\beta \in \mathbb{R}^{p}}\{\frac{1}{N}|y-X \boldsymbol{\beta}|_{2}^{2}+\lambda|\boldsymbol{\beta}| _{1}\}$$</li>
<li>通过对回归系数添加$L_1$惩罚项来防止过拟合，可以让特定的回归系数变为0，从而可以选择一个不包含那些系数的更简单的模型</li>
<li>实际应用中，$\lambda$越大，回归系数越稀疏，$\lambda$一般采用交叉验证的方式来确定</li>
<li>线性回归、逻辑回归、FM/FFM以及神经网络都可以添加$L_1$惩罚项</li>
<li>即使用带惩罚项的基模型，除了筛选出特征外，同时也进行了降维</li>
<li>实际上，L1惩罚项降维的原理是，在多个对目标值具有同等相关性的特征中，只保留一个，所以没保留的特征并不代表不重要</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="comment">#带L1惩罚项的逻辑回归作为基模型的特征选择</span></span><br><span class="line">SelectFromModel(LogisticRegression(</span><br><span class="line">          penalty=<span class="string">&quot;l1&quot;</span>, C=<span class="number">0.1</span>)).fit_transform(</span><br><span class="line">               iris.data,iris.target)</span><br></pre></td></tr></table></figure>


<h2 id="基于树模型的特征选择方法"><a href="#基于树模型的特征选择方法" class="headerlink" title="基于树模型的特征选择方法"></a>基于树模型的特征选择方法</h2><ul>
<li>在决策树中，深度较浅的节点一般对应的特征分类能力更强(可以将更多的样本区分开)</li>
<li>对于基于决策树的算法，如随机森林，重要的特征更有可能出现在深度较浅的节点，而且出现的次数可能越多</li>
<li>即可基于树模型中特征出现次数等指标对特征进行重要性排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">  <span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">  <span class="comment">#GBDT作为基模型的特征选择</span></span><br><span class="line">SelectFromModel(</span><br><span class="line">      GradientBoostingClassifier()).fit_transform(</span><br><span class="line">        iris.data,iris.target)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>美团机器学习实践2.2节</p>
</li>
<li><p>精通特征工程2.6节</p>
</li>
<li><p>特征工程入门与实践第5章</p>
</li>
<li><p>机器学习-周志华第11章</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/74198735">【机器学习】特征选择(Feature Selection)方法汇总</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/28641663">机器学习中，有哪些特征选择的工程方法？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客：为什么我要建博客和写博客</title>
    <url>/first-blog/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>很久之前就想搭建自己的博客了，只是嘛，一直都没有时间（划掉，就是懒）。这一次之所以突然下定决心要搞一波，完全是因为我的同桌真的是个超级大神，北大本科，杜克大学博士，也有一个自己的博客和介绍页，看着她的介绍页真的是超级牛，超级强，而且不仅是学习强，还在自己感兴趣的各个领域钻研的很深。让我不禁连连感叹，大牛的人生真的是超级强，真可谓最强鸡血，对比下来仿佛我白活了这么多年，没有留下任何值得留存的记录。</p>
<p>所以，受到这个启发（主要是刺激），我也要开始搭建自己的博客和个人主页，但同时我觉得我最好同时发布和维护3个平台，一个是CSDN，一个是公众号，一个是这个博客。毕竟文章写好之后，多发布一下几乎不费时间。</p>
<h1 id="为什么要选择github和hexo"><a href="#为什么要选择github和hexo" class="headerlink" title="为什么要选择github和hexo"></a>为什么要选择github和hexo</h1><p>选择github主要是因为能借助git的版本管理，顺便可以在github的热力图刷的好看一点，还有托管在github免费哇，不需要再另外维护云主机，不想当运维。省一笔主机钱，我只需要出钱买个域名即可，万网这个.tech域名买了10年也才199块，就是整个博客搭建中的唯一花销了</p>
<p>选择hexo是因为，能支持markdown的书写，和我现有的工具套件能配套上，可以无缝迁移过来，hexo的生态和主题都相对完善。</p>
<h1 id="过程和踩坑"><a href="#过程和踩坑" class="headerlink" title="过程和踩坑"></a>过程和踩坑</h1><h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>直接上<a href="https://wanwang.aliyun.com/">万网</a>购买自己的域名，做完实名认证之后即可先放着，详细步骤具体参考<a href="https://zhuanlan.zhihu.com/p/103860494">知乎</a>。</p>
<h2 id="安装node和hexo，并部署到github"><a href="#安装node和hexo，并部署到github" class="headerlink" title="安装node和hexo，并部署到github"></a>安装node和hexo，并部署到github</h2><p>具体参考<a href="https://zhuanlan.zhihu.com/p/105715224">知乎</a>，我是安装在macOS上，不需要搞这里面复杂的各种环境变量。</p>
<p>踩坑：我原本以为是建完git仓库后，把仓库pull下来，在里面初始化hexo，但后面看了一下，是要在空文件夹操作，并且后续发布到github的文件是hexo进行编译后的文件。</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>能够部署之后保证通过github.io能访问即可做域名解析，具体参考<a href="https://zhuanlan.zhihu.com/p/103813944">知乎</a></p>
<h2 id="挑选主题"><a href="#挑选主题" class="headerlink" title="挑选主题"></a>挑选主题</h2><p>原本我想直接在<a href="https://hexo.io/themes/">官方的主题链接</a>里挑一个比较合适的，给自己定了几个标准：</p>
<ol>
<li>整体必须是简洁的，那种大量有图片装饰的，背景花哨的不考虑（原因是，挑图片暴露自己的垃圾审美，还要给每个博客挑配图太费心力了）</li>
<li>必须能支持公式、代码块高亮等的解析</li>
<li>偏好整体布局要简洁，偏好侧边栏在右边，并且偏好文章要有侧边栏</li>
<li>主题必须有开发者长期维护和更新</li>
<li>能有评论系统</li>
</ol>
<p>在上面看花了眼，都没有一个不合适的，看了大半天，猛然觉得自己挑选的思路不对，在最原始的未经过筛选的主题站里挑选，能不费劲吗？</p>
<p>转换思路，直接搜推荐的hexo主题，然后看到next主题是几乎完全符合我的要求的，然后发现next主题经历了好几个大版本的迭代，甚至github仓库都换了几次，直接上最新的8.0版本，拉下来</p>
<h2 id="next主题各种调整优化"><a href="#next主题各种调整优化" class="headerlink" title="next主题各种调整优化"></a>next主题各种调整优化</h2><p>next主题中可以进行自主化调整的地方还挺多的，而且8.0版本中，很多地方和以往版本中有不一样的调整方式，我尽量把我用到的写一下。所做的所有操作基本是改一下themes/next下的_config.yml，很少一部分是更改hexo下的_config.yml，偶尔会使用npm装个包</p>
<h3 id="设置首页信息"><a href="#设置首页信息" class="headerlink" title="设置首页信息"></a>设置首页信息</h3><figure class="highlight yaml"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">每天净瞎搞</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;关注：AI/CS/数学/自我提升等&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;既然选择了远方，便只顾风雨兼程&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Shiqi</span> <span class="string">Lu</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://shiqi-lu.tech</span></span><br></pre></td></tr></table></figure>

<h3 id="风格选择"><a href="#风格选择" class="headerlink" title="风格选择"></a>风格选择</h3><p>我把四个风格都试了一遍，最后比较喜欢Gemini</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="支持暗黑模式"><a href="#支持暗黑模式" class="headerlink" title="支持暗黑模式"></a>支持暗黑模式</h3><p>这可是个意外惊喜，还会根据系统的设置自动适配</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="设置建站时间"><a href="#设置建站时间" class="headerlink" title="设置建站时间"></a>设置建站时间</h3><figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<h3 id="设置网站脚注的信息（图标、备案等）"><a href="#设置网站脚注的信息（图标、备案等）" class="headerlink" title="设置网站脚注的信息（图标、备案等）"></a>设置网站脚注的信息（图标、备案等）</h3><figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><p>先到网上找适合的图标，然后更新一下对应的文件，免费的图标素材网站：<a href="https://www.easyicon.net/1220579-maple_leaf_icon.html">Easyicon</a></p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/7-16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/7-32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/7-128.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/7-128.png</span></span><br></pre></td></tr></table></figure>

<h3 id="标签页和分类页"><a href="#标签页和分类页" class="headerlink" title="标签页和分类页"></a>标签页和分类页</h3><p>参考<a href="https://theme-next.js.org/docs/theme-settings/custom-pages.html#Adding-%C2%ABTags%C2%BB-Page">next文档</a></p>
<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>我喜欢放在右边，主要是因为视觉聚焦主要是在左边的</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br></pre></td></tr></table></figure>

<h3 id="打开文章标题下方更新时间、阅读时长等信息"><a href="#打开文章标题下方更新时间、阅读时长等信息" class="headerlink" title="打开文章标题下方更新时间、阅读时长等信息"></a>打开文章标题下方更新时间、阅读时长等信息</h3><p>参考<a href="https://theme-next.js.org/docs/theme-settings/posts.html#Post-Wordcount">官方文档</a><br>先按照npm包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-word-counter</span><br><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-word-counter</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="博客首页的摘要设置"><a href="#博客首页的摘要设置" class="headerlink" title="博客首页的摘要设置"></a>博客首页的摘要设置</h3><p>这个要配合文章中的description字段，或在文章中添加一行注释辅助，参考<a href="https://theme-next.js.org/docs/theme-settings/posts.html?highlight=more#Preamble-Text">官方文档</a></p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button will be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="置顶的百分比和顶部进度条"><a href="#置顶的百分比和顶部进度条" class="headerlink" title="置顶的百分比和顶部进度条"></a>置顶的百分比和顶部进度条</h3><p>默认给的颜色有点花哨，我改成了灰色</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="comment"># color: &quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>

<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>在url里放置本地图片或者图床链接</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/7-128.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="代码块高亮风格选择"><a href="#代码块高亮风格选择" class="headerlink" title="代码块高亮风格选择"></a>代码块高亮风格选择</h3><p>使用了hightlight.js的高亮样式</p>
<figure class="highlight yaml"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;    &#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night-bright</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">flat</span></span><br></pre></td></tr></table></figure>

<h3 id="社交账号设置"><a href="#社交账号设置" class="headerlink" title="社交账号设置"></a>社交账号设置</h3><figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/shiqi-lu</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:traumlou@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="支持本地搜索"><a href="#支持本地搜索" class="headerlink" title="支持本地搜索"></a>支持本地搜索</h3><p>参考<a href="https://theme-next.js.org/docs/third-party-services/search-services.html?highlight=search#Local-Search">官方文档</a><br>先装包：<code>$ npm install hexo-generator-searchdb </code></p>
<figure class="highlight yaml"><figcaption><span>hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>评论系统选择了<a href="https://valine.js.org/">valine</a>，请参考<a href="https://theme-next.js.org/docs/third-party-services/comments.html?highlight=comme#Valine-China">next文档</a>，其中头像需要注册一下Gravatar，参考<a href="https://valine.js.org/avatar.html">头像配置</a>，这里的邮箱提醒好像有问题，官方说明的方法不能用了。这个以后再说吧，我也不想有个评论就给我发邮件，要真有比较紧急的事情，直接发我邮箱吧</p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>注意这里8.0更新之后，就不是通过安装插件改源码的方式实现，直接在文章的front-matter里面添加一个字段：sticky就可以实现了，值越高排的越前，默认为0是按照时间顺序，参考<a href="https://theme-next.js.org/docs/advanced-settings/front-matter.html?highlight=stick">官方文档</a></p>
<h3 id="文章赞赏"><a href="#文章赞赏" class="headerlink" title="文章赞赏"></a>文章赞赏</h3><p>要先准备好微信，支付宝等的二维码，然后放在images下或放在图床中</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Donate (Sponsor) settings</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, a donate button will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">觉得文章写得不错就请博主喝杯奶茶吧(*￣∇￣*)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>


<h1 id="简单的使用指南"><a href="#简单的使用指南" class="headerlink" title="简单的使用指南"></a>简单的使用指南</h1><h2 id="写新博文"><a href="#写新博文" class="headerlink" title="写新博文"></a>写新博文</h2><p>在blog目录下输入命令<code>hexo new post &lt;title&gt;</code>，会自动在<code>&lt;blog-dir&gt;/source/_posts</code>目录下生成对应的title文件，这时候用md编辑器打开写博客即可</p>
<h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>博文写完之后，因为各种不同的解析器和浏览器对md的支持会不一样，先本地看看效果，运行命令：<code>hexo clean &amp;&amp; hexo s</code>，然后根据提示在浏览器打开localhost:4000即可查看</p>
<h2 id="推送到网站上"><a href="#推送到网站上" class="headerlink" title="推送到网站上"></a>推送到网站上</h2><p>运行命令：<code>hexo clean &amp;&amp; hexo g -d</code>即可</p>
<h1 id="尚未完成部分"><a href="#尚未完成部分" class="headerlink" title="尚未完成部分"></a>尚未完成部分</h1><p>这部分以后看时间和心情做吧，每做一部分记录一部分吧</p>
<ul>
<li>SEO</li>
<li>个人简介</li>
<li>README</li>
<li>访问速度比较慢，考虑使用除github外的托管服务</li>
<li>考虑使用CI</li>
<li>考虑CDN加速</li>
<li>考虑把http转换成https</li>
<li>备案</li>
<li>图床替换成自己的域名</li>
<li>完善和链接一下领英</li>
<li>研究一下博客如何分享链接到微信</li>
</ul>
<h1 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h1><ul>
<li>在ipad上的safari显示的时候没有font awesome图标显示，文章内容侧边栏等显示不出来，但ipad的chrome没问题，iphone的safari也没问题，真是奇怪</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://kchen.cc/2016/11/12/hexo-instructions/">基于 Hexo 的全自动博客构建部署系统</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a></li>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></li>
<li><a href="https://github.com/next-theme/hexo-theme-next">Next8.0 Github</a></li>
<li><a href="https://theme-next.js.org/">Next8.0 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>自我提升</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样获得高质量睡眠</title>
    <url>/high-quality-sleep/</url>
    <content><![CDATA[<ul>
<li>1.增大动力：睡眠就像滑滑梯<ul>
<li>c1:增加睡眠动力的方法有哪几个呢?<ul>
<li>1.找到并且尊重自己的节律</li>
<li>2.白天要晒太阳</li>
<li>3.多做有氧运动</li>
<li>4.要避免白天小睡</li>
</ul>
</li>
<li>c1:如何找到自己的睡眠时长和节奏？<ul>
<li>找休闲的一天如周末。按照喜欢的方式,安排一天的生活，比如出去走一走,逛逛公园、爬爬山、看个电影、做个按摩，让自己放松下来，不要做特别刺激或者挑战的事</li>
<li>然后有意识地注意一下你在晚上什么时间会开始觉得困，然后在那个时点，上床睡觉</li>
<li>不要给自己任何的压力，睡到自然醒</li>
<li>然后记录下整个的时长和节奏</li>
</ul>
</li>
</ul>
</li>
<li>2.减少阻力：创造合适的心理环境<ul>
<li>c2:如何通过创造安静平和的心理环境来减少睡眠滑梯的阻力？<ul>
<li>1.要在睡眠和工作以及娱乐之间设定一个隔离，睡觉前的一个小时，尽可能地不要工作或者使用电子设备。可以做一些有仪式感的事情，比如散步、冥想、泡脚或泡澡、贴面膜、读书或听书，让自己放松下来</li>
<li>2.可以试着诱发「放松反射」，可以借助一个词、一句话或者呼吸本身，用一种被动的态度让自己放松下来</li>
<li>3.不要对睡眠有过高的预期。要试着降低睡不着时的那种紧张感，给自己暗示：睡几个小时都行，困了就睡，不困就好好呆着</li>
</ul>
</li>
<li>c2:如何诱发「放松反射」？<ul>
<li>找一个安静的地方坐下来，闭上眼睛，随便找个自己喜欢的词，如「放松」、「安静」、「幸福」，甚至「世界和平」，然后在脑子里默念这个词，不要停，一直坚持约 10 分钟的时间</li>
<li>这里的关键是，这个过程中大脑一定会走神，这没关系，发现走神了，说一句，「哦，走神了」，再回到原来的词上面。一直持续 10 到 15 分钟即可</li>
</ul>
</li>
</ul>
</li>
<li>3.减少阻力：创造合适的卧室环境<ul>
<li>c3:可以从哪些方面创造一个适合睡眠的室内环境？<ul>
<li>视觉<ul>
<li>1.安装厚窗帘或双层窗帘，避免室外灯光，保持黑暗，看不见手指的程度</li>
<li>2.关闭或移除发出蓝光的电子设备，手机电脑打开暗黑+护眼模式</li>
<li>3.床旁准备一副眼罩，必要时让眼睛完全隔离灯光</li>
</ul>
</li>
<li>触觉<ul>
<li>1.室温调至22°C-25°C，体温下降会触发睡眠驱动</li>
<li>2.床品干净、舒服，纯棉材料最好，每周定时换洗三件套</li>
<li>3.穿宽松、凉爽的睡衣</li>
<li>4.睡前泡澡、泡脚，可使用含镁的浴盐</li>
<li>5.按摩有助于睡眠</li>
</ul>
</li>
<li>听觉<ul>
<li>1.保持安静</li>
<li>2.使用「白噪音」应对突发的噪音</li>
<li>3.床旁准备一副耳塞，以防突发的噪音</li>
</ul>
</li>
<li>嗅觉<ul>
<li>1.可以摆放薰衣草味(或其他自然香味)的香包</li>
<li>2.白天要打开窗户换气</li>
</ul>
</li>
<li>味觉<ul>
<li>1.多吃含色氨酸的食物，比如豆类、小米、酸奶、海产品</li>
<li>2.睡前不要吃得太饱;</li>
<li>3.也可吃一些含镁的补充剂，如「甘氨酸镁」</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4.排除干扰：酒、咖啡、安眠药和午觉<ul>
<li>c4:喝酒对睡眠的影响是什么？<ul>
<li>喝酒能帮助入睡，却打断深度睡眠</li>
<li>但如果主要睡眠问题是入睡困难，可以少量饮酒（如一两杯红酒）来帮助入睡</li>
</ul>
</li>
<li>c4:咖啡因对睡眠的影响是什么？<ul>
<li>喝咖啡不等于能少睡会</li>
<li>腺苷是细胞代谢的副产品，堆积起来人体就会觉得困，而咖啡因的作用是阻止腺苷发挥作用，让身体以为好像还不困，但等咖啡因被人体代谢掉后，人会觉得更困，因为这时体内积累了更多的腺苷，并且开始发挥作用</li>
<li>咖啡因的半衰期是 4-6 个小时，推荐每个人每天的摄入量不超过 400 毫克，大致相当于一杯星巴克咖啡</li>
</ul>
</li>
<li>c4:复用安眠药的三个原则是什么？<ul>
<li>1.对于失眠来说，安眠药不是治疗的首选<ul>
<li>安眠药最适用于一些短期的，因为外界环境变化造成的睡眠障碍，比如上夜班倒休、坐飞机倒时差等等。慢性睡眠问题，不建议长期服药</li>
</ul>
</li>
<li>2.如果要吃药，一定要去咨询专科医生，不要自己随便在药店买安眠药</li>
<li>3.如果已经在服用医生处方的安眠药，则需要按需、间断和足量地服药</li>
</ul>
</li>
<li>c4:午睡需要掌握哪两点原则？<ul>
<li>1.午睡是用来弥补睡得不够，不是用来弥补睡得不好的</li>
<li>2.午睡不要太长，一般20到30分钟就可以</li>
</ul>
</li>
<li>c4:午睡后解困的小技巧是什么？<ul>
<li>用肉眼盯着蓝天看1-2分钟，尽可能睁大眼睛，让蓝光尽可能多地进入。因为蓝光刺激视神经，能进一步刺激下丘脑，影响褪黑激素的分泌，减少困意</li>
</ul>
</li>
</ul>
</li>
<li>5.形成习惯：改善睡眠微习惯<ul>
<li>c5:应该形成哪些睡眠微习惯？<ul>
<li>早上同一个点起床，包括周末</li>
<li>白天晒两分钟太阳</li>
<li>睡前做三件事<ul>
<li>1.把窗帘拉好，房间调暗，避免蓝光</li>
<li>2.把房间的温度调到22到25摄氏度，让环境能够凉下来</li>
<li>3.给自己一些有意识的放松，比如看书和听书，做一做冥想或者放松反射练习</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s培训第4课 资源清单</title>
    <url>/k8s-4/</url>
    <content><![CDATA[<p>来源：<a href="https://www.bilibili.com/video/BV1w4411y7Go?p=1">b站</a></p>
<ul>
<li>Q:集群资源有哪些分类？<ul>
<li>名称空间级别<ul>
<li>工作负载型资源(workload): Pod、ReplicaSet、Deployment、StatefulSet、DaemonSet、Job、CronJob</li>
<li>服务发现及负载均衡型资源(ServiceDiscovery LoadBalance)：Service、Ingress</li>
<li>配置与存储型资源：Volume(存储卷)、CSI(容器存储接口，可扩展各种第三方存储卷)</li>
<li>特殊类型的存储卷：ConfigMap(当配置中心来使用的资源类型)、Secret(保存敏感数据)、DownwardAPI(把外部环境中的信息输出给容器)</li>
</ul>
</li>
<li>集群级别：Namespace、Node、Role、ClusterRole、RoleBinding、ClusterRoleBinding</li>
<li>元数据级别：HPA、PodTemplate、LimitRange</li>
</ul>
</li>
<li>Q:容器报错后如何处理？<ul>
<li><code>kubectl describe pod myapp-pod</code></li>
<li>若有多个容器需要用-c指定，查看日志</li>
<li><code>kubectl log myapp-pod -c test</code></li>
</ul>
</li>
<li>Q:initContainer模板是什么？<ul>
<li>initContainers里面会按照顺序依次往下执行</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>Q:检测探针-就绪检测模板？readinessProbe-httpget</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">readiness-httpget-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-httpget-container</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">readinessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/index1.html</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Q:检测探针-存活检测模板？livenessProbe-exec</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-exec-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/busybox</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep 3600&quot;</span>]</span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;/tmp/live&quot;</span>]</span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Q:检测探针-存活检测模板？livenessProbe-httpget</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-httpget-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-httpget-container</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/index.html</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Q:检测探针-存活检测模板？livenessProbe-tcp</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">probe-tcp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Q:启动、退出动作pod模板</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo Hello from the poststop handler &gt; /usr/share/message&quot;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s培训第5课 资源管理器</title>
    <url>/k8s-5/</url>
    <content><![CDATA[<p>来源：<a href="https://www.bilibili.com/video/BV1w4411y7Go?p=1">b站</a></p>
<ul>
<li>Q:Pod有哪些分类？<ul>
<li>自主式Pod：Pod退出了，此类型的Pod不会被创建</li>
<li>控制器管理的Pod：在控制器的生命周期里，始终要维持Pod的副本数目</li>
</ul>
</li>
<li>Q:什么是控制器？<ul>
<li>k8s中内建了很多controller(控制器)，这些相当于一个状态机，用来控制Pod的具体状态和行为</li>
</ul>
</li>
<li>Q:控制器有哪些类型？<ul>
<li>ReplicationController和ReplicaSet</li>
<li>Deployment</li>
<li>DaemonSet</li>
<li>StateFulSet</li>
<li>Job/CronJob</li>
<li>Horizontal Pod Autoscaling</li>
</ul>
</li>
<li>Q:命令式编程和声明式编程的区别是什么？<ul>
<li>命令式编程：侧重于如何实现，需要把程序的实现过程按照逻辑结果一步步写下来，k8s使用create命令</li>
<li>声明式编程：侧重于定义想要什么，然后告诉计算机/引擎，让它帮忙实现，k8s使用apply命令</li>
</ul>
</li>
<li>Q:ReplicationController和ReplicaSet是什么？<ul>
<li>ReplicationController(RC)用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代，而如果异常多出来的容器也会自动回收</li>
<li>在新版本的k8s中建议使用ReplicaSet来取代ReplicationController。ReplicaSet跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector</li>
<li>创建命令<code>kubectl create -f rs.yaml</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">php-redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">dns</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li>Q:Deployment是什么？<ul>
<li>为Pod和ReplicaSet提供了一个声明式定义(declarative)方法，用来替代以前的ReplicationController来方便的管理应用</li>
<li>典型场景有：<ul>
<li>定义Deployment来创建Pod和ReplicaSet</li>
<li>滚动升级和回滚应用</li>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20200921170358.png"></li>
</ul>
</li>
<li><h2 id="Q-如何使用Deployment部署一个简单的Nginx应用"><a href="#Q-如何使用Deployment部署一个简单的Nginx应用" class="headerlink" title="Q:如何使用Deployment部署一个简单的Nginx应用"></a>Q:如何使用Deployment部署一个简单的Nginx应用</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建命令：<code>kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record</code></li>
<li>其中–record参数可以记录命令，可以很方便的查看每次revision的变化</li>
</ul>
</li>
<li>Q:如何查看deployment状态？<ul>
<li><code>kubectl get deployment</code></li>
</ul>
</li>
<li>Q:如何对Deployment进行扩容？<ul>
<li><code>kubectl scale deployment nginx-deployment --replicas 10</code></li>
</ul>
</li>
<li>Q:如何更新deployment镜像？<ul>
<li><code>kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</code></li>
<li>=前是容器名，后是镜像</li>
</ul>
</li>
<li>Q:如何回滚deployment<ul>
<li><code>kubectl rollout undo deployment/nginx-deployment</code></li>
</ul>
</li>
<li>Q:如何查看可回滚的deployment历史版本？<ul>
<li><code>kubectl rollout history deployment/nginx-deployment</code></li>
</ul>
</li>
<li>Q:如何回滚deployment到指定的历史版本？<ul>
<li><code>kubectl rollout undo deployment/nginx-deployment --to-version=2</code></li>
</ul>
</li>
<li>Q:如何查看rollout状态？<ul>
<li><code>kubectl rollout status deployment/nginx-deployment</code></li>
</ul>
</li>
<li>Q:如何编辑Deployment？<ul>
<li><code>kubectl edit deployment/nginx-deployment</code></li>
</ul>
</li>
<li>Q:Deployment的清理策略是什么？<ul>
<li>可以通过设置<code>.spec.revisonHistoryLimit</code>项来指定deployment最多保留多少revision历史记录。默认的会保留所有的revision；如果将该项设置为0，Deployment就不允许回退了</li>
</ul>
</li>
<li>Q:Deployment的更新策略是什么？<ul>
<li>保证在升级时只有一定数量的Pod是down的。默认的，它会确保至少有比期望的Pod数量少一个是up状态（最多一个不可用）</li>
<li>Deployment 同时也可以确保只创建出超过期望数量的一定数量的Pod。默认的，它会确保最多比期望的Pod数 量多一个的Pod是up的（最多1个surge）</li>
<li>未来的 Kuberentes 版本中，将从1-1变成25%-25%</li>
</ul>
</li>
<li>Q:DaemonSet是什么？<ul>
<li>确保全部(或者一些)Node上运行一个Pod的副本。当有Node加入集群时，也会为它们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除DaemonSet将会删除它创建的所有Pod</li>
<li>使用DaemonSet的一些典型用法：<ul>
<li>运行集群存储daemon，例如在每个Node上运行glusterd、ceph</li>
<li>在每个Node上运行日志手机daemon，例如fluentd、logstash</li>
<li>在每个Node上运行监控daemon，例如Prometheus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deamonset-example</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="comment"># 注意这个name和上面的metadata中的name必须要一致</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">deamonset-example</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">deamonset-example</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">daemonset-example</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Q:Job的作用是什么？<ul>
<li>负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</li>
<li>特殊说明<ul>
<li>spec.template格式同Pod</li>
<li>RestartPolicy仅支持Never或OnFailure</li>
<li>单个Pod时，默认Pod成功运行后Job即结束</li>
<li><code>.spec.completions</code>标志Job结束需要成功运行的Pod个数，默认为1</li>
<li><code>.spec.parallelism</code>标志并行运行的Pod的个数，默认为1</li>
<li><code>spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>, <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>] </span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>创建：<code>kubectl create -f job.yaml</code></li>
</ul>
</li>
<li>Q:CronJob的作用是什么？<ul>
<li>管理基于时间的Job，即：<ul>
<li>在给定时间点只运行一次</li>
<li>周期性地在给定时间点运行</li>
</ul>
</li>
<li>典型用法是：<ul>
<li>在给定的时间点调度Job运行</li>
<li>创建周期性运行的Job，如数据库备份、发送邮件</li>
</ul>
</li>
</ul>
</li>
<li>Q:如何查看cronjob状态？<ul>
<li><code>kubectl get cronjob</code></li>
</ul>
</li>
<li>Q:StatefulSet是什么？<ul>
<li>作为Controller为Pod提供唯一的标识。可以保证部署和scale的顺序</li>
<li>是为了解决有状态服务的问题(对应Delpoyments和ReplicaSets是为无状态服务而设计)，其应用场景包括：<ul>
<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service(即没有Cluster IP的Service)来实现</li>
<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次进行，基于init containers来实现</li>
<li>有序收缩，有序删除</li>
</ul>
</li>
</ul>
</li>
<li>Q:Horizontal Pod Autoscaling是什么？<ul>
<li>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的pod个数自动调整呢？就是Horizontal Pod Autoscaling，即使Pod水平自动缩放</li>
</ul>
</li>
<li>Q:如何查看命令详细信息如rs？<ul>
<li><code>kubectl explain rs</code></li>
</ul>
</li>
<li>Q:如何删除所有pod？<ul>
<li><code>kubectl delete pod --all</code></li>
</ul>
</li>
<li>Q:查看pod状态的时候如何查看标签？<ul>
<li><code>kubectl get pod --show-labels</code></li>
</ul>
</li>
<li>Q:如何给pod添加标签？<ul>
<li><code>kubectl label pod frontend-m8szd tier=frontend1</code></li>
<li>即给frontend-m8szd这个容器加了一个标签，若已存在，需要使用–overwrite=True来覆盖</li>
</ul>
</li>
<li>Q:如何删除所有rs？<ul>
<li><code>kubectl delete rs --all</code></li>
</ul>
</li>
<li>Q:如何查看pod的详细信息？<ul>
<li><code>kubectl get pod -o wide</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s培训第6课 Service</title>
    <url>/k8s-6/</url>
    <content><![CDATA[<ul>
<li>Q:Service是什么？<ul>
<li>k8s的service定义了这样一种抽象：一个pod的逻辑分组，一种可以访问它们的策略——通常称为微服务。这一组Pod能够被Service访问到，通常是通过Label Selector</li>
<li>只提供4层负载均衡能力，而没有7层功能，有时可能需要更多的匹配规则来转发请求，此时4层负载均衡是不支持的</li>
</ul>
</li>
<li>Q:Service有哪4种类型？<ul>
<li>ClusterIp：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟 IP</li>
<li>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过<NodeIP>: NodePort 来访问该服务</li>
<li>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到<NodeIP>: NodePort</li>
<li>ExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建， 这只有 kubernetes 1.7 或更高版本的 kube-dns 才支持</li>
</ul>
</li>
<li>Q:Service的实现流程是怎样？<ul>
<li><img src="https://img.shiqi-lu.tech/20201027163257.png"></li>
<li>1.监听服务的端点是由apiserver完成的，通过kube-proxy监控，进行服务和端点信息的发现</li>
<li>2.kube-proxy负责监控标签匹配的Pod的信息，并把它写入到iptables的规则里</li>
<li>3.当客户端想去访问svc的时候，其实访问的是iptables，并导向后端的pod的信息，即iptables通过kube-proxy写入的</li>
</ul>
</li>
<li>Q:service有哪3种代理模式？<ul>
<li>userspace代理模式</li>
<li><img src="https://img.shiqi-lu.tech/20201027171941.png"></li>
<li>iptables代理模式</li>
<li><img src="https://img.shiqi-lu.tech/20201027171954.png"></li>
<li>ipvs代理模式</li>
<li><img src="https://img.shiqi-lu.tech/20201027172005.png"></li>
<li>ipvs模式下，kube-proxy会监视k8s service对象和endpoints，调用netlink接口以相应地创建ipvs规则并定期与k8s service对象和endpoints对象同步ipvs规则，以确保ipvs状态与期望一致。访问服务时，流量将被重定向到其中一个后端Pod</li>
</ul>
</li>
<li>Q:ClusterIP的工作方式是什么？<ul>
<li>ClustuerIP主要在每个node节点使用iptables，将发向clusterIP对应端口的数据，转发到kube-proxy中。然后kube-proxy自己内部实现负载均衡的方法，并可以查询到这个service下对应pod的地址和端口，进而把数据转发给对应的Pod的地址和端口</li>
<li><img src="https://img.shiqi-lu.tech/20201027175214.png"></li>
<li>为了实现图上的功能，主要需要以下几个组件的协同工作：<ul>
<li>apiserver用户通过kubectl命令向apiserver发送创建service的命令，apiserver接收到请求后将数据存储到etcd中</li>
<li>kube-proxy k8s的每个节点中都有一个叫做kube-proxy的进程，这个进程负责感知service，pod的变化，并将变化的信息写入本地的iptables规则中</li>
<li>iptables使用NAT等技术将virtualIP的流量转至endpoint中</li>
</ul>
</li>
</ul>
</li>
<li>Q:ClusterIP的实验演示<ul>
<li>创建deployment：myapp-deploy.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">      <span class="attr">release:</span> <span class="string">stabel</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">stabel</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v2</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/6$ kubectl apply -f myapp-deploy.yaml</span><br><span class="line">deployment.apps/myapp-deploy created</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get pod</span><br><span class="line">NAME                           READY   STATUS              RESTARTS   AGE</span><br><span class="line">myapp-deploy-c7b5fb585-lw9rr   0/1     ContainerCreating   0          22s</span><br><span class="line">myapp-deploy-c7b5fb585-pqd8j   0/1     ContainerCreating   0          22s</span><br><span class="line">myapp-deploy-c7b5fb585-stkdm   0/1     ContainerCreating   0          22s</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get pod -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">myapp-deploy-c7b5fb585-lw9rr   1/1     Running   0          62m   10.244.6.101   zhangliang   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">myapp-deploy-c7b5fb585-pqd8j   1/1     Running   0          62m   10.244.8.108   kongming     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">myapp-deploy-c7b5fb585-stkdm   1/1     Running   0          62m   10.244.4.51    laojun       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.244.6.101</span><br><span class="line">Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>创建service信息：myapp-service.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">stabel</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/6$ kubectl apply -f myapp-service.yaml</span><br><span class="line">service/myapp created</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get svc</span><br><span class="line">NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">myapp   ClusterIP   10.101.48.92   &lt;none&gt;        80/TCP    20s</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get svc -n default</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   114d</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.101.48.92</span><br><span class="line">Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用命令：<code>ipvsadm -Ln</code>查看ipvs的情况</li>
<li>查看服务轮训的情况<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.101.48.92/hostname.html</span><br><span class="line">myapp-deploy-c7b5fb585-pqd8j</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.101.48.92/hostname.html</span><br><span class="line">myapp-deploy-c7b5fb585-stkdm</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.101.48.92/hostname.html</span><br><span class="line">myapp-deploy-c7b5fb585-lw9rr</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl 10.101.48.92/hostname.html</span><br><span class="line">myapp-deploy-c7b5fb585-lw9rr</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:Headless Service是什么？<ul>
<li>有时不需要或不想要负载均衡，以及单独的Service IP。遇到这种情况，可以通过制定ClusterIP(spec.clusterIP)的值为”None”来创建Headless Service。这类Service并不会分配Cluster IP，kube-proxy不会处理它们，而且平台也不会为它们进行负载均衡和路由器</li>
<li>通过这个方式来解决clustername和podname变化问题，即通过它来绑定</li>
</ul>
</li>
<li>Q:Headless Service的实验<ul>
<li>创建myapp-svc-headless.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-headless</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">&quot;None&quot;</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">t:</span> <span class="number">8</span><span class="string">```</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">```shell</span></span><br><span class="line"><span class="string">shiqi-lu@k8s-master:~/6$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">myapp-svc-headless.yaml</span></span><br><span class="line"><span class="string">service/myapp-headless</span> <span class="string">created</span></span><br><span class="line"><span class="string">shiqi-lu@k8s-master:~/6$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span></span><br><span class="line"><span class="string">NAME</span>             <span class="string">TYPE</span>        <span class="string">CLUSTER-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">myapp</span>            <span class="string">ClusterIP</span>   <span class="number">10.101</span><span class="number">.48</span><span class="number">.92</span>   <span class="string">&lt;none&gt;</span>        <span class="number">80</span><span class="string">/TCP</span>    <span class="string">46m</span></span><br><span class="line"><span class="string">myapp-headless</span>   <span class="string">ClusterIP</span>   <span class="string">None</span>           <span class="string">&lt;none&gt;</span>        <span class="number">80</span><span class="string">/TCP</span>    <span class="string">3m11s```</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">发现底下的地址为空</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">```shell</span></span><br><span class="line"><span class="string">shiqi-lu@k8s-master:~/6$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">kube-system</span> <span class="string">-o</span> <span class="string">wide</span></span><br><span class="line"><span class="string">NAME</span>                                            <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span>     <span class="string">IP</span>              <span class="string">NODE</span>               <span class="string">NOMINATED</span> <span class="string">NODE</span>   <span class="string">READINESS</span> <span class="string">GATES</span></span><br><span class="line"><span class="string">coredns-7ff77c879f-kdvsd</span>                        <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">1</span>          <span class="string">10d</span>     <span class="number">10.244</span><span class="number">.8</span><span class="number">.16</span>     <span class="string">kongming</span>           <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="string">coredns-7ff77c879f-vc9gn</span>                        <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">2</span>          <span class="string">10d</span>     <span class="number">10.244</span><span class="number">.1</span><span class="number">.116</span>    <span class="string">shennong</span>           <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;```</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">从coredns中找一个ip，下面这个命令试试来解析，格式是Service的名字+namespace+host</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">```shell</span></span><br><span class="line"><span class="string">shiqi-lu@k8s-master:~/6$</span> <span class="string">dig</span> <span class="string">-t</span> <span class="string">A</span> <span class="string">myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="string">@10.244.8.16</span></span><br><span class="line"></span><br><span class="line"><span class="string">;</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">DiG</span> <span class="number">9.11</span><span class="number">.3</span><span class="string">-1ubuntu1.13-Ubuntu</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">-t</span> <span class="string">A</span> <span class="string">myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="string">@10.244.8.16</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">global options:</span> <span class="string">+cmd</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">Got answer:</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WARNING:</span> <span class="string">.local</span> <span class="string">is</span> <span class="string">reserved</span> <span class="string">for</span> <span class="string">Multicast</span> <span class="string">DNS</span></span><br><span class="line"><span class="string">;;</span> <span class="string">You</span> <span class="string">are</span> <span class="string">currently</span> <span class="string">testing</span> <span class="string">what</span> <span class="string">happens</span> <span class="string">when</span> <span class="string">an</span> <span class="string">mDNS</span> <span class="string">query</span> <span class="string">is</span> <span class="string">leaked</span> <span class="string">to</span> <span class="string">DNS</span></span><br><span class="line"><span class="string">;;</span> <span class="string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="attr">opcode:</span> <span class="string">QUERY,</span> <span class="attr">status:</span> <span class="string">NOERROR,</span> <span class="attr">id:</span> <span class="number">54521</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">flags:</span> <span class="string">qr</span> <span class="string">aa</span> <span class="string">rd;</span> <span class="attr">QUERY:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">ANSWER:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">AUTHORITY:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ADDITIONAL:</span> <span class="number">1</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WARNING:</span> <span class="string">recursion</span> <span class="string">requested</span> <span class="string">but</span> <span class="string">not</span> <span class="string">available</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">;</span> <span class="attr">EDNS: version:</span> <span class="number">0</span><span class="string">,</span> <span class="string">flags:;</span> <span class="attr">udp:</span> <span class="number">4096</span></span><br><span class="line"><span class="string">;</span> <span class="attr">COOKIE:</span> <span class="string">a253bf35c4375eaf</span> <span class="string">(echoed)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">QUESTION SECTION:</span></span><br><span class="line"><span class="string">;myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="string">IN</span> <span class="string">A</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ANSWER SECTION:</span></span><br><span class="line"><span class="string">myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="number">30</span> <span class="string">IN</span> <span class="string">A</span> <span class="number">10.244</span><span class="number">.4</span><span class="number">.51</span></span><br><span class="line"><span class="string">myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="number">30</span> <span class="string">IN</span> <span class="string">A</span> <span class="number">10.244</span><span class="number">.6</span><span class="number">.101</span></span><br><span class="line"><span class="string">myapp-headless.shiqi-lu.svc.cluster.local.</span> <span class="number">30</span> <span class="string">IN</span> <span class="string">A</span> <span class="number">10.244</span><span class="number">.8</span><span class="number">.108</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">Query time:</span> <span class="number">0</span> <span class="string">msec</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">SERVER:</span> <span class="number">10.244</span><span class="number">.8</span><span class="number">.16</span><span class="comment">#53(10.244.8.16)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WHEN:</span> <span class="string">Tue</span> <span class="string">Oct</span> <span class="number">27</span> <span class="number">20</span><span class="string">:05:35</span> <span class="string">CST</span> <span class="number">2020</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">MSG SIZE  rcvd:</span> <span class="number">253</span></span><br><span class="line"><span class="string">shiqi-lu@k8s-master:~/6$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-o</span> <span class="string">wide</span></span><br><span class="line"><span class="string">NAME</span>                           <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span>    <span class="string">IP</span>             <span class="string">NODE</span>         <span class="string">NOMINATED</span> <span class="string">NODE</span>   <span class="string">READINESS</span> <span class="string">GATES</span></span><br><span class="line"><span class="string">myapp-deploy-c7b5fb585-lw9rr</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">122m</span>   <span class="number">10.244</span><span class="number">.6</span><span class="number">.101</span>   <span class="string">zhangliang</span>   <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="string">myapp-deploy-c7b5fb585-pqd8j</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">122m</span>   <span class="number">10.244</span><span class="number">.8</span><span class="number">.108</span>   <span class="string">kongming</span>     <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="string">myapp-deploy-c7b5fb585-stkdm</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">122m</span>   <span class="number">10.244</span><span class="number">.4</span><span class="number">.51</span>    <span class="string">laojun</span>       <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;```</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">虽然headless没有IP，但仍然可以通过访问域名的方式访问</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Q:NodePort是什么？</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">原理是在node上开了一个端口，将向该端口的流量导入到kube-proxy，然后由kube-proxy进一步给到对应的Pod</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">创建nodeport.yaml，除了type中不一样，其它几乎不变</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">```yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">stabel</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/6$ kubectl apply -f nodeport.yaml</span><br><span class="line">service/myapp configured</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get svc</span><br><span class="line">NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">myapp            NodePort    10.101.48.92   &lt;none&gt;        80:30707/TCP   64m</span><br><span class="line">myapp-headless   ClusterIP   None           &lt;none&gt;        80/TCP         21m</span><br><span class="line">shiqi-lu@k8s-master:~/6$ curl localhost:30707</span><br><span class="line">Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:LoadBalancer是什么？<ul>
<li>和nodePort其实是同一种方式，区别在于loadBalancer比nodePort多了一步，就是可以调用cloud provider去创建LoadBalancer来向节点导流</li>
<li><img src="https://img.shiqi-lu.tech/20201027202612.png"></li>
</ul>
</li>
<li>Q:ExternalName是什么?<ul>
<li>这种类型的Service通过返回CNAME和它的值，可以将服务映射到externalName字段的内容(例如:hub.atguigu.com)。ExternalName Service是Service的特例，它没有selector，也没有定义任何端口和endpoint。相反，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">hub.atguigu.com</span></span><br></pre></td></tr></table></figure></li>
<li>当查询主机my-service-1.default.svc.cluster.local (SVC_NAME.NAMESPACE.svc.cluster.local)时，集群的DNS服务将返回一个值hub.atguigu.com的CNAME记录。访问这个服务的工作方式和其它的相同，唯一不同的是重定向发生在DNS层，而且不会进行代理或转发</li>
</ul>
</li>
<li>Q:ExternalName的创建实验<ul>
<li>创建ex.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">hub.atguigu.com</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/6$ kubectl create -f ex.yaml</span><br><span class="line">service/my-service-1 created</span><br><span class="line">shiqi-lu@k8s-master:~/6$ kubectl get svc</span><br><span class="line">NAME             TYPE           CLUSTER-IP     EXTERNAL-IP       PORT(S)        AGE</span><br><span class="line">my-service-1     ExternalName   &lt;none&gt;         hub.atguigu.com   &lt;none&gt;         9s</span><br><span class="line">myapp            NodePort       10.101.48.92   &lt;none&gt;            80:30707/TCP   91m</span><br><span class="line">myapp-headless   ClusterIP      None           &lt;none&gt;            80/TCP         47m</span><br><span class="line">shiqi-lu@k8s-master:~/6$ dig -t A my-service-1.shiqi-lu.svc.cluster.local. @10.244.8.16</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.13-Ubuntu &lt;&lt;&gt;&gt; -t A my-service-1.shiqi-lu.svc.cluster.local. @10.244.8.16</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; WARNING: .local is reserved for Multicast DNS</span><br><span class="line">;; You are currently testing what happens when an mDNS query is leaked to DNS</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 60219</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">; COOKIE: ed3b24efd39612a1 (echoed)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;my-service-1.shiqi-lu.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">my-service-1.shiqi-lu.svc.cluster.local. 30 IN CNAME hub.atguigu.com.</span><br><span class="line"></span><br><span class="line">;; Query time: 39 msec</span><br><span class="line">;; SERVER: 10.244.8.16#53(10.244.8.16)</span><br><span class="line">;; WHEN: Tue Oct 27 20:45:03 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 148</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:nginx-ingress的工作原理<ul>
<li><img src="https://img.shiqi-lu.tech/20201027210932.png"></li>
<li>客户端访问域名，ingress必须先绑定一个域名，不同域名访问nginx，nginx会反向代理，负载均衡选择后端的service，每个service会有一些容器</li>
<li>nginx其实使用nodeport的方式</li>
<li><img src="https://img.shiqi-lu.tech/20201027210938.png"></li>
<li>首先k8s的apiserver和store建立监听状态，这里的监听方式是以协程的Pod的形式向apiserver发起连接的方案进行监听，如果发生新的数据写入，会被写入到updateChannel的循环队列里面，然后有一个nginxController的主进程会去监听这个循环队列里面的资源和事件，发生一个循环以后会更新一个事件，把它写入到我们的同步队列里去，等待被协程去更改配置文件，协程会定期的从队列里拉去执行添加的一些任务，如果有一些必要的直接需要去修改的，不需要去等待直接要更新的一些任务会自动发直接发送到SyncQueue协程，两个协程之间协商直接沟通，收取到所有的要更新的数据以后会去他去判断是否要进行一个重载(reload)，写入数据的这么一个方案，还是等等再去添加，如果有的话就会写入nginx主配置文件，然后重新载入nginx的一些数据，那如果不需要的话就等待后面去执行，直接发送构建的post的数据接口，也就是一些不需要存在的数据即可，最后以nginx模块去运行，那这就是nginx-ingress的进程以及协程的沟通方案</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s培训第8课 集群调度</title>
    <url>/k8s-8/</url>
    <content><![CDATA[<ul>
<li>Q:Scheduler是什么？<ul>
<li>kubernetes 的调度器，主要的任务是把定义的 pod 分配到集群的节点上。听起来非常简单，但有 很多要考虑的问题：<ul>
<li>公平：如何保证每个节点都能被分配资源</li>
<li>资源高效利用：集群所有资源最大化被使用</li>
<li>效率：调度的性能要好，能够尽快地对大批量的 pod 完成调度工作</li>
<li>灵活：允许用户根据自己的需求控制调度的逻辑</li>
</ul>
</li>
<li>Sheduler 是作为单独的程序运行的，启动之后会一直坚挺 API Server，获取 PodSpec.NodeName 为空的 pod， 对每个 pod 都会创建一个 binding，表明该 pod 应该放到哪个节点上</li>
</ul>
</li>
<li>Q: k8s的调度过程是怎样<ul>
<li>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为predicate；然后对通过的节点按照优先级排序，这个是priority；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误</li>
<li>Predicate 有一系列的算法可以使用：<ul>
<li>PodFitsResources：节点上剩余的资源是否大于 pod 请求的资源</li>
<li>PodFitsHost：如果 pod 指定了NodeName，检查节点名称是否和NodeName匹配</li>
<li>PodFitsHostPorts：节点上已经使用的port是否和pod申请的port冲突</li>
<li>PodSelectorMatches：过滤掉和pod指定的label不匹配的节点</li>
<li>NoDiskConflict：已经mount的volume和pod指定的volume不冲突，除非它们都是只读</li>
</ul>
</li>
<li>如果在predicate过程中没有合适的节点，pod会一直在pending状态，不断重试调度，直到有节点满足条件。 经过这个步骤，如果有多个节点满足条件，就继续priorities过程：按照优先级大小对节点排序</li>
<li>优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项的重要性）。这些优先级选项包括：<ul>
<li>LeastRequestedPriority ：通过计算 CPU 和 Memory 的使用率来决定权重，使用率越低权重越高。换句话说，这个优先级指标倾向于资源使用比例更低的节点</li>
<li>BalancedResourceAllocation：节点上 CPU 和 Memory 使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用</li>
<li>ImageLocalityPriority：倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高</li>
</ul>
</li>
<li>通过算法对所有的优先级项目和权重进行计算，得出最终的结果</li>
</ul>
</li>
<li>Q:结点亲和性<ul>
<li>pod.spec.nodeAﬃnity<ul>
<li>preferredDuringSchedulingIgnoredDuringExecution：软策略</li>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬策略</li>
</ul>
</li>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬策略<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">NotIn</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-node02</span></span><br></pre></td></tr></table></figure></li>
<li>preferredDuringSchedulingIgnoredDuringExecution：软策略<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span> <span class="comment"># 权重越大越亲和</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">source</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">qikqiak</span></span><br></pre></td></tr></table></figure></li>
<li>合体<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">NotIn</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-node02</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">source</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">qikqiak</span></span><br></pre></td></tr></table></figure></li>
<li>键值运算关系<ul>
<li>In：label 的值在某个列表中</li>
<li>NotIn：label 的值不在某个列表中</li>
<li>Gt：label 的值大于某个值</li>
<li>Lt：label 的值小于某个值</li>
<li>Exists：某个 label 存在</li>
<li>DoesNotExist：某个 label 不存在</li>
</ul>
</li>
</ul>
</li>
<li>Q:Pod亲和性<ul>
<li>pod.spec.aﬃnity.podAﬃnity/podAntiAﬃnity</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：软策略</li>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬策略<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-3</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-3</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">pod-1</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">pod-2</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:亲和性/反亲和性调度策略比较<ul>
<li><img src="https://img.shiqi-lu.tech/20201104154834.png"></li>
</ul>
</li>
<li>Q:给节点打标签<ul>
<li><code>kubectl label node k8s-node01 disk=ssd</code></li>
</ul>
</li>
<li>Q:k8s指定调度节点<ul>
<li>Pod.spec.nodeName 将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">7</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeName:</span> <span class="string">k8s-node01</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
<li>Pod.spec.nodeSelector：通过 kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配 label， 而后调度 Pod 到目标节点，该匹配规则属于强制约束<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">backEndNode1</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor/tomcat:8.5-jre8</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s培训第7课 存储</title>
    <url>/k8s-7/</url>
    <content><![CDATA[<ul>
<li>Q:Configmap是什么？<ul>
<li>许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConﬁgMap API 给我们提供了向容器中注入配置信息的机制，ConﬁgMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者 JSON 二进制大对象</li>
</ul>
</li>
<li>Q:如何使用目录或文件创建ConfigMap？<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/7$ ls dir</span><br><span class="line">game.properties  ui.properties</span><br><span class="line">shiqi-lu@k8s-master:~/7$ cat dir/game.properties</span><br><span class="line">game,,,,</span><br><span class="line">shiqi-lu@k8s-master:~/7$ cat dir/ui.properties</span><br><span class="line">ui,,,</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl create configmap t-config --from-file=dir</span><br><span class="line">configmap/t-config created</span><br></pre></td></tr></table></figure></li>
<li>Q:如何查看已创建的ConfigMap?<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get cm</span><br><span class="line">NAME       DATA   AGE</span><br><span class="line">t-config   2      113s</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get cm t-config</span><br><span class="line">NAME       DATA   AGE</span><br><span class="line">t-config   2      2m</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get cm t-config -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  game.properties: |</span><br><span class="line">    game,,,,</span><br><span class="line">  ui.properties: |</span><br><span class="line">    ui,,,</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2020-09-22T06:21:50Z&quot;</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:data:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:game.properties: &#123;&#125;</span><br><span class="line">        f:ui.properties: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2020-09-22T06:21:50Z&quot;</span><br><span class="line">  name: t-config</span><br><span class="line">  namespace: shiqi-lu</span><br><span class="line">  resourceVersion: &quot;20138794&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/shiqi-lu/configmaps/t-config</span><br><span class="line">  uid: 631fa2ae-7f55-46d2-9db3-e14222e61de6</span><br></pre></td></tr></table></figure>
<ul>
<li>–from-file这个参数可以使用多次</li>
</ul>
</li>
<li>Q:如何使用字面值创建Configmap？<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~/7$  kubectl create configmap sp-config --from-literal=special.how=very --from-literal=special.typen=charm</span><br><span class="line">configmap/sp-config created</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get configmap special-config</span><br><span class="line">Error from server (NotFound): configmaps &quot;special-config&quot; not found</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get configmap sp-config</span><br><span class="line">NAME        DATA   AGE</span><br><span class="line">sp-config   2      25s</span><br><span class="line">shiqi-lu@k8s-master:~/7$ kubectl get configmap sp-config -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  special.how: very</span><br><span class="line">  special.typen: charm</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2020-09-22T06:31:17Z&quot;</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:data:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:special.how: &#123;&#125;</span><br><span class="line">        f:special.typen: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2020-09-22T06:31:17Z&quot;</span><br><span class="line">  name: sp-config</span><br><span class="line">  namespace: shiqi-lu</span><br><span class="line">  resourceVersion: &quot;20140688&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/shiqi-lu/configmaps/sp-config</span><br><span class="line">  uid: b10fedc2-7131-4f8b-a168-135cd6d1e021</span><br></pre></td></tr></table></figure>
<ul>
<li>–from-literal参数可使用多次</li>
</ul>
</li>
<li>Q:如何以资源清单的方式创建Configmap？创建字面值<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">env-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">log_level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure></li>
<li>Q:如何在Pod中使用Configmap中的值？<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span> ]</span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">sp-config</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_TYPE_KEY</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">special.type</span></span><br><span class="line">    <span class="attr">envFrom:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">env-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure></li>
<li>Q:如何把configmap中的文件填入数据卷中？<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">special.how:</span> <span class="string">very</span></span><br><span class="line">  <span class="attr">special.type:</span> <span class="string">charm</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat /etc/config/special.how&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure></li>
<li>Q:如何修改ConfigMap？<ul>
<li><code>kubectl edit configmap log-config</code></li>
</ul>
</li>
<li>Q:Secret的作用是什么？<ul>
<li>解决密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或Pod Spec中。Secret可以以Volume或者环境变量的方式使用</li>
</ul>
</li>
<li>Q:Secret有哪三种类型？<ul>
<li>Service Account：用来访问k8s api，由k8s自动创建，并且会自动挂载到Pod的<code>/run/secrets/kubernetes.io/serviceaccount</code>目录中</li>
<li>Opaque：base64编码格式的Secret，用来存储密码、密钥等</li>
<li>kubernetes.io/dockerconﬁgjson：用来存储私有docker registry的认证信息</li>
</ul>
</li>
<li>Q:ServiceAccount的实践<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~$ kubectl run nginx --image nginx</span><br><span class="line">pod/nginx created</span><br><span class="line">shiqi-lu@k8s-master:~$ kubectl get pods</span><br><span class="line">NAME                           READY   STATUS              RESTARTS   AGE</span><br><span class="line">myapp-deploy-c7b5fb585-lw9rr   1/1     Running             0          20h</span><br><span class="line">myapp-deploy-c7b5fb585-pqd8j   1/1     Running             0          20h</span><br><span class="line">myapp-deploy-c7b5fb585-stkdm   1/1     Running             0          20h</span><br><span class="line">nginx                          0/1     ContainerCreating   0          14s</span><br><span class="line">shiqi-lu@k8s-master:~$ kubectl exec nginx ls /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl kubectl exec [POD] -- [COMMAND] instead.</span><br><span class="line">ca.crt</span><br><span class="line">namespace</span><br><span class="line">token</span><br></pre></td></tr></table></figure></li>
<li>Q:Opaque Secret的实践<ul>
<li>Opaque 类型的数据是一个 map 类型，要求 value 是 base64 编码格式<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi-lu@k8s-master:~$ echo -n &quot;admin&quot; | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">shiqi-lu@k8s-master:~$ echo -n &quot;1f2d1e2e67df&quot; | base64</span><br><span class="line">MWYyZDFlMmU2N2Rm```</span><br><span class="line">    - 创建secrets.yml</span><br><span class="line">    - ```yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  password: MWYyZDFlMmU2N2Rm</span><br><span class="line">  username: YWRtaW4=</span><br></pre></td></tr></table></figure></li>
<li>将Secret挂载到Volume中<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seret-test</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">seret-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">      readOnly: true</span></span><br></pre></td></tr></table></figure></li>
<li>将Secret导出到环境变量中<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">pod-deployment</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-1</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.atguigu.com/library/myapp:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEST_USER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEST_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:kubernetes.io/dockerconﬁgjson的实践<ul>
<li>使用 Kuberctl 创建 docker registry 认证的 secret<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret docker-registry myregistrykey --docker-server=DOCKER_REGISTRY_SERVER -docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL</span></span><br><span class="line">secret &quot;myregistrykey&quot; created.</span><br></pre></td></tr></table></figure></li>
<li>在创建Pod的时候，通过<code>imagePullSecrets</code>来引用刚创建的<code>myregistrykey</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">roc/awangyang:v1</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:emptyDir是什么？<ul>
<li>当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该结点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除Pod时，emptyDir中的数据将被永久删除</li>
<li>用法有：<ul>
<li>暂存空间，例如用于基于磁盘的合并排序</li>
<li>用作长时间计算崩溃恢复时的检查点</li>
<li>Web服务器容器提供鞥数据时，保存内容管理器容器提取的文件<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Q:hostPath是什么？<ul>
<li>hostPath卷将主机节点的文件系统中的文件或目录挂载到集群中</li>
<li>hostPath的用途：<ul>
<li>运行需要访问Docker内部的容器；使用/var/lib/docker的hostPath</li>
<li>在容器中运行cAdvisor；使用/dev/cgroups的hostPath</li>
<li>允许pod指定给定的hostPath是否应该在pod运行之前存在，是否应该创建，以及它应该以什么形式存在</li>
</ul>
</li>
<li>除了所需的path，用户还可以为hostPath卷指定type</li>
<li><img src="https://img.shiqi-lu.tech/20201028153031.png"></li>
<li>使用这种卷类型时请注意，因为<ul>
<li>由于每个节点上的文件都不同，具有相同配置(例如从podTemplate创建的)的pod在不同节点上的行为可能会有所不同</li>
<li>当k8s按照计划添加资源感知调度时，将无法考虑hostPath使用的资源</li>
<li>在底层主机上创建的文件或目录只能由root写入。所以需要在特权容器中以root身份运行进程，或修改主机上的文件权限以便写入hostPath卷<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">    <span class="comment"># directory location on host</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">    <span class="comment"># this field is optional</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Q:PV是什么？<ul>
<li>是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。PV是Volume之类的卷插件，但具有独立于使用PV的Pod的生命周期。此API对象包含存储实现的细节，即NFS、iSCSI或特定于云供应商的存储系统</li>
</ul>
</li>
<li>Q:PVC是什么？<ul>
<li>是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或只读多次模式挂载）</li>
</ul>
</li>
<li>Q:持久化卷声明(PVC)的保护<ul>
<li>PVC 保护的目的是确保由 pod 正在使用的 PVC 不会从系统中移除，因为如果被移除的话可能会导致数据丢失</li>
<li>当启用PVC 保护 alpha 功能时，如果用户删除了一个 pod 正在使用的 PVC，则该 PVC 不会被立即删除。PVC 的 删除将被推迟，直到 PVC 不再被任何 pod 使用</li>
</ul>
</li>
<li>Q:PV访问模式<ul>
<li>PersistentVolume 可以以资源提供者支持的任何方式挂载到主机上。如下表所示，供应商具有不同的功能，每个 PV 的访问模式都将被设置为该卷支持的特定模式。例如，NFS 可以支持多个读/写客户端，但特定的 NFS PV 可能 以只读方式导出到服务器上。每个 PV 都有一套自己的用来描述特定功能的访问模式<ul>
<li>ReadWriteOnce——该卷可以被单个节点以读/写模式挂载</li>
<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
<li>ReadWriteMany——该卷可以被多个节点以读/写模式挂载</li>
</ul>
</li>
<li>在命令行中，访问模式缩写为：<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
</li>
</ul>
</li>
<li>Q:PV的回收策略有哪些<ul>
<li>Retain（保留）——手动回收</li>
<li>Recycle（回收）——基本擦除（ rm -rf /thevolume/* ）</li>
<li>Delete（删除）——关联的存储资产（例如 AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder 卷） 将被删除</li>
<li>当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略</li>
</ul>
</li>
<li>Q:PV的状态<ul>
<li>卷可以处于以下的某种状态：</li>
<li>Available（可用）——一块空闲资源还没有被任何声明绑定</li>
<li>Bound（已绑定）——卷已经被声明绑定</li>
<li>Released（已释放）——声明被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）——该卷的自动回收失败</li>
<li>命令行会显示绑定到 PV 的 PVC 的名称</li>
</ul>
</li>
<li>Q:如何安装nfs服务器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-common nfs-utils rpcbind</span><br><span class="line">mkdir /nfsdata</span><br><span class="line">chmod 666 /nfsdata</span><br><span class="line">chown nfsnobody /nfsdata</span><br><span class="line">cat /etc/exports</span><br><span class="line">      /nfsdata *(rw,no_root_squash,no_all_squash,sync)</span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载</span></span><br><span class="line">showmount -e xxx.xxx.xxx.xxx</span><br><span class="line">mount -t nfs xxx.xxx.xxx.xxx:/nfs /test</span><br><span class="line">umount /test</span><br></pre></td></tr></table></figure></li>
<li>Q:部署PV<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfspv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">10.66</span><span class="number">.66</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pv.yaml</span><br><span class="line">kubectl get pv```</span><br><span class="line">- Q:创建服务并使用pvc</span><br><span class="line">    - ```yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  serviceName: &quot;nginx&quot;</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: wangyanglinux/myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class="line">      storageClassName: &quot;nfs&quot;</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据处理</title>
    <url>/mass-data-processing/</url>
    <content><![CDATA[<h1 id="散列分治"><a href="#散列分治" class="headerlink" title="散列分治"></a>散列分治</h1><ul>
<li>寻找Top IP：海量日志数据，提取出某日访问百度次数最多的那个IP<ul>
<li>1.分而治之：把该日访问百度的所有IP从日志中提取出来，逐个写入一个大文件中(这一步可以省略)。然后采取散列映射的方法(如hash(IP)%1024)，把海量IP日志分别存储到1024个小文件中，每个小文件最多包含4MB个IP地址</li>
<li>2.hash_map统计：对每个小文件，采用hash_map&lt;ip, 出现次数&gt;进行统计。找出每个小文件频率最高的IP，总共1024个IP</li>
<li>3.堆/快排：排序得到频率最高的IP</li>
</ul>
</li>
<li>寻找热门查询：搜索引擎会通过日志文件把用户每次检索所使用的所有查询串都记录下来，每个查询串的长度为1~255字节。假设目前有1000万条查询记录(但是，因为这些查询串的重复度比较高，所以虽然总数是1000万，但如果除去重复后，查询串query不超过300万个)，请统计其中最热门的10个查询串，要求使用的内存不能超过1 GB<ul>
<li>虽然有1000万个查询，但是因为重复度比较高，去除重复后，事实上只有300万个查询，每个查询为255字节，所以可以考虑把它们全部放进内存中去(假设300万个字符串没有重复，都是最大长度，那么最多占用内存300000 x 255 = 765MB = 0.765GB, 所以可以将所有字符串都存放在内存中进行处理)。</li>
<li>1.hash_ map统计。对这批海量数据进行预处理，用hash_map完成频率统计。在O(n)的时间复杂度内完成了所有query的频率统计</li>
<li>2.堆排序。借助堆找出Top k, 时间复杂度为0(nlogk)。维护k个元素的最小堆</li>
<li>也可用trie树</li>
</ul>
</li>
<li>堆排找topK过程<ul>
<li>维护k个元素的最小堆， 即用容量为k的最小堆存储最先遍历到的k个数，并假设它们就是最大的k个数， 建堆费时O(k)，有k1&gt;k2&gt;..&gt; kmin (设kmin为最小堆中最小元素)。继续遍历整个数列剩下的n-k个元素，每次遍历一个元素x将其与堆项元素进行比较，若x &gt; kmin 则更新堆，每次调整堆费时0(log k)，否则不更新堆。这样下来，总费时 O(k + (n- k) logk )= O(nlogk)。此方法得益于在堆中查找等各项操作的时间复杂度均为O(logk)</li>
</ul>
</li>
<li>寻找Top 10：有海量数据分布在100台电脑中，请想个办法高效统计出这批数据出现次数最多的Top 10<ul>
<li>如果同一个数据元素只出现在某一台机器中<ul>
<li>1.堆排：每台电脑求Top10，然后扫描后面的元素，得到最终topK</li>
<li>2.组合归并：每台电脑求Top10，然后组合100台电脑上数据的1000个数据，再求topk</li>
</ul>
</li>
<li>如果同一个数据元素出现在不同机器中<ul>
<li>1.遍历所有数据，重新散列取模，回到上一个问题</li>
<li>2.暴力求解，直接统计所有元素，把同一元素再不同机器中出现次数相加，得到最终top10</li>
</ul>
</li>
</ul>
</li>
<li>查询串的重新排列：有10个文件，每个文件的大小是1 GB，每个文件的每一行存放的都是用户的查询串query，每个文件的query都可能重复。请按照query的频度排序<ul>
<li>解法一<ul>
<li>1.散列映射</li>
<li>2.hash_map统计</li>
<li>3.堆排、快排或归并，得到10个排好序的文件后，对这10个文件进行归并排序(内排和外排相结合)</li>
</ul>
</li>
<li>解法二：query总量有限时，可一次性加入内存，采用Trie树和hash_map直接统计，按照出现次数做快排、堆排、归并排序即可</li>
</ul>
</li>
<li>寻找共同的URL：给定a和b两个文件，各存放50亿个URL，每个URL占64字节，内存限制是4GB。请找出a和b文件中共同的URL<ul>
<li>可以估计出每个文件的大小为5000000000x 64=320 GB</li>
<li>1.散列映射：对a，b文件，分别散列映射成1000对小文件。处理完后相同URL都在对应的小文件中。求出1000对小文件中相同的URL即可</li>
<li>2.hash_set统计：把一个小文件的URL存储到hash_set中，然后遍历另一个小文件的URL判断是否存在</li>
</ul>
</li>
</ul>
<h1 id="多层划分"><a href="#多层划分" class="headerlink" title="多层划分"></a>多层划分</h1><ul>
<li>寻找不重复的数：在2.5亿个整数中找出不重复的整数的个数。注意，内存空间不足以容纳这2.5亿个整数<ul>
<li>1.整数个数为2^{32}，将这2^{32}个数划分为 2^8个区域(用一个文件代表一个区域)</li>
<li>2.不同的区域再利用位图进行统计</li>
</ul>
</li>
<li>寻找中位数：找出5亿个int型数的中位数<ul>
<li>1.将这5亿个int型数划分为2^{16}个区域</li>
<li>2.读取数据统计落到各个区域里的数的个数，根据统计结果就可以判断中位数落到哪个区域，并知道这个区域中的第几大数刚好是中位数</li>
<li>3.第二次扫描只统计落在这个区域中的那些数即可</li>
</ul>
</li>
</ul>
<h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1><ul>
<li>外排序介绍<ul>
<li>采用「排序-归并」策略在排序。在排序阶段，先读入能放在内存中的数据，将其排序后输出到一个临时文件，依次进行，将待排序数据组织为多个有序的临时文件，而后在归并阶段将这些临时文件组合成一个大的有序文件</li>
</ul>
</li>
<li>给10^7个数据的磁盘文件排序：给定一个文件，里面最多含有n个不重复的正整数( 也就是说可能含有少于n个不重复的正整数)，且其中每个数都小于等于n(n=10^7)。请输出一个按从小到大升序排列的包含所有输入整数的列表。假设最多有大约1 MB的内存空间可用，但磁盘空间足够。要求运行时间在5分钟以内，10 秒为最佳结果<ul>
<li>1.位图<ul>
<li>由于每个7位十进制整数表示一个小于1000万的整数，所以可以使用一个具有1000万个位的字符串来表示这个文件，当且仅当整数i在文件中存在时，字符串中的第i位置为1</li>
<li>能采用位图方案的原因<ul>
<li>输入数据限制在相对较小的范围内</li>
<li>数据没有重复</li>
<li>其中的每条记录都是单一的整数，没有任何其他与之关联的数据</li>
</ul>
</li>
</ul>
</li>
<li>2.多路归并<ul>
<li>先把整个大文件分为若干大小的几块，然后分别对每一块进行排序，最后完成整个过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><ul>
<li>电话号码统计：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数<ul>
<li>8位数字最多组成99 999 999个号码，大概需要99兆位，大概十几兆字节的内存即可</li>
</ul>
</li>
<li>2.5亿个整数的去重：在2.5亿个整数中找出不重复的整数。注意，内存不足以容纳这2.5亿个整数<ul>
<li>采用2位图(每个数分配2位，00表示不存在，01表示出现一次，10表示出现多次，11无意义)，共需内存2^32x2=1 GB内存，可以接受</li>
<li>扫描这2.5亿个整数，查看位图中相对应的位，如果是00就变为01,如果是01就变为10, 如果是10就保持不变。扫描完之后，查看位图，把对应位是01的整数输出即可</li>
<li>也可以先划分成小文件，然后在小文件中找出不重复的整数，并排序，最后归并， 归并的同时去除重复的数</li>
</ul>
</li>
<li>整数的快速查询：给定40亿个不重复的没排过序的unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这40亿个整数当中?<ul>
<li>可以用位图的方法，申请512 MB的内存，一个位代表一个unsigned int 型的值</li>
<li>读入40亿个数，设置相应的位</li>
<li>读入要查询的数，查看相应位是否为1, 如果为1表示存在，如果为0表示不存在</li>
</ul>
</li>
</ul>
<h1 id="布隆过滤器-Bloom-filter"><a href="#布隆过滤器-Bloom-filter" class="headerlink" title="布隆过滤器(Bloom filter)"></a>布隆过滤器(Bloom filter)</h1><ul>
<li>原理<ul>
<li>相当于位图的扩展，其结构是长度为n的位数组，初始化为全0。当一个元素被加入集合中时，通过k个散列函数将这个元素映射成一个位数组中的k个点，并将这k个点全部置为1</li>
<li>在检索一个元素是否在一个集合中时，只需看这个元素被映射成位阵列的k个点是不是都是1。如果这k个点中有任何一个点为0，则被检索元素在集合中一定不存在；如果这k个点都是1，则被检索元素很可能在集合中</li>
<li>但会有误判的可能</li>
</ul>
</li>
</ul>
<h1 id="simhash算法"><a href="#simhash算法" class="headerlink" title="simhash算法"></a>simhash算法</h1><ul>
<li>设计一个比较两篇文档相似度的算法<ul>
<li>一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离(比如计算它们之间的欧氏距离、汉明距离或者夹角余弦等)，从而通过距离的大小来判断两篇文章的相似度。该方案的缺点是海量数据计算量极大</li>
<li>simhash算法</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><pre><code>- 结构之法
- https://blog.csdn.net/v_JULY_v/article/details/6543438</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习项目清单</title>
    <url>/ml-checklist/</url>
    <content><![CDATA[<h1 id="1-框出问题并看整体"><a href="#1-框出问题并看整体" class="headerlink" title="1.框出问题并看整体"></a>1.框出问题并看整体</h1><ul>
<li>1.用业务术语定义目标。</li>
<li>2.你的解决方案将如何使用?</li>
<li>3.当前有什么解决方案/解决方法（如果有）?</li>
<li>4.你应该如何阐述这个问题（有监督/无监督，在线/离线等）？</li>
<li>5.应该如何衡量性能?</li>
<li>6.性能指标是否符合业务目标?</li>
<li>7.达到业务目标所需的最低性能是多少？</li>
<li>8.有没有一些相似的向题？你可以重用经验或工具吗？</li>
<li>9.有没有相关有经验的人？</li>
<li>10.你会如何手动解决问题？</li>
<li>11.列出你（或其他人）到目前为止所做的假设。</li>
<li>12.如果可能，请验证假设。</li>
</ul>
<h1 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h1><ul>
<li>注意：尽可能地自动化，以便你可以轻松地获取新数据</li>
<li>1.列出所需的数据以及你需要多少数据。</li>
<li>2.查找并记录可从何处获取该数据。</li>
<li>3.检查将占用多少空间。</li>
<li>4.检查法律义务，并在必要时获得授权。</li>
<li>5.获取访问授权。</li>
<li>6.创建一个工作空间（具有足够的存储空间）。</li>
<li>7.获取数据。</li>
<li>8.将数据转换为可以轻松操作的格式（无须更改数据本身）。</li>
<li>9.确保敏感信息被删除或受保护（例如匿名）。</li>
<li>10.检查数据的大小和类型（时间序列、样本、地理等）。</li>
<li>11.抽样一个测试集，将其放在一边，再也不要看它（无数据监听！）。</li>
</ul>
<h1 id="3-研究数据"><a href="#3-研究数据" class="headerlink" title="3.研究数据"></a>3.研究数据</h1><ul>
<li>注意：请尝试从现场专家那里获取有关这些步骤的见解。</li>
<li>1.创建数据副本来进行研究（必要时将其采样到可以管理的大小）。</li>
<li>2.创建Jupyter notebook以记录你的数据研究。</li>
<li>3.研究每个属性及其特征：<ul>
<li>名称</li>
<li>类型（分类、整数/浮点型、有界/无界、文本、结构化等）</li>
<li>缺失值的百分比</li>
<li>噪声和噪声类型（随机、异常值、舍入误差等）</li>
<li>任务的实用性</li>
<li>分布类型（高斯分布、均匀分布、对数分布等）</li>
</ul>
</li>
<li>4.对于有监督学习任务，请确定目标属性。</li>
<li>5.可视化数据。</li>
<li>6.研究属性之间的相关性。</li>
<li>7.研究如何手动解决问题。</li>
<li>8.确定你可能希望使用的转变。</li>
<li>9.确定有用的额外数据。</li>
<li>10.记录所学的知识。</li>
</ul>
<h1 id="4-准备数据"><a href="#4-准备数据" class="headerlink" title="4.准备数据"></a>4.准备数据</h1><ul>
<li>注意：<ul>
<li>在数据副本上工作（保持原始数据集完整）。</li>
<li>为你应用的所有数据转换编写函数，原因有5个：<ul>
<li>下次获取新的数据集时，你可以轻松准备数据。</li>
<li>可以在未来的项目中应用这些转换。</li>
<li>清理并准备测试集。</li>
<li>解决方案上线后清理并准备新的数据实例。</li>
<li>使你可以轻松地将准备选择视为超参数。</li>
</ul>
</li>
</ul>
</li>
<li>1.数据清理：<ul>
<li>修复或删除异常值（可选）。</li>
<li>填写缺失值（例如，零、均值、中位数）或删除其行（或列）。</li>
</ul>
</li>
<li>2.特征选择（可选）：<ul>
<li>删除没有为任务提供有用信息的属性。</li>
</ul>
</li>
<li>3.特征工程（如果适用）：<ul>
<li>离散化连续特征。</li>
<li>分解特征（例如分类、日期/时间等）。</li>
<li>添加有希望的特征转换(如 Iog(x)、sqrt(x）、$x^2$等）</li>
<li>将特征聚合为有希望的新特征。</li>
</ul>
</li>
<li>4.特征缩放：<ul>
<li>标准化或归一化特征。</li>
</ul>
</li>
</ul>
<h1 id="5-列出有前途的模型"><a href="#5-列出有前途的模型" class="headerlink" title="5.列出有前途的模型"></a>5.列出有前途的模型</h1><ul>
<li>注意：<ul>
<li>如果数据量巨大，则可能需要采样为较小的训练集，以便可以在合理的时间内训练许多不同的模型(请注意，这会对诸如大型神经网络或随机森林之类的复杂模型造成不利影响)</li>
<li>尽可能自动化地执行这些步骤</li>
</ul>
</li>
<li>1.使用标准参数训练来自不同类别（例如线性、朴素贝叶斯、SVM，随机森林、神经网络等）的许多快速和粗糙的模型。</li>
<li>2.衡量并比较其性能。</li>
<li>对于每个模型，使用N折交叉验证，在N折上计算性能度量的均值和标准差。</li>
<li>3.分析每种算法的最重要的变量。</li>
<li>4.分析模型所犯错误的类型。<ul>
<li>人类将使用什么数据来避免这些错误?</li>
</ul>
</li>
<li>5.快速进行特征选择和特征工程。</li>
<li>6.在前面5个步骤中执行一两个以上的快速迭代。</li>
<li>7.筛选出前三到五个最有希望的模型，优先选择会产生不同类型错误的模型。</li>
</ul>
<h1 id="6-微调系统"><a href="#6-微调系统" class="headerlink" title="6.微调系统"></a>6.微调系统</h1><ul>
<li>注意：<ul>
<li>你将需要在此步骤中使用尽可能多的数据，尤其是在微调结束时。</li>
<li>与往常一样，尽可能做到自动化。</li>
</ul>
</li>
<li>1.使用交叉验证微调超参数：<ul>
<li>将你的数据转换选择视为超参数，尤其是当你对它们不确定时（例如，如果不确定是否用零或中位数替换缺失值，或者只是删除行）。</li>
<li>除非要研究的超参数值很少，否则应优先选择随机搜索而不是网格搜索。如果训练时间很长，你可能更喜欢贝叶斯优化方法（如Jasper Snoek等人所述使用高斯过程先验）。</li>
</ul>
</li>
<li>2.尝试使用集成方法。组合最好的模型通常会比单独运行有更好的性能。</li>
<li>3.一旦对最终模型有信心，就可以在测试集中测量其性能，以估计泛化误差。</li>
<li>注意：在测量了泛化误差之后，请不要对模型进行调整：否则你会开始过拟合测试集。</li>
</ul>
<h1 id="7-演示你的解决方案"><a href="#7-演示你的解决方案" class="headerlink" title="7.演示你的解决方案"></a>7.演示你的解决方案</h1><ul>
<li>1.记录你所做的事情。</li>
<li>2.创建一个不错的演示文稿。<ul>
<li>确保先突出大的蓝图。</li>
</ul>
</li>
<li>3.说明你的解决方案为何可以实现业务目标。</li>
<li>4.别忘了介绍你一路上注意到的有趣观点。<ul>
<li>描述什么有效，什么无效。</li>
<li>列出你的假设和系统的局限性。</li>
</ul>
</li>
<li>5.确保通过精美的可视化效果或易于记忆的陈述来传达你的主要发现（例如，“中等收入是房价的第一大预测指标”）。</li>
</ul>
<h1 id="8-启动！"><a href="#8-启动！" class="headerlink" title="8.启动！"></a>8.启动！</h1><ul>
<li>1.使你的解决方案准备投入生产环境（插入生产数据输入、编写单元测试等）。</li>
<li>2.编写监控代码，以定期检查系统的实时性能，并在系统故障时触发警报。<ul>
<li>当心缓慢的退化：随着数据的发展，模型往往会“腐烂”。</li>
<li>评估性能可能需要人工流水线（例如通过众包服务）。</li>
<li>监视你的输入的质量（例如，传感器出现故障，发送了随机值，或者另一个团队的输出变得过时)。这对于在线学习系统尤其重要。</li>
</ul>
</li>
<li>3.定期根据新数据重新训练模型（尽可能自动进行）。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《左手MongoDB，右手Redis》第3章 MongoDB快速入门</title>
    <url>/mongodb-redis3/</url>
    <content><![CDATA[<ul>
<li>3.4 MongoDB的基本操作<ul>
<li>创建数据库与集合<ul>
<li>创建数据库：Robo 3T中，右键小电脑选择“Create Database”</li>
<li>创建集合：在新创建的数据库里，右键“Collections”，选择”Create Collection”</li>
</ul>
</li>
<li>插入单条数据<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).insertOne(&#123;&quot;name&quot;:&quot;张小三&quot;, &quot;age&quot;:18, &quot;address&quot;:&quot;上海&quot;&#125;)</code></li>
<li>使用cmd+r运行</li>
</ul>
</li>
<li>批量插入数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#x27;example_data_1&#x27;).insertMany([</span><br><span class="line">    &#123;&quot;name&quot;:&quot;kk&quot;, &quot;age&quot;:20&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;ll&quot;, &quot;age&quot;:21&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
<li>查询所有数据<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#125;)</code></li>
<li><code>db.getCollection(&#39;example_data_1&#39;).find()</code></li>
</ul>
</li>
<li>查询特定数据<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#39;字段1&#39;:&#39;值1&#39;, &#39;字段2&#39;:&#39;值2&#39;&#125;)</code></li>
</ul>
</li>
<li>查询范围值数据<ul>
<li>查询’age’字段不小于25的记录<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 25&#125;&#125;)</code></li>
</ul>
</li>
<li>各个操作符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">大于：$gt</span><br><span class="line">大于等于：$gte</span><br><span class="line">小于：$lt</span><br><span class="line">小于等于：$lte</span><br><span class="line">不等于：$ne</span><br></pre></td></tr></table></figure></li>
<li>查询’age’大于21并小于等于24的数据<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#39;age&#39;: &#123;&#39;$lte&#39;: 24, &#39;$gt&#39;: 21&#125;&#125;)</code></li>
</ul>
</li>
</ul>
</li>
<li>限定返回哪些字段<ul>
<li>find命令第1个参数用于过滤不同的记录，第2个参数用于修改返回的字段。如果省略第2个参数，则会返回所有字段</li>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(用于过滤记录的字典, 用于限定字段的字典)</code></li>
<li>限定字段的字典的Key为各个字段名，其值只有两个0或1<ul>
<li>0表示在全部字段中剔除值为0的这些字段返回</li>
<li>1表示只返回值为1的这些字段</li>
</ul>
</li>
<li>查询数据集，但不返回address和age字段<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#125;, &#123;&#39;address&#39;:0, &#39;age&#39;:0&#125;)</code></li>
</ul>
</li>
<li>查询数据集，只返回address和age字段<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#125;, &#123;&#39;address&#39;:1, &#39;age&#39;:1&#125;)</code></li>
</ul>
</li>
</ul>
</li>
<li>查询满足结果的数据集的条数<ul>
<li>查询’age’字段不小于25的记录的条数<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 25&#125;&#125;).count()</code></li>
</ul>
</li>
</ul>
</li>
<li>返回限定的条数<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find().limit(限制返回的条数)</code></li>
</ul>
</li>
<li>对查询结果进行排序<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).find(&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 25&#125;&#125;).sort(&#123;&#39;字段名&#39;: -1或1&#125;)</code></li>
<li>其中-1表示倒序，1表示正序</li>
</ul>
</li>
<li>修改数据updateOne()和updateMany()<ul>
<li><code>sql db.getCollection(&#39;example_data_1&#39;).updateMany( 参数1：查询语句的第一个字典， &#123;&#39;$set&#39;: &#123;&#39;字段1&#39;: &#39;新的值1&#39;, &#39;字段2&#39;: &#39;新的值2&#39;&#125;&#125; )</code></li>
</ul>
</li>
<li>删除数据<ul>
<li>只需把find改成deleteOne或deleteMany即可，对应删除第1条数据和所有满足要求的数据</li>
</ul>
</li>
<li>数据去重<ul>
<li><code>db.getCollection(&#39;example_data_1&#39;).distinct(&#39;字段名&#39;, 查询语句的第一个字典)</code></li>
</ul>
</li>
</ul>
</li>
<li>3.5 使用Python操作MongoDB<ul>
<li>安装<ul>
<li><code>pip install pymongo</code></li>
</ul>
</li>
<li>连接数据库<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = MongoClient(<span class="string">&#x27;mongodb://192.168.1.53:27017&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>database = client.chapter_3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection = database.example_data_1</span><br></pre></td></tr></table></figure></li>
<li>MongoDB与PyMongo的对比<ul>
<li>把MongoDB的驼峰命名转化为PyMongo的小写加下划线即可</li>
</ul>
</li>
<li>插入数据insert_one和insert_many<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection.insert_many([</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;new_new&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;old_old&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">31</span>&#125;</span><br><span class="line"><span class="meta">... </span>])</span><br></pre></td></tr></table></figure></li>
<li>查询数据find<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$lt&#x27;</span>: <span class="number">30</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line"><span class="meta">... </span>    print(row)</span><br></pre></td></tr></table></figure></li>
<li>更新数据<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection.update_many(</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kk&#x27;</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">44</span>&#125;&#125;</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure></li>
<li>更新或插入数据<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection.update_many(</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kk&#x27;</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">44</span>&#125;&#125;,</span><br><span class="line"><span class="meta">... </span>    upsert=<span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure></li>
<li>删除数据<ul>
<li><code>collection.delete_many(&#123;&#39;age&#39;:0&#125;)</code></li>
</ul>
</li>
</ul>
</li>
<li>3.6 MongoDB与Python不通用的操作<ul>
<li>1.空值<ul>
<li>MongoDB中写作null，Python中写作None</li>
</ul>
</li>
<li>2.布尔值<ul>
<li>MongoDB中真为true，假为false</li>
<li>Python中真为True，假为False</li>
</ul>
</li>
<li>3.排序参数<ul>
<li>MongoDB: .sort({‘age’: -1})</li>
<li>Python: .sort(‘age’, -1)</li>
</ul>
</li>
<li>4.查询_id<ul>
<li>MongoDB<ul>
<li><code>db.getCollection(&#39;example_data_2&#39;).find(&#123;&#39;_id&#39;: ObjectId(&#39;mxmmmmm&#39;)&#125;)</code></li>
</ul>
</li>
<li>Python<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bson <span class="keyword">import</span> ObjectId</span><br><span class="line">collection.find(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;mxmmmmm&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>《左手MongoDB，右手Redis》第5章 Redis快速入门</title>
    <url>/mongodb-redis5/</url>
    <content><![CDATA[<ul>
<li>5.1 安装Redis<ul>
<li>macOS安装<ul>
<li>使用Homebrew：<code>brew install redis</code></li>
<li>启动Redis：<code>redis-server /usr/local/etc/redis.conf</code></li>
</ul>
</li>
<li>在线测试环境：<a href="http://try.redis.io/">http://try.redis.io</a></li>
</ul>
</li>
<li>5.2 字符串的创建、查询和修改<ul>
<li>查看当前有哪些Key<ul>
<li><code>keys *</code></li>
</ul>
</li>
<li>创建字符串<ul>
<li>格式：<code>set key value</code></li>
</ul>
</li>
<li>读取字符串<ul>
<li><code>get key</code></li>
</ul>
</li>
<li>修改Key值<ul>
<li><code>set key 新值</code></li>
</ul>
</li>
<li>修改Key值，但不覆盖旧值<ul>
<li><code>set key value NX</code></li>
</ul>
</li>
<li>给字符串末尾加上其它字符串<ul>
<li><code>append key value</code></li>
</ul>
</li>
<li>注意，若有空格的话，需要使用双引号</li>
<li>让Key的数字增加1<ul>
<li><code>incr key</code></li>
</ul>
</li>
<li>让Key的数字减少1<ul>
<li><code>decr key</code></li>
</ul>
</li>
<li>让key的数字增加n<ul>
<li><code>incrby key n</code></li>
</ul>
</li>
<li>让key的数字减少n<ul>
<li><code>decrby key n</code></li>
</ul>
</li>
<li>在python中列出所有key<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = redis.Redis(host=<span class="string">&#x27;192.168.1.53&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(client.keys())</span><br><span class="line">[<span class="string">b&#x27;give&#x27;</span>, <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> client.keys():</span><br><span class="line"><span class="meta">... </span>    print(key.decode())</span><br><span class="line">...</span><br><span class="line">give</span><br><span class="line">中文</span><br></pre></td></tr></table></figure></li>
<li>python创建字符串<ul>
<li><code>client.set(&#39;key&#39;, &#39;value&#39;)</code></li>
</ul>
</li>
<li>python获取字符串<ul>
<li><code>client.get(&#39;key&#39;)</code></li>
</ul>
</li>
<li>python修改key值，但不覆盖旧值<ul>
<li><code>client.set(&#39;key&#39;, &#39;value&#39;, nx=True)</code></li>
</ul>
</li>
<li>python对字符串增加和减小数值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client.incr(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">client.incr(<span class="string">&#x27;key&#x27;</span>, n)</span><br><span class="line">client.decr(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">client.decr(<span class="string">&#x27;key&#x27;</span>, n)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>5.3 列表的创建、查询和修改<ul>
<li>向列表插入数据的命令：<ul>
<li>从左侧插入：<code>lpush key value1 value2 value3</code></li>
<li>从右侧插入：<code>rpush key value1 value2 value3</code></li>
</ul>
</li>
<li>查看列表长度<ul>
<li><code>llen key</code></li>
</ul>
</li>
<li>根据索引查看数据<ul>
<li>格式：<code>lrange 0 开始索引 结束索引</code></li>
<li>查看索引为6的数据：<code>lrange elist 6 6</code></li>
<li>查看索引从2到5(闭区间)的数据：<code>lrange elist 2 5</code></li>
<li>查看所有数据：<code>lrange key 0 -1</code></li>
<li>查看右边的5条数据：<code>lrange key -5 -1</code></li>
</ul>
</li>
<li>弹出列表数据<ul>
<li>左边弹出：<code>lpop key</code></li>
<li>右边弹出：<code>rpop key</code></li>
</ul>
</li>
<li>根据数据列表索引修改数据<ul>
<li><code>lset key index 新值</code></li>
</ul>
</li>
<li>python插入列表数据<ul>
<li><code>client.lpush(&#39;key&#39;, &#39;value&#39;)</code></li>
<li><code>client.rpush(&#39;key&#39;, &#39;value1&#39;, &#39;value2&#39;)</code></li>
</ul>
</li>
<li>python查看列表长度<ul>
<li><code>client.llen(key)</code></li>
</ul>
</li>
<li>python获取列表索引范围内的数据<ul>
<li><code>client.lrange(key, 开始索引, 结束索引)</code></li>
</ul>
</li>
<li>python从列表左右侧弹出数据<ul>
<li><code>client.lpop(key)</code></li>
<li><code>client.rpop(key)</code></li>
</ul>
</li>
<li>python修改列表数据<ul>
<li><code>client.lset(key, index, value)</code></li>
</ul>
</li>
</ul>
</li>
<li>5.4 集合的创建和修改<ul>
<li>插入集合数据<ul>
<li><code>sadd key value1 value2 value3</code></li>
</ul>
</li>
<li>读取集合数据长度<ul>
<li><code>scard key</code></li>
</ul>
</li>
<li>从集合中随机获取数据，并删除改数据<ul>
<li><code>spop key count</code></li>
<li>若count省略，随机获取1条数据</li>
</ul>
</li>
<li>获取集合所有数据<ul>
<li><code>smembers key</code></li>
</ul>
</li>
<li>判断集合中是否包含某个数据<ul>
<li><code>sismember key value</code></li>
<li>如果数据存在返回1，不存在返回0</li>
</ul>
</li>
<li>删除集合数据<ul>
<li><code>srem key value1 value2 value3</code></li>
</ul>
</li>
<li>求集合的交集<ul>
<li><code>sinter key1 key2 key3</code></li>
</ul>
</li>
<li>求集合的并集<ul>
<li><code>sunion key1 key2 key3</code></li>
</ul>
</li>
<li>求集合的差集<ul>
<li><code>sdiff key1 key2 key3</code></li>
</ul>
</li>
<li>python插入集合数据<ul>
<li><code>client.sadd(&#39;key&#39;, &#39;value1&#39;, &#39;value2&#39;)</code></li>
</ul>
</li>
<li>python读取集合长度<ul>
<li><code>client.scard(&#39;key&#39;)</code></li>
</ul>
</li>
<li>python弹出集合数据<ul>
<li><code>client.spop(&#39;key&#39;)</code></li>
<li>注意这里没有count参数，一次只能获取一条数据</li>
</ul>
</li>
<li>python获取集合全部数据<ul>
<li><code>client.smembers(&#39;key&#39;)</code></li>
</ul>
</li>
<li>python删除集合数据<ul>
<li><code>client.srem(&#39;key&#39;)</code></li>
</ul>
</li>
<li>python集合的交集<ul>
<li><code>client.sinter(&#39;key1&#39;, &#39;key2&#39;)</code></li>
</ul>
</li>
<li>python集合的并集<ul>
<li><code>client.sunion(&#39;key1&#39;, &#39;key2&#39;)</code></li>
</ul>
</li>
<li>python集合的差集<ul>
<li><code>client.sdiff(&#39;key1&#39;, &#39;key2&#39;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>我的leetcode刷题方法</title>
    <url>/my-leetcode-method/</url>
    <content><![CDATA[<ul>
<li>最小闭环：学习、思考、记录、复习<ul>
<li>新题先思考，旧题默念各种解法，尝试做一下，注意要计时做</li>
<li>研究题解并简要记录题目和关键解法和关键代码，要调整到最适合自己理解和记住的最优代码和思路</li>
<li>把题解在对应板块进行汇总</li>
<li>总结完必须再提交一次所有搞懂的题解，计时，熟练度必须达到🐎，掌握必须达到🆗或🆒</li>
<li>有创新和小改动的，发表题解</li>
<li>粘贴到笔记本中，导出anki</li>
<li>anki复习即可</li>
</ul>
</li>
<li>标题记录掌握程度和熟练程度，同时metadata里面添加每一次的做题日期、做题时长、整理后做题时长<ul>
<li>熟练程度：至少隔一周且未看题解前评估，看完题解后，必须能达到🐎<ul>
<li>🐢表示勉强的很卡顿的写出来</li>
<li>🐇表示需要略思考其中几个点略卡顿写出来，E10，M15，H20</li>
<li>🐎表示非常纯熟能一气呵成写出来，E5，M10，H15</li>
<li>整理后必须达到E3，M5，H8内，且整理后写题必须按照思路写而不是背，并把每个语句和每个变量的意义都能说出来</li>
</ul>
</li>
<li>掌握程度<ul>
<li>💯表示能不看题解的情况下，隔了一段时间没做，仍能分析并写出最优解(或已学会的最优解)</li>
<li>🆒表示整理并背诵完毕，一题多解均能说并写出来(包括暴力和最优等)，并能分析时间/空间复杂度</li>
<li>🆗(仅在有多种解题方法使用)表示整理并背诵其中的一种题解思路，能说并写出来和分析时间复杂度，但不能理解并写出所有解法</li>
<li>🆕表示能在看完题解的情况下，默写/仿写出来其中的一种解法，此时未整理</li>
<li>🆖表示看着题解写出来了，但仍不理解题解的意思，有很多模糊的地方</li>
<li>🤨存在有一个解法学不懂，或者不必要去学</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《OFF学》读书笔记</title>
    <url>/off-time/</url>
    <content><![CDATA[<ul>
<li>metadata<ul>
<li>来源<ul>
<li><a href="https://book.douban.com/subject/2142034/">OFF学 : 会玩，才会成功douban6.9</a></li>
</ul>
</li>
</ul>
</li>
<li>导言<ul>
<li>年初制定休闲生活的年度计划<ul>
<li>1.制定一年三次的长期休假计划</li>
<li>2.以月为单位，决定周末的休闲生活</li>
<li>3.身体的疗养与休息等的时间安排也要制定计划</li>
</ul>
</li>
<li>与其多次反复浅尝辄止，不如少次充分享受，是充实休闲生活的秘诀之一</li>
<li>为了丰富多彩的人生，有必要对于自己的时间和资金进行适当配</li>
</ul>
</li>
<li>第1章 享受兴趣，从现在开始<ul>
<li>海洋休闲方式知多少<ul>
<li>有了享受休闲生活的渴望，人们才能真正体会到休闲的乐趣</li>
</ul>
</li>
<li>不要打自费又不快乐的高尔夫<ul>
<li>充分享受休闲生活法则<ul>
<li>1.休闲生活都是自费的享受</li>
<li>2.到真正的休闲地点去享受</li>
</ul>
</li>
<li>一生能够尽情享受休闲生活的次数毕竟是有限的。既然如此，为什么不去真正一流的地点，尽情品味休闲的真味呢？</li>
</ul>
</li>
<li>从享受音乐开始，培养一生的兴趣<ul>
<li>深度享受兴趣的关键是通过亲自参与，享受乐趣</li>
<li>记录兴趣日记，持续简短地记录，是保持和提高兴趣的秘诀</li>
<li>在一个领域中，不断地产生想知道的事、想做的事，是形成兴趣的秘诀</li>
<li>自己演奏乐器的乐趣，远大于只是聆听音乐的乐趣</li>
<li>结识共同的兴趣伙伴</li>
</ul>
</li>
<li>以老当益壮的精神挑战体育活动<ul>
<li>盛田昭夫常说，“绝对不能变成老年人”。这样的精神是保持年轻的秘诀</li>
<li>“做做看吧”，想象着自己要退休，现在马上开始吧！在退休之前就开始行动，以“想去加拿大好好地享受化学乐趣”、“想去夏威夷悠闲第享受冲浪乐趣”等具体的梦想为目标，不断地练习，退休之后才能实现自己的目标</li>
</ul>
</li>
<li>购物，购买“标准物品”足矣：合用的、高品质的物品<ul>
<li>1.因为符合自己的需求，而不会产生不便</li>
<li>2.因为只需重复购买相同的物品，所以不会有购物的烦恼及时间的浪费</li>
</ul>
</li>
<li>把时间花在真正感兴趣的事物上<ul>
<li>不管是只有工作的人生，还是只有家庭的人生，都是很无趣的。建议每个人都应该拥有属于自己一个人的休闲项目</li>
<li>坚持一项活动并且用心追求，将会减少无所事事的时间浪费</li>
</ul>
</li>
</ul>
</li>
<li>第2章 击退“忧郁的星期一”<ul>
<li>在“浮华之日”(每两三周一次的放松之日)，让身心彻底放松<ul>
<li>这个日子是为了经常被忽略的非工作性活动而设。事前的安排让你“不得不”享受浮华之日，而且，“今天是浮华之日，所以要彻底放松”的想法，能让自己真正地放松身心</li>
</ul>
</li>
<li>周末悠闲放松，周一从容不迫<ul>
<li>河边散步的4个魅力<ul>
<li>1.除了交通费外没有额外开销</li>
<li>2.没有压力，无需特别的行程计划</li>
<li>3.开放感，没有空间的限制</li>
<li>4.丰富家人之间的交流</li>
</ul>
</li>
</ul>
</li>
<li>购置第二住宅，享受假期</li>
<li>假期跟家人同游，享受美食<ul>
<li>三个方式<ul>
<li>1.联络感情</li>
<li>2.攻占人气餐厅</li>
<li>3.假日的美食之旅</li>
</ul>
</li>
</ul>
</li>
<li>周末的时间分配术<ul>
<li>从周五晚开始周末的休闲活动</li>
<li>周六享受体力型的休闲活动，周日让身心充分休息</li>
<li>周日的晚餐后，开始为周一的工作做准备：确认未来的时间安排，构思会议的提议和发言</li>
</ul>
</li>
<li>增加休闲时间的三种方法<ul>
<li>“我再给你打电话”是浪费时间</li>
<li>为一个议案，准备三种提案</li>
<li>上班之前完成杂物，提升工作效率</li>
</ul>
</li>
<li>高效阅读的秘诀</li>
<li>有效利用个人时间的书房活用术<ul>
<li>1.将个人时间列入计划，并且形成习惯</li>
<li>2.将休息的空间与思考的空间分开使用</li>
<li>3.营造可以集中精力进行思考的场所，并且将它标准化</li>
</ul>
</li>
<li>拓展人际关系，结交工作以外的朋友</li>
<li>摆脱“工作时钟”，击退压力</li>
</ul>
</li>
<li>第3章 出去旅游<ul>
<li>通过“网络观光”制订旅游计划<ul>
<li>造访曾经去过的观光景点以及感兴趣的地点</li>
<li>造访曾经去过的海外观光景点以及感兴趣的地点<ul>
<li>美国宇航局探险宇宙：<a href="http://www.nasa.gov/">www.nasa.gov</a></li>
</ul>
</li>
</ul>
</li>
<li>充分享受国内旅游的乐趣<ul>
<li>制订“定点型”旅游计划<ul>
<li>国内旅游再次拜访的可能性大，如果走马观花地游览所有景点，只会造成没有意义的旅游疲惫</li>
</ul>
</li>
<li>尝试自由随兴的自助游</li>
<li>不购买“旅游特产”</li>
</ul>
</li>
<li>避免“休闲疲惫”的法则<ul>
<li>如果能遵循“人多的地方不要去”和“在开放的空间享受休闲生活”两个原则，就可以轻松地创造愉快的小旅行</li>
</ul>
</li>
<li>带父母同游，尽孝从现在做起</li>
</ul>
</li>
<li>第4章 休闲时间的IT活用术<ul>
<li>活用电脑拓展兴趣，结交新朋友</li>
<li>将医疗网站变成“家庭医生”<ul>
<li>掌握自身疾病的信息</li>
<li>寻求第二意见</li>
<li>身体不舒服一定要立刻休息</li>
</ul>
</li>
<li>数码相机是拓展对话的工具</li>
<li>在雨天的假日，利用电脑整理“自己的过去”</li>
<li>利用网络拍卖聪明购物</li>
</ul>
</li>
<li>第5章 喝酒的场所与乐趣<ul>
<li>下午5点后的灯红酒绿是人生的浪费<ul>
<li>4个缺点<ul>
<li>1.下班后还与公司的人在一起，话题将只限于工作范围，容易累积工作压力，这样的聚会就像加班一样</li>
<li>2.即使诉说工作的不满与烦恼，由于参与的人通常都是相同层级的人，往往也无法解决问题。结果，除了互相抱怨外，无法提出任何解决问题的意见和方法</li>
<li>3.失去与家人相处的时间</li>
<li>4.原本应该休息的时间却用来喝酒聊天，不仅加深疲惫，也会造成睡眠不足，影响第二天的工作</li>
</ul>
</li>
<li>可提倡活力早餐和午餐，优点<ul>
<li>1.没有喝酒，能彼此冷静又有建设性地谈话</li>
<li>2.确保下班以后的时间，自己可以享受兴趣或学习</li>
<li>3.如果有重要的议程，当天下午就可以马上行动</li>
</ul>
</li>
</ul>
</li>
<li>以在酒吧喝酒的方式与工作以外的人开怀畅饮</li>
<li>选择美食餐厅的三项法则<ul>
<li>可整理一个餐厅候选名单</li>
<li>信息整理术：按照不同价位选择餐厅</li>
<li>餐厅的选择方法：确认午餐的味道</li>
<li>菜品的选择方法：请餐厅人员推荐</li>
</ul>
</li>
<li>拥有两家熟悉的餐厅</li>
<li>外籍女服务员是最好的信息源</li>
</ul>
</li>
<li>第6章 家庭管理术<ul>
<li>周四晚上进行家庭定期检查<ul>
<li>家庭内部问题</li>
<li>家庭外部的烦恼</li>
<li>安排一周时间的举例<ul>
<li>周末假日，身心得到了充分的休息，</li>
<li>周一晚可安排财务、IT、英语等商务能力的学习计划</li>
<li>周二晚可参与义工活动</li>
<li>若一定要加班，可安排在周三晚，因为到周三为止，身心还不会太疲惫</li>
<li>周四则是做家庭定期检查的时间</li>
<li>周五晚可以享受比较轻松的休闲活动，如读书、听音乐、看电影、看球赛等。如此从周五晚起可完全沉浸在周末假日的气氛中。偶尔也可喝一点酒</li>
</ul>
</li>
<li>安排的优点<ul>
<li>1.按照自己的想法，主动地使用自己的时间</li>
<li>2.每天都安排不同的计划，一周的生活会充满变化</li>
<li>3.如果有计划，下班的理由与实际会比较明确，工作也会很快完成</li>
<li>4.当同事邀约喝酒时，是否赴约的判断会比较明确</li>
<li>5.周末的时间可充分地用在个人的兴趣以及全家人的旅游上，并且达到真正身心放松的目的</li>
</ul>
</li>
</ul>
</li>
<li>家庭融洽的秘诀<ul>
<li>安排每周一次家人聚会的日子</li>
</ul>
</li>
<li>撤除孩子的房间，确保父亲的活动空间</li>
<li>边看电视边吃饭是家庭融洽的最大杀手</li>
<li>好好庆祝家庭纪念日</li>
<li>让家人尝尝爸爸的菜</li>
<li>夫妻有各自的空间，也有共同的话题</li>
<li>将长期外派转化为增进家人感情的机会<ul>
<li>筹划家人共同参与的项目</li>
<li>分享计划</li>
<li>活用网络空间</li>
</ul>
</li>
<li>给太太自由和权限，远离中年离婚</li>
<li>管理“家庭团队”</li>
</ul>
</li>
<li>第7章 家庭育儿术<ul>
<li>利用“丛林法则”，让孩子在体验中成长</li>
<li>只跟同年级学生玩耍的孩子很难成长</li>
<li>并肩谈话胜于面对面交流</li>
<li>善用寄宿学校与“寄宿家庭”</li>
<li>称为孩子的“协助者”，而非“教导者”</li>
<li>让孩子统筹家庭活动，锻炼孩子的领导能力</li>
<li>从取消零用钱开始，对孩子进行金钱教育</li>
<li>考试失败、被人欺负——解救陷入困境的孩子</li>
</ul>
</li>
<li>第8章 从现在起，为退休后的生活做准备<ul>
<li>选择终身兴趣的三项法则<ul>
<li>1.如果超过40岁，要拥有退休之后可以持续的兴趣</li>
<li>2.跟不同年龄层的朋友一起享受兴趣</li>
<li>3.选择有表现机会的兴趣</li>
</ul>
</li>
<li>理性投资，为退休生活积累财富</li>
<li>参加社会公益活动，回报社会</li>
<li>老年的海外移居计划</li>
<li>退休后另外购置居所，享受天堂般的生活</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch学习笔记</title>
    <url>/pytorch-learning/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这个目录是从深度之眼的pytorch课程中学习并整理的学习笔记</p>
<ul>
<li><a href="https://ai.deepshare.net/detail/p_5df0ad9a09d37_qYqVmt85/6">课程页面入口</a></li>
<li><a href="https://github.com/JansonYuan/Pytorch-Camp">课程代码github</a></li>
<li><a href="https://github.com/greebear/pytorch-learning">作业讲解代码</a></li>
<li>课程所有代码汇总中配套数据百度网盘地址：<a href="https://pan.baidu.com/s/1mA8wSCLnKphByzvHBzc9Pw">https://pan.baidu.com/s/1mA8wSCLnKphByzvHBzc9Pw</a><br>提取码：g5ym</li>
<li>课程所有课件汇总百度网盘地址：<a href="https://pan.baidu.com/s/1svt3lbDgNGixk5lKM1zfig">https://pan.baidu.com/s/1svt3lbDgNGixk5lKM1zfig</a><br>提取码：9j2f</li>
</ul>
<h1 id="目录笔记"><a href="#目录笔记" class="headerlink" title="目录笔记"></a>目录笔记</h1><p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week1.ipynb">Week1 Pytorch基础概念</a></p>
<ul>
<li>Pytorch简介及环境配置</li>
<li>Pytorch基础数据结构——张量</li>
<li>张量操作与线性回归</li>
<li>计算图与动态图机制</li>
<li>autograd与逻辑回归</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week2.ipynb">Week2 PyTorch数据处理</a></p>
<ul>
<li>数据读取机制DataLoader与Dataset</li>
<li>数据预处理transforms模块机制</li>
<li>二十二种transforms数据预处理方法</li>
<li>学会自定义transforms方法</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week3.ipynb">Week3 PyTorch模型搭建</a></p>
<ul>
<li>nn.Module与网络模型构建步骤</li>
<li>模型容器与AlexNet构建</li>
<li>网络层中的卷积层</li>
<li>网络层中的池化层、全连接层和激活函数层</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week4.ipynb">Week4 PyTorch损失优化</a></p>
<ul>
<li>权值初始化</li>
<li>损失函数（一）</li>
<li>Pytorch的14种损失函数</li>
<li>优化器optimizer的概念</li>
<li>torch.optim.SGD</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week5.ipynb">Week5 PyTorch训练过程</a></p>
<ul>
<li>学习率调整</li>
<li>TensorBoard简介与安装</li>
<li>TensorBoard使用（一）</li>
<li>TensorBoard使用（二）</li>
<li>hook函数与CAM</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week6.ipynb">Week6 PyTorch的正则化</a></p>
<ul>
<li>weight_decay</li>
<li>dropout</li>
<li>Batch Normalization</li>
<li>Layer Normalization、Instance</li>
<li>Normalization和Group Normalization</li>
</ul>
<p><a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week7.ipynb">Week7 PyTorch训练技巧</a></p>
<ul>
<li>模型保存与加载</li>
<li>Finetune</li>
<li>GPU的使用</li>
<li>Pytorch中常见报错</li>
</ul>
<p>Week8、9 PyTorch深度体验</p>
<ul>
<li>图像分类一瞥</li>
<li>图像分割一瞥</li>
<li>目标检测一瞥（上）</li>
<li>目标检测一瞥（下）</li>
<li>对抗生成网络一瞥</li>
<li>循环神经网络一瞥</li>
</ul>
]]></content>
      <categories>
        <category>pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《Redis核心技术与实战》基础篇2-5</title>
    <url>/redis-gt-1/</url>
    <content><![CDATA[<h1 id="02丨数据结构：快速的Redis有哪些慢操作？"><a href="#02丨数据结构：快速的Redis有哪些慢操作？" class="headerlink" title="02丨数据结构：快速的Redis有哪些慢操作？"></a>02丨数据结构：快速的Redis有哪些慢操作？</h1><ul>
<li>Q:Redis的数据类型分别对应底层哪些数据结构？<ul>
<li>String：简单动态字符串</li>
<li>List：压缩列表、双向链表</li>
<li>Hash：压缩列表、哈希表</li>
<li>Set：整数数组、哈希表</li>
<li>Sorted Set：压缩列表、跳表</li>
<li><img src="https://img.shiqi-lu.tech/20210507163031.png?imageView2/2/w/300"></li>
<li><img src="https://img.shiqi-lu.tech/20210130161930.png"></li>
</ul>
</li>
<li>Q:Redis的键和值使用什么结构组织？<ul>
<li>使用一个全局哈希表，其实是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据</li>
<li>哈希桶中的 entry 元素中保存了 *key 和 *value 指针，分别指向了实际的键和值</li>
<li><img src="https://img.shiqi-lu.tech/20210507113941.png"></li>
</ul>
</li>
<li>Q:Redis如何解决哈希冲突？<ul>
<li>哈希冲突是，由于哈希桶的个数通常少于 key 的数量，计算两个 key 的哈希值正好落在同一个哈希桶中</li>
<li>解决：使用链式哈希，即同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接，该链表也叫哈希冲突链</li>
<li><img src="https://img.shiqi-lu.tech/20210507114739.png"></li>
</ul>
</li>
<li>Q:rehash是什么？<ul>
<li>增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</li>
</ul>
</li>
<li>Q:Redis 使 rehash 更高效的方法是什么？<ul>
<li>默认使用了两个全局哈希表：哈希表 1 和哈希表 2</li>
<li>一开始默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash</li>
<li>rehash 完毕后从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用</li>
</ul>
</li>
<li>Q:rehash 的步骤是什么？<ul>
<li>1.给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍</li>
<li>2.把哈希表1中的数据重新映射并拷贝到哈希表2中</li>
<li>3.释放哈希表1的空间</li>
</ul>
</li>
<li>Q:渐进式 rehash 是什么？<ul>
<li>在第二步拷贝数据时，redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中。等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries</li>
<li><img src="https://img.shiqi-lu.tech/20210130162617.png"></li>
</ul>
</li>
</ul>
<h1 id="03丨高性能IO模型：为什么单线程Redis能那么快？"><a href="#03丨高性能IO模型：为什么单线程Redis能那么快？" class="headerlink" title="03丨高性能IO模型：为什么单线程Redis能那么快？"></a>03丨高性能IO模型：为什么单线程Redis能那么快？</h1><ul>
<li>Q:Redis单线程指的是什么？<ul>
<li>Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程</li>
</ul>
</li>
<li>Q:单线程Redis速度快的原因是什么？<ul>
<li>1.大部分操作在内存上完成，加上采用的高效的数据结构(哈希表和跳表)</li>
<li>2.采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求</li>
</ul>
</li>
</ul>
<h1 id="04丨AOF日志：宕机了，Redis如何避免数据丢失？"><a href="#04丨AOF日志：宕机了，Redis如何避免数据丢失？" class="headerlink" title="04丨AOF日志：宕机了，Redis如何避免数据丢失？"></a>04丨AOF日志：宕机了，Redis如何避免数据丢失？</h1><ul>
<li>Q:Redis持久化的两大机制是什么？<ul>
<li>AOF日志和RDB快照</li>
</ul>
</li>
<li>Q:AOF(Append Only File)的持久化是怎样的<ul>
<li>Redis 执行完一个写命令后，将写命令以协议文本的形式追加到 AOF 缓冲区末尾，再通过同步策略来决定是否将 AOF 缓冲区中的内容写入 &amp; 同步到 AOF 日志</li>
<li>只有命令能执行成功，才会被记录到日志中。不会阻塞当前的写操作</li>
</ul>
</li>
<li>Q:AOF日记的记录内容是怎样的？<ul>
<li>以<code>set testkey testvalue</code>为例</li>
<li><code>*3</code>表示当前命令有三个部分，每部分都是有<code>$+数字</code>开头，后面紧跟着具体的命令、键、值，此处的数字表示这部分中的命令、键和值一共有多少字节</li>
<li><img src="https://img.shiqi-lu.tech/20210130204646.png"></li>
</ul>
</li>
<li>Q:AOF的两个潜在风险是什么？<ul>
<li>1.如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险</li>
<li>2.AOF虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险，这是因为，AOF日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行</li>
</ul>
</li>
<li>Q:AOF日志有哪三种写回策略？(即配置项 appendfsync 的三个可选值)<ul>
<li>Always,同步写回：每个写命令执行完，立马将所有内容写入并同到 AOF 日志</li>
<li>Everysec,每秒写回：每个写命令执行完，将 AOF 缓冲区中的所有内容写入到 AOF 日志，如果上次同步 AOF 日志的时间距离现在超过 1 秒，那么对 AOF 日志进行同步</li>
<li>No,操作系统控制的写回：每个写命令执行完，将 AOF 缓冲区中的所有内容写入到 AOF 日志，但并不对 AOF 日志进行同步，何时同步由操作系统来决定</li>
</ul>
</li>
<li>Q:Redis 中的写入并同步到 AOF 日志的写入和同步的区别是什么<ul>
<li>当写回策略为 always 的时候，Redis 源码逻辑为先调用 write 函数写入 AOF 日志文件，紧接着调用 fdatasync 函数对 AOF 日志文件进行同步，确保写入的内容同步到硬盘成功</li>
<li>当调用 write 函数的时候，数据只是写到了内存缓冲区中，用 fdatasync 函数可以强制让操作系统立即将内存缓冲区中的数据同步到硬盘中</li>
</ul>
</li>
<li>Q:AOF日志三种写回策略的优劣是什么？<ul>
<li>同步写回：基本不丢数据，但在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能</li>
<li>每秒写回：采用一秒写回一次的频率，避免了「同步写回」的性能开销，虽然减少了对系统性能的影响，但若发生宕机，上一秒内未落盘的命令操作仍然会丢失</li>
<li>操作系统控制的写回：在写完缓冲区后，可以继续执行后续的命令，但是落盘的时机已经不在Redis手中了，只有AOF记录没有写回磁盘，一旦宕机对应的数据就丢失了</li>
<li><img src="https://img.shiqi-lu.tech/20210130205858.png"></li>
</ul>
</li>
<li>Q:AOF文件过大带来的3个性能问题是什么？<ul>
<li>1.文件系统本身对文件大小有限制， 无法保存过大的文件</li>
<li>2.如果文件太大，之后再往里面追加命令记录的话，效率也会变低</li>
<li>3.如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢</li>
</ul>
</li>
<li>Q:AOF重写机制是什么？<ul>
<li>在重写时，Redis根据数据库的现状创建一个新的AOF文件。</li>
<li>即读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入</li>
</ul>
</li>
<li>Q:为什么重写机制可以把日志文件变小？<ul>
<li>当一个键值对被多条写命令反复修改时，AOF文件会记录相应的多条命令</li>
<li>但在重写时，根据这个键值对当前的最新状态，为它生成对应的写入命令。这样，一个键值对在重写日志中只用一条命令即可</li>
<li>在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了</li>
<li><img src="https://img.shiqi-lu.tech/20210130225834.png"></li>
</ul>
</li>
<li>Q:重写的过程是怎样的？<ul>
<li>由后台线程bgrewriteaof完成，是为了避免阻塞主线程，导致数据库性能下降</li>
<li>一个拷贝<ul>
<li>每次执行重写时，主线程fork出后台的bgrewriteaof子进程。fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里包含了数据库的最新数据</li>
<li>bgrewriteaof子进程在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志</li>
</ul>
</li>
<li>两处日志<ul>
<li>1.正在使用的AOF日志：因主进程未阻塞，仍然可以处理新来的操作。此时若有写操作，Redis会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个AOF日志的操作仍然是齐全的，可以用于恢复</li>
<li>2.新的AOF重写日志：这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的AOF文件，以保证数据库最新状态的记录。此时即可用新的AOF文件替代旧文件了</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20210131101541.png"></li>
</ul>
</li>
</ul>
<h1 id="05丨内存快照：宕机后，Redis如何实现快速恢复？"><a href="#05丨内存快照：宕机后，Redis如何实现快速恢复？" class="headerlink" title="05丨内存快照：宕机后，Redis如何实现快速恢复？"></a>05丨内存快照：宕机后，Redis如何实现快速恢复？</h1><ul>
<li>Q:RDB的持久化是怎样的？<ul>
<li>作用是将某个时间点上的数据库状态保存到 RDB 文件中，RDB 文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于 RDB 文件是保存在硬盘上的，所以即使 Redis 崩溃或者退出，只要 RDB 文件存在，就可以用它来还原数据库的状态</li>
</ul>
</li>
<li>Q:生成RDB文件的两个命令是什么？<ul>
<li>save：在主线程执行，会导致阻塞，直到 RDB 文件生成完毕，在进程阻塞期间，Redis 不能处理任何命令请求</li>
<li>bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞(默认配置)</li>
</ul>
</li>
<li>Q:bgsave做快照时如何保证数据可修改？<ul>
<li>借助操作系统提供的写时复制技术(Copy-On-Write, COW)</li>
<li>bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件</li>
<li>若主线程对这些数据也是读操作(图中键值对A)，主线程和bgsave子线程互不影响</li>
<li>若主线程要修改一块数据(图中键值对C)，那这块数据会被复制一份，生成该数据的副本C’。然后，主线程在这个数据副本上修改，同时，bgsave子进程会把原来的数据写入RDB文件</li>
<li><img src="https://img.shiqi-lu.tech/20210619182408.png"></li>
</ul>
</li>
<li>Q:混合使用AOF日志和内存快照的方法是什么？<ul>
<li>内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作</li>
<li><img src="https://img.shiqi-lu.tech/20210131104239.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>《Redis核心技术与实战》基础篇6-9</title>
    <url>/redis-gt-2/</url>
    <content><![CDATA[<h1 id="06丨数据同步：主从库如何实现数据一致？"><a href="#06丨数据同步：主从库如何实现数据一致？" class="headerlink" title="06丨数据同步：主从库如何实现数据一致？"></a>06丨数据同步：主从库如何实现数据一致？</h1><ul>
<li>Q:Redis的主从库和读写分离是怎样的？<ul>
<li>读操作：主从库都可接收</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库</li>
<li><img src="https://img.shiqi-lu.tech/20210131104851.png"></li>
</ul>
</li>
<li>Q:如何设置主从库？<ul>
<li>通过replicaof(redis5.0之前是slaveof)</li>
<li>如现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上 执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</li>
<li><code>replicaof 172.16.19.3 6379</code></li>
</ul>
</li>
<li>Q:主从库间数据第一次同步的三个阶段是怎样？<ul>
<li><img src="https://img.shiqi-lu.tech/20210131105418.png"></li>
<li>第一阶段：主从库间建立连接、协商同步，为全量复制做准备<ul>
<li>从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了</li>
<li>即从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了主库的runID和复制进度offset两个参数<ul>
<li>runID，是每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为？</li>
<li>offset，此时设为-1，表示第一次复制</li>
</ul>
</li>
<li>主库收到psync命令后，会用FULLRESYNC相应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后，会记录下这两个参数</li>
<li>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说， 主库会把当前所有的数据都复制给从库</li>
</ul>
</li>
<li>第二阶段：主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的RDB文件<ul>
<li>主库执行bgsave命令，生成RDB文件，接着将文件发给从库。从库收到RDB文件后，会先清空当前数据库，然后加载RDB文件。这是因为从库在通过replicaof命令开始和主库同步前，可能保存了其它数据。为了避免之前数据的影响，从库需要先把当前数据库清空</li>
<li>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</li>
</ul>
</li>
<li>第三阶段：主库会把第二阶段执行过程中新收到的写命令，再发送给从库<ul>
<li>当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修 改操作发给从库，从库再重新执行这些操作</li>
</ul>
</li>
</ul>
</li>
<li>Q:主从库在命令传播时网络断了之后的处理方法？<ul>
<li>采用增量复制的方式继续同步</li>
</ul>
</li>
<li>Q:增量复制时，主从库之间的同步方式是怎样？<ul>
<li>当主从库断连后，主库会把断连期间收到的写操作命令，写入replication buffer，同时也会把这些操作命令也写入repl_backlog_buffer这个缓冲区</li>
<li>repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置</li>
<li>刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接 收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这 个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大</li>
<li>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位 置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏 移量基本相等</li>
<li><img src="https://img.shiqi-lu.tech/20210131145526.png"></li>
<li>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距</li>
<li>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行</li>
<li><img src="https://img.shiqi-lu.tech/20210131145707.png"></li>
<li>注意，因为repl_backlog_buffer是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致</li>
<li>这种情况可调整repl_backlog_size这个参数，这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小=主库写入命令速度<em>操作大小-主从库间网络传输命令速度</em>操作大小</li>
<li>在实际应用中，可把空间扩大一倍，即repl_backlog_size = 缓冲空间大小*2</li>
</ul>
</li>
</ul>
<h1 id="07丨哨兵机制：主库挂了，如何不间断服务？"><a href="#07丨哨兵机制：主库挂了，如何不间断服务？" class="headerlink" title="07丨哨兵机制：主库挂了，如何不间断服务？"></a>07丨哨兵机制：主库挂了，如何不间断服务？</h1><ul>
<li>gt7:哨兵机制是什么？<ul>
<li>哨兵其实是一个运行在特殊模式下的Redis进程，和主从库同时运行</li>
<li>用于实现主从库自动切换，有效解决主从复制模式下故障转移的监控、选主、通知三个问题</li>
</ul>
</li>
<li>gt7:哨兵机制的基本流程是怎样<ul>
<li>监控：哨兵进程在运行时，周期性地给所有的主从库发送PING命令，检测它们是否仍在运行<ul>
<li>如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为「下线状态」</li>
<li>如果主库没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程</li>
</ul>
</li>
<li>选主：主库挂了后，哨兵就从多个从库里按照一定的规则选择一个从库实例作为新主库</li>
<li>通知：哨兵会把新主库的连接信息发给其它从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</li>
<li><img src="https://img.shiqi-lu.tech/20210703104615.png"></li>
</ul>
</li>
<li>gt7:主观下线是什么？<ul>
<li>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了。哨兵就会先把它标记为「主观下线」</li>
</ul>
</li>
<li>gt7:在什么情况下，哨兵会对主库故障产生误判<ul>
<li>集群网络压力较大、网络拥塞，或是主库本身压力较大的情况下</li>
</ul>
</li>
<li>gt7:什么时候会判断客观下线？<ul>
<li>当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为「主观下线」，才能最终判定主库为「客观下线」</li>
</ul>
</li>
<li>gt7:如何选定新主库？<ul>
<li>筛选+打分</li>
<li><img src="https://img.shiqi-lu.tech/20210704133431.png"></li>
<li>筛选：检查从库当前在线状态和它之前的网络连接状态<ul>
<li>通过配置项 down-after-miliseconds * 10，down-after-miliseconds 是认定主从库锻炼的最大连接超时时间。如果在该时间内，主从节点都没有通过网络联系上，可认为主从节点断连了。如果发生断连的次数超过 10 次，说明这个从库的网络状况不好，不适合作为新主库</li>
</ul>
</li>
<li>打分：按照从库优先级、从库复制进度和从库ID号进行三轮打分<ul>
<li>1.优先级最高的从库得分高：通过 slave-priority 给从库设置不同优先级</li>
<li>2.和旧主库同步程度最接近的从库得分高：即找从库的slave_repl_offset最接近master_repl_offset的从库</li>
<li>3.ID号小的从库得分高：</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="08-哨兵集群：哨兵挂了，主从库还能切换吗？"><a href="#08-哨兵集群：哨兵挂了，主从库还能切换吗？" class="headerlink" title="08 | 哨兵集群：哨兵挂了，主从库还能切换吗？"></a>08 | 哨兵集群：哨兵挂了，主从库还能切换吗？</h1><ul>
<li>gt8:哨兵实例之间是怎样互相发现的？<ul>
<li>基于 Redis 的 pub/sub (发布/订阅)机制</li>
<li>哨兵只需和主库建立起连接，就可以在主库上发布信息了，如发布它自己的连接信息(IP和端口)。同时，也可从主库上订阅消息，获得其它哨兵发布的连接信息。</li>
<li>当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口</li>
<li>在主从集群中，不同哨兵通过主库上名为<code>__sentinel__:hello</code>的频道来相互发现，实现互相通信的</li>
<li><img src="https://img.shiqi-lu.tech/20210704150035.png"></li>
</ul>
</li>
<li>gt8:哨兵是如何知道从库的 IP 地址和端口的呢？<ul>
<li>哨兵向主库发送 INFO 命令，主库就把从库列表返回给哨兵</li>
<li>哨兵根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控</li>
<li><img src="https://img.shiqi-lu.tech/20210704150435.png"></li>
</ul>
</li>
<li>gt8:客户端如何通过监控了解哨兵进行主从切换的过程？<ul>
<li>客户端从哨兵的不同频道订阅消息</li>
<li><img src="https://img.shiqi-lu.tech/20210704150703.png"></li>
</ul>
</li>
<li>gt8:主库故障以后，哨兵集群有多个实例，怎么确定由哪个哨兵来进行实际的主从切换呢？</li>
<li>gt8:判断主库「客观下线」的过程是怎样？<ul>
<li>任何一个实例只要自身判断主库「主观下线」后，就会给其它实例发送 is-master-down-by-addr 命令</li>
<li>其它实例会根据自己和主库的连接情况，响应Y(赞成)或N(反对)</li>
<li><img src="https://img.shiqi-lu.tech/20210704151434.png"></li>
<li>一个哨兵获得了仲裁所需的赞成票数后，就可标记主库为「客观下线」。<ul>
<li>这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的 quorum 配置项设定的</li>
</ul>
</li>
<li>此时，这个哨兵可以再给其它哨兵发送命令，表明希望由自己来实现主从切换，并让所有其它哨兵投票，即「Leader 选举」</li>
<li>在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：<ul>
<li>1.拿到半数以上的赞成票</li>
<li>2.拿到的赞成票数同时还需要大于等于哨兵配置文件中的 quorum 值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="09-切片集群：数据增多了，是该加内存还是加实例？"><a href="#09-切片集群：数据增多了，是该加内存还是加实例？" class="headerlink" title="09 | 切片集群：数据增多了，是该加内存还是加实例？"></a>09 | 切片集群：数据增多了，是该加内存还是加实例？</h1><ul>
<li>gt9:Redis Cluster 数据切片和实例的对应关系是怎样？<ul>
<li>采用哈希槽(Hash Slot)，一个切片集群共有 16384 个哈希槽，每个键值对都会根据它的 key，映射到一个哈希槽中<ul>
<li>映射过程为：</li>
<li>1.根据键值对的 key，按照 CRC16 算法计算一个 16bit 的值</li>
<li>2.用这个 16 bit 值对 16384 取模，每个模数代表一个相应编号的哈希槽</li>
</ul>
</li>
<li>使用<code>cluster create</code>命令时，Redis 会自动把这些槽平均分布在集群实例上，可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。但手动分配时，需要把 16384 个槽都分配完</li>
<li><img src="https://img.shiqi-lu.tech/20210704211831.png"></li>
</ul>
</li>
<li>gt9:客户端如何定位数据在切片集群的哪个实例上？<ul>
<li>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了</li>
<li>客户端和集群实例建立连接后，实例会把哈希槽的分配信息发给客户端</li>
<li>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地</li>
</ul>
</li>
<li>gt9:若集群中，实例和哈希槽的对应关系改变了，客户端如何感知？<ul>
<li>Redis Cluster 提供了一种重定向机制，客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回 MOVED 命令响应结果，其中包含新实例的访问地址</li>
<li><code>plain text GET hello:key (error) MOVED 13320 172.16.19.5:6379</code></li>
</ul>
</li>
<li>gt9:如果数据只有一部分迁移到新实例，客户端请求重定向操作会怎样？<ul>
<li>收到一条 ASK 报错信息</li>
<li><code>plain text GET hello:key (error) ASK 13320 172.16.19.5:6379</code></li>
<li>ASK 命令表示客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移</li>
<li>此时客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令，然后在发送 GET 命令以读取数据</li>
<li>ASK 命令不会更新客户端缓存的哈希槽分配信息，即只让客户端能给新实例发送一次请求。MOVED 命令会更改本地缓存，让后续命令都发往新实例</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>自研小工具roam2anki介绍</title>
    <url>/roam2anki-intro/</url>
    <content><![CDATA[<h1 id="roam2anki"><a href="#roam2anki" class="headerlink" title="roam2anki"></a>roam2anki</h1><p>roam2anki用来把Roam Research的笔记转成anki进行记忆</p>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><a href="https://github.com/shiqi-lu/roam2anki">Github</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>已经完成所有规划的功能，已支持roam中的所有样式，包括行内、行间公式、代码块、高亮、加粗、图片、超链接等等，其中第一级会解析为问题，第二级和往后级别均解析为第一级的答案</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol>
<li>下载roam2anki.py和roam2anki模板.apkg</li>
<li>第一次操作先在anki中导入roam2anki模板.apkg</li>
<li>新建一个txt文件如example.txt，把要导入的roam字段粘贴到文本中，注意第一级为问题，第二级以下都是答案</li>
<li>运行python脚本<code>python roam2anki.py example.txt</code>，程序把转换成对应的只有两列的csv文件，问题是第一列，回答是第二列</li>
<li>把csv导入到anki中，保持默认设置即可。即fields separated by: Tab；勾选上Allow HTML in fields；Field 1为正面；field 2为背面</li>
</ol>
<p><img src="https://img.shiqi-lu.tech/20210127160319.jpeg"></p>
<h1 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 支持所有样式：加粗、斜体、高亮、删字符、行内代码、超链接</li>
<li><input checked="" disabled="" type="checkbox"> 支持图片并居中，支持引用图片</li>
<li><input checked="" disabled="" type="checkbox"> 支持答案里最高10级的缩进</li>
<li><input checked="" disabled="" type="checkbox"> 问题和答案支持块内多行</li>
<li><input checked="" disabled="" type="checkbox"> 删除alias和双中括号</li>
<li><input checked="" disabled="" type="checkbox"> 把同级问题合并成anki同一个问题</li>
<li><input checked="" disabled="" type="checkbox"> 支持问题和答案的行内公式、引用的行内公式</li>
<li><input checked="" disabled="" type="checkbox"> 支持多行行间公式，引用的多行行间公式，同时支持块内的新起的多行行间公式，但要注意新起一行，不能续着写</li>
<li><input checked="" disabled="" type="checkbox"> 支持代码块导入和语法高亮，支持引用代码块，若有必要并可强制选择代码块高亮语言</li>
<li><input checked="" disabled="" type="checkbox"> 支持标题字号h1到h3</li>
<li><input checked="" disabled="" type="checkbox"> 涉及到html的&lt;、&gt;、&amp;、”等字符放到anki前进行转义，保证所有字符都能显示</li>
</ul>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul>
<li>答案和问题的代码块必须要新起一个块或块内新起一行，且这一行必须以3个反引号开始，即不支持代码块放在一行中间，原因是难以解析，且代码块展示就是会新起一行，就人工新起一行吧，结尾也要新起一行</li>
<li>只支持无序列表(Bulleted List)，不支持有序列表(Numbered List)和文档(Document)，原因是有序列表难以判断和解析，支持文档模式会和现有的块内多行的判断有歧义</li>
</ul>
<h1 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h1><ul>
<li>roam2anki.py提供了批量转换的方法，第二个选项<code>python roam2anki.py example ...</code>，若example为一个文件夹，会寻找example下的所有以.txt结尾的文件进行转换，后续可接多个文件或文件夹</li>
<li>roam2anki只支持语法正确时的解析，即保证在roam中能正确解析的，导出anki后也正确解析，不正确的语法，或故意为难解析器的，，我也没办法哇</li>
<li>roam2anki目前是作者写给自用，若使用过程中发现有解析出来的bug，请提一个issue</li>
</ul>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ul>
<li>python &gt;= 3.7</li>
<li>pandas &gt;= 1.0.1</li>
</ul>
]]></content>
      <categories>
        <category>学习工具</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Roam Research</tag>
        <tag>anki</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法全整理（python3）</title>
    <url>/sort-algo/</url>
    <content><![CDATA[<h1 id="冒泡排序-基础写法"><a href="#冒泡排序-基础写法" class="headerlink" title="冒泡排序(基础写法)"></a>冒泡排序(基础写法)</h1><ul>
<li>核心思想：每一趟都通过按顺序两两比较的方法，把当前剩余元素的最大值移动到一端<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="comment"># 外层循环：从第0到n-2共n-1趟，比较是以当前元素和后一个元素比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 内层循环：从0到n-i-1，减i是因为每一趟结束均有一个已排好序的值</span></span><br><span class="line">            <span class="comment"># 如进行第i=1趟时，意味着有1个数字已排好</span></span><br><span class="line">            <span class="comment"># 如进行第i=n-2趟时(最后一趟)，此时i为n-2个数字已排好，</span></span><br><span class="line">            <span class="comment"># 最后2个数字再比较一次即可</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length - i - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 交换当前元素和后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)，空间复杂度：O(1)<h1 id="冒泡排序-基础改进写法"><a href="#冒泡排序-基础改进写法" class="headerlink" title="冒泡排序(基础改进写法)"></a>冒泡排序(基础改进写法)</h1></li>
<li>思想是如果一次排序中没有经过交换，则停止排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        swapped = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length - i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)，空间复杂度：O(1)<h1 id="冒泡排序-第三种写法"><a href="#冒泡排序-第三种写法" class="headerlink" title="冒泡排序(第三种写法)"></a>冒泡排序(第三种写法)</h1></li>
<li>在第二种写法的基础上继续优化，下一轮比较时，只需比较到上一轮中，最后一次发生交换的位置即可。因为后面的所有元素都没有发生过交换，必然已经有序了<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        swapped = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 最后一个没有经过排序的元素的下标</span></span><br><span class="line">        last_unsorted = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 上次交换的位置</span></span><br><span class="line">        swapped_index = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> swapped:</span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(last_unsorted):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                    nums[i], nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>], nums[i]</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">                    swapped_index = i</span><br><span class="line">            <span class="comment"># 最后一个没有经过排序的元素的下标就是</span></span><br><span class="line">            <span class="comment"># 最后一次发生交换的位置</span></span><br><span class="line">            last_unsorted = swapped_index</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)，空间复杂度：O(1)<h1 id="选择排序-基本写法"><a href="#选择排序-基本写法" class="headerlink" title="选择排序(基本写法)"></a>选择排序(基本写法)</h1></li>
<li>对一个序列A中的元素A[0]~A[n-1]，令i从0到n-1枚举，进行第n趟操作，每趟从待排序部分[i,n-1]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会与当前有序区间[1,i-1]形成新的有序区间[1,i]。于是在n趟操作之后，所有的元素都是有序的，时间复杂度O(n^2)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">1</span>):</span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length):</span><br><span class="line">                <span class="keyword">if</span> nums[min_index] &gt; nums[j]:</span><br><span class="line">                    min_index = j</span><br><span class="line">            nums[min_index], nums[i] = nums[i], nums[min_index]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度O(1)，时间复杂度O(n^2)<h1 id="选择排序-改进写法"><a href="#选择排序-改进写法" class="headerlink" title="选择排序(改进写法)"></a>选择排序(改进写法)</h1></li>
<li>每次选择是记录最小值和最大值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">            min_index, max_index = i, i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - i):</span><br><span class="line">                <span class="keyword">if</span> nums[min_index] &gt; nums[j]:</span><br><span class="line">                    min_index = j</span><br><span class="line">                <span class="keyword">if</span> nums[max_index] &lt; nums[j]:</span><br><span class="line">                    max_index = j</span><br><span class="line">            <span class="comment"># 若min_index和max_index相等，那么必定都等于i，</span></span><br><span class="line">            <span class="comment"># 且后面的所有数字都与 nums[i] 相等，此时排序完成</span></span><br><span class="line">            <span class="keyword">if</span> min_index == max_index:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[min_index], nums[i] = nums[i], nums[min_index]</span><br><span class="line">            <span class="comment"># 若最大值的下标刚好是i，由于nums[i]和nums[min_index]已</span></span><br><span class="line">            <span class="comment"># 交换，所以这里要更新 max_index 的值</span></span><br><span class="line">            <span class="keyword">if</span> max_index == i:</span><br><span class="line">                max_index = min_index</span><br><span class="line">            last_index = length - i - <span class="number">1</span></span><br><span class="line">            nums[max_index], nums[last_index] = nums[last_index], nums[max_index]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度O(1)，时间复杂度O(n^2)<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1></li>
<li>对序列A的前n个元素A[0]到A[n-1]，令i从1到n-1枚举，进行n-1趟操作。假设某一趟时，序列A的前i-1个元素A[i]到A[i-1]已经有序，而范围[i,n-1]还未有序，那么从范围[1,i-1]中寻找某个位置j，是的将a[i]插入位置j后（此时A[j]到A[i-1]会后移一位至A[j+1]到A[i]），范围[1,i]有序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            cur_num = nums[i]</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 寻找插入位置的过程中，不断地将比cur_num大的数字向后挪</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> cur_num &lt; nums[j]:</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 跳出循环的两种情况:</span></span><br><span class="line">            <span class="comment"># 1.遇到一个小于或等于cur_num的数字，跳出循环，</span></span><br><span class="line">            <span class="comment"># curr_num就坐到它后面</span></span><br><span class="line">            <span class="comment"># 2.已经走到数列头部，仍然没有遇到小于或等于cur_num的数字，</span></span><br><span class="line">            <span class="comment"># 也会跳出循环，此时j等于-1，cur_num就坐到数列头部</span></span><br><span class="line">            nums[j+<span class="number">1</span>] = cur_num</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度O(1)，时间复杂度O(n^2)<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行用时：568 ms, 在所有 Python3 提交中击败了5.08%的用户</span></span><br><span class="line"><span class="comment"># 内存消耗：17.9 MB, 在所有 Python3 提交中击败了58.54%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gaps</span>(<span class="params">self, length</span>):</span></span><br><span class="line">        gaps = []</span><br><span class="line">        gap = length // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">            gaps.append(gap)</span><br><span class="line">            gap //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> gaps</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="comment"># 间隔序列</span></span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> self.get_gaps(length):</span><br><span class="line">            <span class="comment"># 分组</span></span><br><span class="line">            <span class="keyword">for</span> group_index <span class="keyword">in</span> range(gap):</span><br><span class="line">                <span class="comment"># 插入排序</span></span><br><span class="line">                <span class="keyword">for</span> cur_index <span class="keyword">in</span> range(group_index+gap, length, gap):</span><br><span class="line">                    cur_num = nums[cur_index]</span><br><span class="line">                    pre_index = cur_index - gap</span><br><span class="line">                    <span class="keyword">while</span> pre_index &gt;= group_index <span class="keyword">and</span> cur_num &lt; nums[pre_index]:</span><br><span class="line">                        nums[pre_index + gap] = nums[pre_index]</span><br><span class="line">                        pre_index -= gap</span><br><span class="line">                    nums[pre_index + gap] = cur_num</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度O(1)，时间复杂度O(n^1.3)，最坏时间复杂度O(n^2)<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1></li>
<li>根节点下标视为0的完全二叉树的3个性质<ul>
<li>1.对于完全二叉树中的第 i 个数，它的左孩子下标是：<code>left = 2i + 1</code></li>
<li>2.对于完全二叉树中的第 i 个数，它的右孩子下标是：<code>right = left + 1 = 2i + 2 = 2(i+1)</code></li>
<li>3.对于n个元素的完全二叉树(n &gt;= 2)，它的最后一个非叶子结点的下标：$\lfloor n / 2 \rfloor -1$，等价于该结点的父节点下标<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行用时：1052 ms, 在所有 Python3 提交中击败了5.09%的用户</span></span><br><span class="line"><span class="comment">#内存消耗：20.1 MB, 在所有 Python3 提交中击败了6.51%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 构建初始大顶堆</span></span><br><span class="line">        nums = self.build_max_heap(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 将最大值交换到数组最后</span></span><br><span class="line">            nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 调整剩余数组，使其满足大顶堆</span></span><br><span class="line">            nums = self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span>(<span class="params">self, nums</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 从最后一个非叶子结点开始调整大顶堆，</span></span><br><span class="line">        <span class="comment"># 最后一个非叶子结点的下标是 len(nums) // 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            nums = self.max_heapify(nums, i, len(nums))</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调整大顶堆，第三个参数表示剩余未排序的数字的数量，即剩余堆的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span>(<span class="params">self, nums, i, heap_size</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 左右子节点下标</span></span><br><span class="line">        l, r = <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        <span class="comment"># 找到根节点、左右子树结点中的最大值下标</span></span><br><span class="line">        largest = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; heap_size <span class="keyword">and</span> nums[l] &gt; nums[largest]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; heap_size <span class="keyword">and</span> nums[r] &gt; nums[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            <span class="comment"># 将最大值交换为根结点</span></span><br><span class="line">            nums[i], nums[largest] = nums[largest], nums[i]</span><br><span class="line">            <span class="comment"># 再次调整交换数字后的大顶堆</span></span><br><span class="line">            nums = self.max_heapify(nums, largest, heap_size)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>初始化堆(build_max_heap)的时间复杂度是O(n)，重建堆(max_heapify)的时间复杂度为O(nlogn)，总时间复杂度O(nlogn)</li>
<li>空间复杂度O(1)<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行用时：176 ms, 在所有 Python3 提交中击败了75.38%的用户</span></span><br><span class="line"><span class="comment"># 内存消耗：18 MB, 在所有 Python3 提交中击败了40.91%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.quicksort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">self, nums, start, end</span>):</span></span><br><span class="line">        <span class="comment"># 如果区域内少于2个，退出递归</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = self.partition(nums, start, end)</span><br><span class="line">        self.quicksort(nums, start, mid<span class="number">-1</span>)</span><br><span class="line">        self.quicksort(nums, mid+<span class="number">1</span>, end)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, nums, start, end</span>):</span></span><br><span class="line">        <span class="comment"># 避免有序数组</span></span><br><span class="line">        random_index = random.randint(start, end)</span><br><span class="line">        nums[start], nums[random_index] = nums[random_index], nums[start]</span><br><span class="line">        pivot = nums[start]</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">while</span> start &lt; end <span class="keyword">and</span> pivot &lt;= nums[end]:</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            nums[start] = nums[end]</span><br><span class="line">            <span class="keyword">while</span> start &lt; end <span class="keyword">and</span> nums[start] &lt;= pivot:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            nums[end] = nums[start]</span><br><span class="line">        nums[start] = pivot</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure></li>
<li>平均时间复杂度为 O(nlogn)，最坏的时间复杂度为 O(n^2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn) ~ O(n)，平均空间复杂度为 O(logn)</li>
</ul>
<h1 id="归并排序-递归写法"><a href="#归并排序-递归写法" class="headerlink" title="归并排序(递归写法)"></a>归并排序(递归写法)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行用时：252 ms, 在所有 Python3 提交中击败了32.87%的用户</span></span><br><span class="line"><span class="comment"># 内存消耗：19 MB, 在所有 Python3 提交中击败了15.42%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid = len(nums) // <span class="number">2</span></span><br><span class="line">        a = self.sortArray(nums[:mid])</span><br><span class="line">        b = self.sortArray(nums[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(a,b)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        merged = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(a) <span class="keyword">and</span> j &lt; len(b):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt;= b[j]:</span><br><span class="line">                merged.append(a[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merged.append(b[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        merged.extend(a[i:])</span><br><span class="line">        merged.extend(b[j:])</span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度是 O(nlogn)，因拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，空间复杂度是 O(n)，主要占用空间的就是我们在排序前创建的长度为 n 的数组</li>
</ul>
<h1 id="归并排序-非递归写法"><a href="#归并排序-非递归写法" class="headerlink" title="归并排序(非递归写法)"></a>归并排序(非递归写法)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行用时：276 ms, 在所有 Python3 提交中击败了24.61%的用户</span></span><br><span class="line"><span class="comment">#内存消耗：17.9 MB, 在所有 Python3 提交中击败了60.92%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.merge_sort(<span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.nums</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">self, low, high</span>):</span></span><br><span class="line">        <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        self.merge_sort(low, mid)</span><br><span class="line">        self.merge_sort(mid+<span class="number">1</span>, high)</span><br><span class="line">        self.merge(low, mid, high)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, low, mid, high</span>):</span></span><br><span class="line">        <span class="comment"># 只需要拷贝前半份</span></span><br><span class="line">        merged = self.nums[low:mid+<span class="number">1</span>]</span><br><span class="line">        i, i1, i2 = low, <span class="number">0</span>, mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i1 &lt; len(merged) <span class="keyword">and</span> i2 &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> merged[i1] &lt;= self.nums[i2]:</span><br><span class="line">                self.nums[i] = merged[i1]</span><br><span class="line">                i, i1 = i+<span class="number">1</span>, i1+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.nums[i] = self.nums[i2]</span><br><span class="line">                i, i2 = i+<span class="number">1</span>, i2+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i1 &lt; len(merged):</span><br><span class="line">            self.nums[i] = merged[i1]</span><br><span class="line">            i, i1 = i+<span class="number">1</span>, i1+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i2 &lt;= high:</span><br><span class="line">            self.nums[i] = self.nums[i2]</span><br><span class="line">            i, i2 = i+<span class="number">1</span>, i2+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度是 O(nlogn)，空间复杂度是 O(n)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>博客升级纪要</title>
    <url>/update-blog/</url>
    <content><![CDATA[<p>学完HTTP协议后，然后下决心要把博客和图床都升级为HTTPS，然后域名也备案，并且把图床也用自己的域名</p>
<p>参考：<a href="https://jiapeng.me/markdown-picbed/">https://jiapeng.me/markdown-picbed/</a></p>
<p>简要步骤：<br>1.先把原有的域名走备案流程，原有申请的域名在万网，就直接在阿里云备案了，这需要一周左右时间，这里我要吐槽一下，备案一定要买阿里云的服务器，，，，，，<br>2.在阿里云上课直接申请免费的SSL证书，同时在七牛云上的图床的对象存储中新开一个域名，配置好后，打开HTTPS访问，并且自动转换HTTP为HTTPS访问<br>3.申请一个子域名img.shiqi-lu.tech，然后指向七牛云中<br>4.批量替换原有图床的域名为新域名</p>
<p>除了第1个步骤等了很久，其它都很快。。。整个过程阿里云的服务器买了最低配的，花了300多，七牛云以后用HTTPS的话，就没有免费额度了，看了一下价格也不贵，19块有100G流量，够用了。。。</p>
]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>自我提升</tag>
      </tags>
  </entry>
  <entry>
    <title>5种限流算法总结</title>
    <url>/throttling-algorithm/</url>
    <content><![CDATA[<h1 id="限流的定义是什么"><a href="#限流的定义是什么" class="headerlink" title="限流的定义是什么"></a>限流的定义是什么</h1><ul>
<li>限流就是对请求的速率进行限制，即限制到达系统的并发请求数，避免瞬时的大量请求击垮软件系统</li>
</ul>
<h1 id="限流算法有哪些？"><a href="#限流算法有哪些？" class="headerlink" title="限流算法有哪些？"></a>限流算法有哪些？</h1><ul>
<li>计数限流</li>
<li>固定窗口限流</li>
<li>滑动窗口限流</li>
<li>漏桶算法</li>
<li>令牌桶算法</li>
</ul>
<h1 id="计数限流算法原理、代码、优缺点"><a href="#计数限流算法原理、代码、优缺点" class="headerlink" title="计数限流算法原理、代码、优缺点"></a>计数限流算法原理、代码、优缺点</h1><ul>
<li>原理<ul>
<li>根据系统能同时处理的请求数，保存一个计数器，处理一个请求加一，处理完后减一，若超过阈值拒绝请求</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (counter &lt; threshold) &#123;</span><br><span class="line">         counter++;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        counter--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优点<ul>
<li>简单粗暴，单机在 java 可用 Atomic 等原子类、分布式就 Redis incr</li>
</ul>
</li>
<li>缺点<ul>
<li>假设单机设的 1 万阈值，计数器为 0，若在 1 秒内收到 1 万个突发请求，可能超过机器的处理上限而导致机器崩溃</li>
</ul>
</li>
</ul>
<h1 id="固定窗口限流算法的原理、代码、问题"><a href="#固定窗口限流算法的原理、代码、问题" class="headerlink" title="固定窗口限流算法的原理、代码、问题"></a>固定窗口限流算法的原理、代码、问题</h1><ul>
<li>原理<ul>
<li><img src="https://img.shiqi-lu.tech/20211204112507.png"></li>
<li>相比于计数限流主要是多了个时间窗口的概念，计数器每过一个时间窗口就重置，规则为：<ul>
<li>1.请求次数小于阈值，允许访问并且计数器 +1</li>
<li>2.请求次数大于阈值，拒绝访问</li>
<li>3.这个时间窗口过了之后，计数器清零</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    bool now = currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若过了时间窗口把计数器清零</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastAcquireTime &gt; TimeWindow) &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        lastAcquireTime = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter &lt; threshold) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>问题<ul>
<li>无法保证限流速率，因而无法保证突然激增的流量，会遇到固定窗口临界问题，即这个算法有时会让通过请求量允许为限制的两倍</li>
<li>如图，限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求</li>
<li><img src="https://img.shiqi-lu.tech/20211204112759.png"></li>
</ul>
</li>
</ul>
<h1 id="滑动窗口限流算法的原理、代码"><a href="#滑动窗口限流算法的原理、代码" class="headerlink" title="滑动窗口限流算法的原理、代码"></a>滑动窗口限流算法的原理、代码</h1><ul>
<li>原理<ul>
<li><img src="https://img.shiqi-lu.tech/20211204113156.png"></li>
<li>1.将时间划分为多个区间</li>
<li>2.在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间</li>
<li>3.每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间</li>
<li>4.如果当前窗口内的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃</li>
</ul>
</li>
<li>代码<ul>
<li>实现：记录每次请求的时间，统计每次请求的时间至往前一个时间窗口的请求数，如果小于阈值就记录这个请求的时间，反之拒绝<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> counter = getCounterInTimeWindow(now);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; threshold) &#123;</span><br><span class="line">        addToTimeWindow(now);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>优点<ul>
<li>避免了固定窗口计数器带来的双倍突发请求</li>
</ul>
</li>
<li>缺点<ul>
<li>时间区间的精度越高，算法所需的空间容量就越大</li>
<li>无法解决短时间集中流量的突击，到流量处理不够平滑</li>
</ul>
</li>
</ul>
<h1 id="桶漏算法的原理、实现、优缺点"><a href="#桶漏算法的原理、实现、优缺点" class="headerlink" title="桶漏算法的原理、实现、优缺点"></a>桶漏算法的原理、实现、优缺点</h1><ul>
<li>原理<ul>
<li><img src="https://img.shiqi-lu.tech/20211204114457.png"></li>
<li>水滴持续漏到桶中，底部定速流出，如果桶空了则停止漏水，如果满了多余的水会被直接抛弃</li>
</ul>
</li>
<li>实现<ul>
<li>使用队列，服务的请求会存在队列中，服务的提供方按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝</li>
</ul>
</li>
<li>优点<ul>
<li>宽进严出，无论请求数量和速率多大，都能按照固定速率流出，流量处理非常平滑</li>
</ul>
</li>
<li>缺点<ul>
<li>当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应</li>
</ul>
</li>
</ul>
<h1 id="令牌桶算法的原理、优缺点"><a href="#令牌桶算法的原理、优缺点" class="headerlink" title="令牌桶算法的原理、优缺点"></a>令牌桶算法的原理、优缺点</h1><ul>
<li>原理<ul>
<li><img src="https://img.shiqi-lu.tech/20211204121242.png"></li>
<li>以固定速率生成令牌存入到令牌桶中</li>
<li>如果令牌数量超过桶的限制则直接丢弃</li>
<li>当请求到达是，会先从令牌桶中取令牌，取到了令牌的请求可以执行，如果桶空了，那么取令牌的请求会被直接丢弃</li>
</ul>
</li>
<li>优点<ul>
<li>能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://segmentfault.com/a/1190000023552181">图解+代码|常见限流算法以及限流在单机分布式场景下的思考</a></li>
<li><a href="https://snailclimb.gitee.io/javaguide/#/docs/high-availability/limit-request">限流算法有哪些？</a></li>
<li>极客时间-分布式技术原理与算法解析 29 讲</li>
<li><a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">分布式服务限流实战，已经为你排好坑了</a></li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>《分布式协议与算法实战》协议和算法篇上 学习笔记</title>
    <url>/distrib-protocal-algo-2/</url>
    <content><![CDATA[<h1 id="05-Paxos算法（一）：如何在多个节点间确定某变量的值？"><a href="#05-Paxos算法（一）：如何在多个节点间确定某变量的值？" class="headerlink" title="05 | Paxos算法（一）：如何在多个节点间确定某变量的值？"></a>05 | Paxos算法（一）：如何在多个节点间确定某变量的值？</h1><ul>
<li>Q:Basic Paxos的三种角色<ul>
<li>提议者(Proposer)：提议一个值用于投票表决，可把客户端当成提议者。但在绝大多数场景中，集群中收到客户端请求的节点，才是提议者。好处是对业务代码没有入侵性，即不需要再业务代码中实现算法逻辑，可像使用数据库一样访问后端数据。代表的是接入和协调功能，收到客户端请求后，发起二阶段提交，进行共识协商</li>
<li>接受者(Acceptor)：对每个提议的值进行投票，并存储接受的值。一般集群中的所有节点都在扮演接受者的角色，参与共识协商，并接受和存储数据。代表投票协商和存储数据，对提议的值进行投票，并接受达成共识的值，存储保存</li>
<li>学习者(Learner)：被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。通常学习者是数据备份节点，如「Master-Slaev」模型中的Slave，被动地接受数据，容灾备份。代表存储数据，不参与共识协商，值接受达成共识的值，存储保存</li>
<li><img src="https://img.shiqi-lu.tech/20210224113354.png"></li>
</ul>
</li>
<li>Q:Basic Paxos如何达成共识<ul>
<li>假设客户端 1 的提案编号为 1，客户端 2 的提案编号为 5，并假设节点 A、B 先收到来自客户端 1 的准备请求，节点 C 先收到来自客户端 2 的准备请求</li>
<li>准备(Prepare)阶段<ul>
<li>客户端1、2作为提议者，分别向所有接受者发送包含提案编号的准备请求</li>
<li><img src="https://img.shiqi-lu.tech/20210224130253.png"></li>
<li>在准备请求中是不需要指定提议的值的，只需要携带提案编号即可</li>
<li>当节点A、B收到提案编号为1的准备请求，节点C收到提案编号为5的准备请求后，将这样处理：</li>
<li><img src="https://img.shiqi-lu.tech/20210224131137.png"></li>
<li>由于之前没有通过任何提案，所以结点A、B将返回一个「尚无提案」的相应，并以后不再响应提案编号小于等于1的准备请求，不会通过编号小于1的提案</li>
<li>结点C则返回「尚无提案」的响应并以后不再响应提案编号小于等于5的准备请求，不会通过编号小于5的提案</li>
<li>另外，当节点 A、B 收到提案编号为 5 的准备请求，和节点 C 收到提案编号为 1 的准备请求的时候，将这样处理：</li>
<li><img src="https://img.shiqi-lu.tech/20210224131639.png"></li>
<li>当节点A、B收到提案编号为5的准备请求的时候，因为提案编号5大于它们之前响应的准备请求的提案编号1，而且两个节点都没有通过诺任何提案，所以它将返回一个「尚无提案」的响应，并承诺以后不再响应提案编号小于等于5的准备请求，不会通过编号小于5的提案</li>
<li>当节点C收到提案编号为1的准备请求的时候，由于提案编号1小于它之前响应的准备请求的提案编号5，所以丢弃该准备请求，不做响应</li>
</ul>
</li>
<li>接受(Accept)阶段<ul>
<li>首先客户端1、2在收到大多数节点的准备响应之后，会分别发送接受请求：</li>
<li><img src="https://img.shiqi-lu.tech/20210224132014.png"></li>
<li>当客户端1收到大多数的接受者(节点A、B)的准备响应后，根据响应中提案编号最大的提案的值，设置接受请求中的值。因为该值在来自节点A、B的准备响应中都为空，所以就把自己的提议值3作为提案的值，发送接受请求[1, 3]</li>
<li>当客户端2收到大多数的接受者的准备响应后(节点A、B和节点C)，根据响应中提案编号最大的提案的值，来设置接受请求中的值。因为该值来自节点A、B、C的准备响应中都为空，所以就把自己的提议值7作为提案的值，发送请求[5, 7]</li>
<li>当三个节点收到2 个客户端的接受请求时，会这样处理：</li>
<li><img src="https://img.shiqi-lu.tech/20210224142538.png"></li>
<li>当节点A、B、C收到接受请求[1, 3]时，由于提案的提案编号1小于三个节点承诺能通过的提案的最小提案编号5，所以提案[1, 3]将被拒绝</li>
<li>当节点A、B、C收到接受请求[5, 7]的时候，由于提案的提案编号 5 不小于三个节点承诺能通过的提案的最小提案编号 5，所以就通过提案[5, 7]，也就是接受了值 7，三个节点就 X 值为 7 达成了共识</li>
</ul>
</li>
<li>如果集群中有学习者，当接受者通过了一个提案时，就通知给所有的学习者。当学习者发现大多数的接受者都通过了某个提案，那么它也通过该提案，接受该提案的值</li>
<li>Basic Paxos的容错能力，源自「大多数」的约定，即当少于一半的节点出现故障的时候，共识协商仍然在正常工作</li>
<li>本质上而言，提案编号的大小代表着优先级，根据提案编号的大小， 接受者保证三个承诺<ul>
<li>如果准备请求的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个准备请求</li>
<li>如果接受请求中的提案的提案编号，小于接受者已经响应的准备请求的提案编号，那么接受者将承诺不通过这个提案</li>
<li>如果接受者之前有通过提案，那么接受者将承诺，会在准备请求的响应中，包含已经通过的最大编号的提案信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="07-Raft算法（一）：如何选举领导者？"><a href="#07-Raft算法（一）：如何选举领导者？" class="headerlink" title="07 | Raft算法（一）：如何选举领导者？"></a>07 | Raft算法（一）：如何选举领导者？</h1><ul>
<li>Q:Raft算法的成员身份(服务器节点状态)<ul>
<li>领导者(Leader)：主要工作有处理写请求、管理日志复制和不断地发送心跳信息</li>
<li>跟随者(Follower)：默默接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，主动站出来，推荐自己当候选人</li>
<li>候选人(Candidate)：候选人将向其它节点发送请求投票(RequestVote) RPC消息，通知其它节点来投票，如果赢得了大多数选票，就晋升当领导者</li>
<li>Raft算法是强领导者模型，集群中只能有一个领导者</li>
</ul>
</li>
<li>Q:Raft算法选举领导者的过程<ul>
<li>在初始状态下，集群中所有的节点都是跟随者的状态</li>
<li><img src="https://img.shiqi-lu.tech/20210224152326.png"></li>
<li>Raft算法实现了随机超时时间的特性，即每个节点等待领导者节点心跳信息的超时时间间隔是随机的。如上图，集群中没有领导者，而节点A的等待超时时间最小(150ms)，它会最先因为没有等到领导者的心跳信息，发生超时</li>
<li>这时，节点A就增加自己的任期编号，推举自己为候选人，先给自己投上一张选票，然后向其他节点发送请求投票 RPC 消息，请它们选举自己为领导者</li>
<li><img src="https://img.shiqi-lu.tech/20210224152603.png"></li>
<li>如果其它节点接收到候选人A的请求投票RPC消息，在编号为1的这届任期内，也还没有进行过投票，那么它将把选票投给节点A，并增加自己的任期编号</li>
<li><img src="https://img.shiqi-lu.tech/20210224152812.png"></li>
<li>如果候选人在选举超时时间内赢得了大多数的选票，那么它就会成为本届任期内的新领导者</li>
<li><img src="https://img.shiqi-lu.tech/20210224152920.png"></li>
<li>节点A当选领导者后，将周期性地发送心跳消息，通知其他服务器我是领导者，阻止跟随者发起新的选举，篡权</li>
<li><img src="https://img.shiqi-lu.tech/20210224153011.png"></li>
</ul>
</li>
<li>Q:节点间如何通讯？<ul>
<li>在Raft算法中，服务器节点间的沟通联络采用的是远程过程调用(RPC)，在领导者选举中，需要用到两类RPC：<ul>
<li>1.请求投票(RequestVote) RPC，由候选人在选举期间发起，通知各节点进行投票</li>
<li>2.日志复制(AppendEntries) RPC，由领导者发起，用来复制日志和提供心跳信息</li>
</ul>
</li>
<li>注意：日志复制 RPC 只能由领导者发起，这是实现强领导者模型的关键之一</li>
</ul>
</li>
<li>Q:什么是任期？<ul>
<li>Raft算法中的领导者也是有任期的，每个任期由单调递增的数字(任期编号)标识，如节点A的任期编号是1。任期编号是随着选举的举行而变化的<ul>
<li>1.跟随者在等待领导者心跳信息超时后，推举自己为候选人时，会增加自己的任期号，如节点A的当前任期编号为0，那么在推举自己为候选人时，会将自己的任期编号加1</li>
<li>2.如果一个服务器节点，发现自己的任期编号比其它节点小，那么它会更新自己的编号到较大的编号值。如节点B的任期编号是0，当收到来自节点A的请求投票RPC消息时，因为信息中包含了结点A的任期编号，且编号为1，那么节点B将把自己的任期编号更新为1</li>
</ul>
</li>
<li>Raft 算法中的任期不只是时间段，而且任期编号的大小，会影响领导者选举和请求的处理<ul>
<li>1.在Raft算法中约定，如果一个候选人或领导者，发现自己的任期编号比其它节点小，那么它会立即恢复成跟随者状态。比如分区错误恢复后，任期编号为3的领导者节点B，收到来自新领导者的，包含任期编号为4的心跳信息，那么节点B将立即恢复成跟随者状态</li>
<li>2.还约定如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求。如节点C的任期编号为4，收到包含任期编号为3的请求投票RPC消息，那么它将拒绝这个消息</li>
</ul>
</li>
</ul>
</li>
<li>Q:选举有哪些规则？<ul>
<li>1.领导者周期性地向所有跟随者发送心跳信息(即不包含日志项的日志复制RPC消息)，通知大家我是领导者，阻止跟随者发起新的选举</li>
<li>2.如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举</li>
<li>3.在一次选举中，赢得大多数选票的候选人，将晋升为领导者</li>
<li>4.在一个任期内，领导者一直都会是领导者，直到它自身出现问题(如宕机)，或者因为网络延迟，其它节点发起一轮新的选举</li>
<li>5.在一次选举中，每一个服务器节点最多会对一个任期编号投出一章选票，并且按照「先来先服务」的原则进行投票。如节点C的任期编号为3，先收到了1个包含任期编号为4的投票请求(来自节点A)，然后又收到了1个包含任期编号为4的投票请求(来自节点B)。那么节点C将会把唯一一张选票投给节点A，当再收到节点B的投票请求RPC 消息时，对于编号为 4 的任期，已没有选票可投了</li>
<li><img src="https://img.shiqi-lu.tech/20210224160810.png"></li>
<li>6.当任期编号相同时，日志完整性高的跟随者(即最后一条日志项对应的任期编号值更大，索引号更大)，拒绝投票给日志完整性低的候选人。比如节点B、C的任期编号都是3，节点B的最后一条日志项对应的任期编号为3，而节点C为2，那么当节点C请求节点B投票给自己时，节点B将拒绝投票</li>
<li><img src="https://img.shiqi-lu.tech/20210224161027.png"></li>
<li>注意：选举时跟随者发起的，推举自己为候选人；大多数选票是指集群成员半数以上的选票；大多数选票规则的目标，是为了保证在一个给定的任期内最多只有一个领导者</li>
<li>除了选举规则外，还需要避免一些会导致选举失败的情况，如同一任期内，多个候选人同时发起选举，导致选票被瓜分，选举失败。在Raft使用随机超时时间来避免这个问题</li>
</ul>
</li>
<li>Q:如何理解随机超时时间?<ul>
<li>Raft 算法巧妙地使用随机选举超时时间的方法，把超时时间都分散开来，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，这样就能减少因选票瓜分导致选举失败的情况</li>
<li>Raft算法的随机超时时间的 2 种含义<ul>
<li>1.跟随者等待领导者心跳信息超时的时间间隔，是随机的</li>
<li>2.当没有候选人赢得过半票数，选举无效了，这时需要等待一个随机时间间隔，即等待选举超时的时间间隔，是随机的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="08-Raft算法（二）：如何复制日志？"><a href="#08-Raft算法（二）：如何复制日志？" class="headerlink" title="08 | Raft算法（二）：如何复制日志？"></a>08 | Raft算法（二）：如何复制日志？</h1><ul>
<li>Q:Raft算法中的日志是什么？<ul>
<li>在Raft算法中，副本数据以日志的形式存在，日志是由日志项组成，日志项是一种数据格式，主要包含用户指定的数据，即指令(Command)，和一些附加信息，如索引值(Log index)、任期编号(Term)</li>
<li><img src="https://img.shiqi-lu.tech/20210224162319.png"></li>
<li>指令：一条由客户端请求指定的、状态机需要执行的指令。可理解成客户端指定的数据</li>
<li>索引值：日志项对应的整数索引值，用来标识日志项，是一个连续的、单调递增的整数号码</li>
<li>任期编号：创建这条日志项的领导者的任期编号</li>
<li>注意：一届领导者任期，往往有多条日志项。而且日志项的索引值是连续的</li>
</ul>
</li>
<li>Q:如何复制日志？<ul>
<li>可把Raft 的日志复制理解成一个优化后的二阶段提交（将二阶段优化成了一阶段），减少了一半的往返消息，也就是降低了一半的消息延迟</li>
<li>1.领导者进入第一阶段，通过日志复制(AppendEntries) RPC消息，将日志项复制到其它节点上</li>
<li>2.如果领导者接收到大多数的「复制成功」响应后，它将日志项提交到它的状态机，并返回成功给客户端。如果领导者没有接收到大多数的“复制成功”响应，那么就返回错误给客户端</li>
</ul>
</li>
<li>Q:领导者将日志项提交到它的状态机，为什么没通知跟随者提交日志项？<ul>
<li>这是 Raft 中的一个优化，领导者不直接发送消息通知其它节点提交指定日志项。因为领导者的日志复制RPC消息或心跳消息，包含了当前最大的，将会被提交的日志项索引值。所以通过日志复制RPC消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息</li>
<li>因此，当其它节点接受领导者的心跳信息，或者新的日志复制RPC消息后，就会将这条日志项提交到它的状态机。这个优化，降低了处理客户端请求的延迟，将二阶段提交优化为一阶段提交，降低了一半的消息延迟</li>
</ul>
</li>
<li>Q:日志复制过程？<ul>
<li><img src="https://img.shiqi-lu.tech/20210224164552.png"></li>
<li>1.接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中</li>
<li>2.领导者通过日志复制RPC，将新的日志项复制到其它的服务器</li>
<li>3.当领导者将日志项，成功复制到大多数服务器上的时候，领导者会将这条日志项提交到它的状态机中</li>
<li>4.领导者将执行的结果返回给客户端</li>
<li>5.当跟随者接收到心跳信息，或者新的日志复制RPC消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没提交，那么跟随者就将这条日志项提交到本地的状态机中</li>
</ul>
</li>
<li>Q:如何实现日志的一致？<ul>
<li>在Raft算法中，，领导者通过强制跟随者直接复制自己的日志项，处理不一致日志。即Raft是通过以领导者的日志为准，来实现各节点日志的一致的</li>
<li>1.领导者通过日志复制RPC的一致性检查，找到跟随者节点上，与自己想通日志项的最大索引值。即在这个索引值之前的日志，领导者和跟随者是一致的，之后的日志是不一致的了</li>
<li>2.领导者强制跟随者更新覆盖不一致的日志项，实现日志的一致</li>
</ul>
</li>
<li>Q:Raft实现日志的一致的详细过程<ul>
<li>引入2个新变量<ul>
<li>PrevLogEntry：表示当前要复制的日志项，前面一条日志项的索引值。如在图中，如果领导者将索引值为8的日志项发送给跟随者，那么此时 PrevLogEntry 值为7</li>
<li>PrevLogTerm：表示当前要复制的日志项，前面一条日志项的任期编号，如在图中，如果领导者将索引值为8的日志项发送给跟随者，那么此时PrevLogTerm值为4</li>
</ul>
</li>
<li><img src="https://img.shiqi-lu.tech/20210224170941.png"></li>
<li>1.领导者通过日志复制RPC消息，发送当前最新日志项到跟随者，这个消息的PrevLogEnetry值为7，PrevLogTerm值为4</li>
<li>2.如果跟随者在它的日志中，找不到与PrevLogEntry值为7、PrevLogTerm值为4的日志项，即它的日志和领导者的不一致了，那么跟随者者就会拒绝接收新的日志项， 并返回失败信息给领导者</li>
<li>3.这时，领导者会递减要复制的日志项的索引值，并发送新的日志项到跟随者，这个消息的 PrevLogEntry 值为 6，PrevLogTerm 值为 3</li>
<li>4.如果跟随者在它的日志中，找到了 PrevLogEntry 值为 6、PrevLogTerm 值为 3 的日志项，那么日志复制 RPC 返回成功，这样一来，领导者就知道在 PrevLogEntry 值为 6、PrevLogTerm 值为 3 的位置，跟随者的日志项与自己相同</li>
<li>5.领导者通过日志复制RPC，复制并更新覆盖索引值后的日志项(即不一致的日志项)，最终实现了集群各节点日志的一致</li>
<li>从上面步骤中可以看到，领导者通过日志复制 RPC 一致性检查，找到跟随者节点上与自己相同日志项的最大索引值，然后复制并更新覆盖该索引值之后的日志项，实现了各节点日志的一致。注意，跟随者中的不一致日志项会被领导者的日志覆盖，而且领导者从来不会覆盖或者删除自己的日志</li>
</ul>
</li>
</ul>
<h1 id="10-一致哈希算法：如何分群，突破集群的“领导者”限制？"><a href="#10-一致哈希算法：如何分群，突破集群的“领导者”限制？" class="headerlink" title="10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？"></a>10 | 一致哈希算法：如何分群，突破集群的“领导者”限制？</h1><ul>
<li>Q:使用哈希算法实现哈希寻址时，有什么问题？<ul>
<li>通过哈希算法，每个 key 都可以寻址到对应的服务器，比如，查询 key 是 key-01，计算公式为 hash(key-01) % 3 ，经过计算寻址到了编号为 1 的服务器节点 A</li>
<li><img src="https://img.shiqi-lu.tech/20210224172621.png"></li>
<li>但如果服务器数量发生变化，基于新的服务器数量来执行哈希算法的时候，就会出现路由寻址失败的情况，Proxy 无法找到之前寻址到的那个服务器节点</li>
<li>假如 3 个节点不能满足业务需要了，这时我们增加了一个节点，节点的数量从 3 变化为 4，那么之前的 hash(key-01) % 3 = 1，就变成了 hash(key-01) % 4 = X，因为 取模运算发生了变化，所以这个 X 大概率不是 1（可能 X 为 2），这时你再查询，就会找 不到数据了，因为 key-01 对应的数据，存储在节点 A 上，而不是节点 B</li>
<li><img src="https://img.shiqi-lu.tech/20210224172749.png"></li>
<li>同样的道理，如果我们需要下线 1 个服务器节点（也就是缩容），也会存在类似的可能查询不到数据的问题</li>
<li>而解决这个问题的办法，在于我们要迁移数据，基于新的计算公式 hash(key-01) % 4 ，来重新对数据和节点做映射。需要你注意的是，数据的迁移成本是非常高的</li>
<li>对于 1000 万 key 的 3 节点 KV 存储，如果我们增加 1 个 节点，变为 4 节点集群，则需要迁移 75% 的数据</li>
</ul>
</li>
<li>Q:如何使用一致哈希实现哈希寻址<ul>
<li>一致哈希算法是对 2^32 进行取模运算，将整个 哈希值空间组织成一个虚拟的圆环，即哈希环</li>
<li><img src="https://img.shiqi-lu.tech/20210224173010.png"></li>
<li>哈希环的空间是按顺时针方向组织的，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到 2^32-1，即 0 点左 侧的第一个点代表 2^32-1</li>
<li>在一致哈希中，通过执行哈希算法将节点映射到哈希环上，比如选择节点的主机名作为参数执行 c-hash()，那么每个节点就能确定其在哈希环上的位置了</li>
<li><img src="https://img.shiqi-lu.tech/20210224173309.png"></li>
</ul>
</li>
<li>Q:对指定 key 的值进行读写的时候，通过哪 2 步进行寻址？<ul>
<li>1.将key作为参数执行 c-hash() 计算哈希值，并确定此 key 在环上的位置</li>
<li>2.从这个位置沿着哈希环顺时针“行走”，遇到的第一节点就是 key 对应的节点</li>
<li><img src="https://img.shiqi-lu.tech/20210224175429.png"></li>
</ul>
</li>
<li>Q:有一个节点故障了(如节点C)，一致哈希是怎么处理的<ul>
<li><img src="https://img.shiqi-lu.tech/20210224175616.png"></li>
<li>key-01 和 key-02 不会受到影响，只有 key-03 的寻址被重定位到 A。一般来说，在一致哈希算法中，如果某个节点宕机不可用了，那么受影响的数据仅仅是，会寻址到此节点和前一节点之间的数据</li>
<li>如当节点 C 宕机了，受影响的数据是会寻址到节点 B 和节点 C 之间的数据（例如 key-03），寻址到其他哈希环空间的数据（例如 key-01），不会受到影响</li>
</ul>
</li>
<li>Q:需要扩容一个节点，一致哈希是怎么处理的<ul>
<li><img src="https://img.shiqi-lu.tech/20210224175729.png"></li>
<li>key-01、key-02 不受影响，只有 key-03 的寻址被重定位到新节点 D。一般 而言，在一致哈希算法中，如果增加一个节点，受影响的数据仅仅是，会寻址到新节点和前 一节点之间的数据，其它数据也不会受到影响</li>
</ul>
</li>
<li>Q:在一致哈希中，客户端访问请求集中在少数的节点上，为什么会出现有些机器高负载，有些机器低负载的情况<ul>
<li>在一致哈希中，如果节点太少，容易因为节点分布不均匀造成数据访问的冷热不均，即大多数访问请求都会集中少量几个节点上</li>
<li><img src="https://img.shiqi-lu.tech/20210224175845.png"></li>
</ul>
</li>
<li>Q:如何通过虚拟节点解决冷热不均的问题？<ul>
<li>对每一个服务器节点计算多个哈希值，在每个计算结果位置上，都放置一个虚拟 节点，并将虚拟节点映射到实际节点。比如，可以在主机名的后面增加编号，分别计算 “Node-A-01”“Node-A-02”“Node-B-01”“Node-B-02”“Node-C01”“Node-C-02”的哈希值，于是形成 6 个虚拟节点</li>
<li><img src="https://img.shiqi-lu.tech/20210224180725.png"></li>
<li>增加了节点后，节点在哈希环上的分布就相对均匀了。这时，如果有访问请求寻址到“Node-A-01”这个虚拟节点，将被重定位到节点 A。这样我们就解决了冷热不均的问题</li>
</ul>
</li>
</ul>
<h1 id="11-Gossip协议：流言蜚语，原来也可以实现一致性"><a href="#11-Gossip协议：流言蜚语，原来也可以实现一致性" class="headerlink" title="11 | Gossip协议：流言蜚语，原来也可以实现一致性"></a>11 | Gossip协议：流言蜚语，原来也可以实现一致性</h1><ul>
<li>Q:Gossip的三板斧是什么？<ul>
<li>直接邮寄(Direct Mail)</li>
<li>反熵(Anti-entropy)</li>
<li>谣言传播(Rumor mongering)</li>
</ul>
</li>
<li>Q:直接邮寄是什么？<ul>
<li>直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。直接邮寄虽然实现起来比较容易，数据同步也很及时，但可能会因为缓存队列满了而丢数据。即只采用直接邮寄是无法实现最终一致性的</li>
</ul>
</li>
<li>Q:反熵是什么？<ul>
<li>集群中的节点，每隔段时间就随机选择某个其它节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性</li>
<li><img src="https://img.shiqi-lu.tech/20210224182702.png"></li>
<li>如上图，节点A通过反熵的方式，修复了节点 D 中缺失的数据</li>
<li>注意，因为反熵熵需要节点两两交换和比对自己所有的数据，执行反熵时通讯成本会很高，不建议频繁执行，可通过引入校验和(Checksum)等机制，降低需要对比的数据量和通讯消息</li>
<li>执行反熵时相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境，这时反熵就不适用了，该用谣言传播</li>
</ul>
</li>
<li>Q:反熵修复节点缺失数据的3种方式<ul>
<li>以下图中，2 个数据副本的不一致为例</li>
<li><img src="https://img.shiqi-lu.tech/20210224183252.png"></li>
<li>推：将自己的所有副本数据，推给对方，修复对方副本中的熵</li>
<li><img src="https://img.shiqi-lu.tech/20210224183330.png"></li>
<li>拉：拉取对方的所有副本数据，修复自己副本中的熵</li>
<li><img src="https://img.shiqi-lu.tech/20210224183401.png"></li>
<li>推拉：同时修复自己副本和对方副本中的熵</li>
<li><img src="https://img.shiqi-lu.tech/20210224183422.png"></li>
</ul>
</li>
<li>Q:谣言传播是什么？<ul>
<li>当一个节点有了新数据后，这个节点编程活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据</li>
<li><img src="https://img.shiqi-lu.tech/20210224182841.png"></li>
<li>如图，节点 A 向节点 B、D 发送新数据，节点 B 收到新数据后，变成活跃节点，然后节点 B 向节点 C、D 发送新数据。谣言传播非常具有传染性，它适合动态变化的分布式系统</li>
</ul>
</li>
</ul>
<h1 id="12-Quorum-NWR算法：想要灵活地自定义一致性，没问题！"><a href="#12-Quorum-NWR算法：想要灵活地自定义一致性，没问题！" class="headerlink" title="12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！"></a>12 | Quorum NWR算法：想要灵活地自定义一致性，没问题！</h1><ul>
<li>Q:最终一致性和强一致性有什么区别<ul>
<li>强一致性能保证写操作完成后，任何后续访问都能读到更新后的值</li>
<li>最终一致性只能保证如果对某个对象没有新的写操作了，最终所有后续访问都能读到相同的最近更新的值，即写操作完成后，后续访问可能会读到旧数据</li>
</ul>
</li>
<li>Q:Quorum NWR的三要素<ul>
<li>N：副本数，又叫复制因子(Replication Factor)</li>
<li>W：写一致性级别(Write Consistency Level)，表示成功完成W个副本更新，才完成写操作</li>
<li>R：读一致性级别(Read Consistency Level)，表示读取一个数据对象时需要读R个副本，即，读取指定数据时，要读 R 副本，然后返回 R 个副本中最新的那份数据</li>
<li>注意：无论客户端如何执行读操作，哪怕它访问的是写操作未强制更新副本数据的节点（比如节点 B），但因为 W(2) + R(2) &gt; N(3)，也就是说，访问节点 B，执行读操作时，因为要读 2 份数据副本，所以除了节点 B 上的 DATA-2，还会读取节点 A 或节点 C 上的 DATA-2，就像上图的样子（比如节点 C 上的 DATA-2），而节点 A 和节点 C 的 DATA-2 数据副本是强制更新成功的。这个时候，返回给客户端肯定是最新的那份数据</li>
</ul>
</li>
<li>Q:N、W、R 值的不同组合，会产生哪两种不同的一致性效果？<ul>
<li>当 W + R &gt; N 时，对于客户端来说，整个系统能保证强一致性，一定能返回更新后的那份数据</li>
<li>当 W + R &lt; N 时，对于客户端来说，整个系统只能保证最终一致性，可能会返回旧数据</li>
</ul>
</li>
<li>Q:any、one、quorum、all 这4种写一致性级别，具体的含义<ul>
<li>any：任何一个节点写入成功后，或者接收节点已将数据写入Hinted-handoff缓存(即写其他节点失败后，本地节点上缓存写失败数据的队列) 后，就会返回成功给客户端</li>
<li>one：任何一个节点写入成功后，立即返回成功给客户端，，不包括成功写入到 Hinted-handoff 缓存</li>
<li>quorum：当大多数节点写入成功后，就会返回成功给客户端。此选项仅在副本数大于 2 时才有意义，否则等效于 all</li>
<li>all：仅在所有节点都写入成功后，返回成功</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸语法13-15课</title>
    <url>/gramma13-15/</url>
    <content><![CDATA[<h1 id="13-如何用好比较结构"><a href="#13-如何用好比较结构" class="headerlink" title="13.如何用好比较结构"></a>13.如何用好比较结构</h1><h2 id="比较句，其实并不是状语从句，而是一种特殊的并列句"><a href="#比较句，其实并不是状语从句，而是一种特殊的并列句" class="headerlink" title="比较句，其实并不是状语从句，而是一种特殊的并列句"></a>比较句，其实并不是状语从句，而是一种特殊的并列句</h2><ul>
<li>Mary <code>is beautiful</code> and Lucy <code>is beautiful</code> too.</li>
<li>这是一个并列句，两句话的系表部分都是”is beautiful”</li>
<li>那么，如果你要表达：“Mary和Lucy一样漂亮”，就称为<code>原级比较</code>:</li>
<li>Mary is <code>as beautiful as</code> Lucy (is beautiful).</li>
<li>前面一个as是副词，后面一个as才是连词，括号里边的部分和前面的分句相同，故通常省略。</li>
<li>如果你要表达:“Mary比Lucy漂亮”， 就称为<code>一般比较</code>:</li>
<li>Mary <code>is more beautiful</code> than Lucy.</li>
</ul>
<h2 id="原级比较：as-副词-形容词或副词的原级…as-连词-…"><a href="#原级比较：as-副词-形容词或副词的原级…as-连词-…" class="headerlink" title="原级比较：as(副词)+形容词或副词的原级…as (连词) …"></a>原级比较：as(副词)+形容词或副词的原级…as (连词) …</h2><ul>
<li>概述<ul>
<li>出现在“as…as…”(和…一样)的句子中，第一个as为副词，第二个as为副词连词，引导比较状语从句</li>
<li>此时，整个比较结构，可以作表语，定语（形容词比较），也可以作状语（副词比较）</li>
<li>在否定句中，也可用“not so…as…”<ul>
<li>He is handsome.</li>
<li>John is handsome.</li>
<li>可合并为：He is as handsome as John is handsome</li>
<li>为了避免重复，第二个as后面相同的部分(动词及动词以后的词)均可省略。如果后面的主语是代词时，书面语用主格，但是口语可使用宾格。</li>
<li>故这句话可改为:</li>
<li>He is as handsome as John. 他和约翰一样帅!</li>
</ul>
</li>
<li>在书面语中，尤其是主语为代词时，为了避免选择主格/宾格的麻烦，最好不要省略比较连词后面的动词（口语中可省略）</li>
<li>He is as handsome as John <code>is</code></li>
<li>He is as handsome as you <code>are</code></li>
<li>He is as handsome as I <code>am</code></li>
</ul>
</li>
<li>形容词原级比较<ul>
<li>Pigs are <code>as clever as monkeys and dolphins.</code> (表语比较) 猪和猴子以及海豚一样聪明。</li>
<li>People are <code>not so honest as they once were.</code> (表语比较) 人们不再像以前那样诚实了。</li>
<li>注:形容词后可接名词(定语比较)<ul>
<li>Jane is <code>as a beautiful girl as</code> Mary. 简和玛丽一样是个漂亮女孩。</li>
</ul>
</li>
</ul>
</li>
<li>副词原级比较<ul>
<li>David works <code>as hard as</code> Bill. 大卫和比尔一样努力。</li>
<li>Mary reads <code>as much as</code> Tony watches television. 玛丽看书的时间和托尼看电视的时间一样多。</li>
<li>I can’t keep a secret <code>as long as</code> he/him. 我不能像他一样保守那么久的秘密</li>
</ul>
</li>
<li>尽量…：as + adj./adv. + as possible/one can<ul>
<li>You should be <code>as careful as you can</code> when driving. = You should be <code>as careful as possible</code> when driving. 你开车要尽量小心。</li>
<li>The woman kept <code>as near as she could</code> to the children and even tried to get into the case herself, but it was too small. 这位妇女尽可能地靠近孩子，甚至自己也想钻进箱子里去，只是箱子太小了。</li>
</ul>
</li>
<li>极为…：be as + adj. + as can be<ul>
<li>That girl is <code>as beautiful as can be.</code> 那个女孩子美丽极了。</li>
</ul>
</li>
<li>和往常一样…：as + adj./adv. + as ever + as one used to be<ul>
<li>I rang the bell and was not surprised to see that Herbert was still <code>as fat as ever.</code>  我按响了门铃，当看到休仍和往常一样胖时，我并不感到惊奇。</li>
<li>Jack is working <code>as hard as ever.</code> 杰克和往常一样努力工作。</li>
<li>Jay Chou is <code>not so popular as he used to be.</code> 周杰伦没有以前那么红了。</li>
</ul>
</li>
<li>多达…：as many as + 数字 + 复合名词<ul>
<li><code>As many as</code> 20,000 people were killed or missing in a massive tsunami in Japan on March 11, 2011. 多达2万人在2011年3月11日的日本大海啸中丧生和失踪。</li>
<li>注：修饰金额时，一律用as much as</li>
<li>I have <code>as much as</code> 100 dollars with me. 我身上多达100美元。</li>
<li>类似搭配有：as long as长达，as wide as宽达，as high as高达</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.要想把英文学好，你应该尽量多看英文文章。<ul>
<li>1.To learn English well, you should read as many English articles as possible.</li>
</ul>
</li>
<li>2.我每次见到大卫，他都像蜜蜂一样忙着工作。<ul>
<li>2.Whenever I see David, he is as busy working as a bee.</li>
</ul>
</li>
<li>3.彼得或许没有玛丽那么聪明，但是他勤奋(hardworking)极了。<ul>
<li>3.Peter may be not so/as clever as Mary, but he is as hardworking as can be.</li>
</ul>
</li>
<li>4.这名歌手不像以前那么受欢迎了。<ul>
<li>4.The singer is not so/as popular as he used to be.</li>
</ul>
</li>
<li>5.估计多达10万名考生将参加新托福考试。<ul>
<li>5.It is estimated that as many as one hundred thousand candidates will take the IBT.</li>
</ul>
</li>
<li>6.我学英文长达十年之久。<ul>
<li>6.I’ve been learning English as long as ten years.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="比较级比较-一般-：形容词或副词的比较级…than-连词-…"><a href="#比较级比较-一般-：形容词或副词的比较级…than-连词-…" class="headerlink" title="比较级比较(一般)：形容词或副词的比较级…than (连词)…"></a>比较级比较(一般)：形容词或副词的比较级…than (连词)…</h2><ul>
<li>概述<ul>
<li>情况一<ul>
<li>1.A is beautiful.</li>
<li>2.B is beautiful.</li>
<li>如果要表达“A比B更漂亮”，就需要将上面两个句子合并:</li>
<li>A is more beautiful than B is beautiful.</li>
<li>A is more beautiful than B is.</li>
<li>A is more beautiful than B.</li>
<li>那么问题来了，than后面的句子，动词is省略好还是不省略好呢?</li>
<li>很简单，than后 面的句子中的动词和前面完全一致， 那就可以省略，但是如果<code>不一致</code>，比如is变成了am, are, was, were等形式，那就不能省略。如果是一般动词，应以do, does, did代替)。</li>
<li>Mary is more beautiful than Jane.</li>
<li>John is more handsome than I <code>am</code>.</li>
</ul>
</li>
<li>情况二<ul>
<li>1.I like her.</li>
<li>2.You like her.</li>
<li>如果要表达“我比你更喜欢她”，那么两句合并:</li>
<li>I like her more than you like her.</li>
<li>此时，如果省略动词: I like her more than you. (意思是我喜欢她胜过喜欢你)</li>
<li>那么，就出现歧义了，到底是“我比你更喜欢她”还是“我更喜欢她而不喜欢你呢?因为“you”既可能是主格也可能是宾格。事实上，英文中所有的实义名词都是“主格”与“宾格”相同的。</li>
<li>所以，上面的句子应该写成: I like her more than you do. (我比你更喜欢她)</li>
</ul>
</li>
</ul>
</li>
<li>形容词一般比较<ul>
<li>Bill Frith’s garden is <code>larger than Joe&#39;s</code>. 比尔.弗里斯的花园比乔的花园大。</li>
<li>Wisdom is <code>more precious than wealth.</code> 智慧比财富更宝贵。</li>
<li>Athlete need to consume <code>much more food than the average person.</code> 运动员比一般人需要消耗更多的食物。</li>
<li>Taking a beautiful fall is <code>better than wondering aimlessly</code>. 华丽的跌倒，胜过无谓的徘徊。</li>
<li>Indifference and neglect often do <code>much more damage than outstraight dislike</code>. 冷漠和忽视经常比直接的憎恨伤害更大。(J.K .Rowling名言)</li>
</ul>
</li>
<li>副词一般比较<ul>
<li>Bill works <code>harder than Joe</code> and grows more flowers and vegetables, but Joe’s garden is more interesting. 他比乔也更为勤奋，种植的花卉和蔬菜也更多，但乔的花园更富有情趣。</li>
<li>Actions speak <code>louder than words.</code> 行动胜于空谈。</li>
<li>比较级可以被副词much, even, still, far, a lot修饰，表示”…得多”，或者a bit, a little修饰，表示“…一点点”。</li>
<li>比较级前面加上all the，表示“更加…”，是一种强调，相当于even, much<ul>
<li>The food was <code>all the</code> more delicious because we were hungry. = The food was <code>even/much</code> more delicious because we were hungry. 因为我们饿了，食物就更加美味可口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="准关系代词as-than-but引导的定语从句"><a href="#准关系代词as-than-but引导的定语从句" class="headerlink" title="准关系代词as, than, but引导的定语从句"></a>准关系代词as, than, but引导的定语从句</h2><ul>
<li>概述<ul>
<li>对比两个句子:</li>
<li>1.我们了解到<code>他通过了考试。</code></li>
<li>2.<code>正如我们了解到的那样</code>，他通过了考试。</li>
<li>我们会发现，上面两句话其实是同一个意思。英语中，也有和上面完全对应的说法:</li>
<li>1.We learned <code>that he passed the exam.</code></li>
<li>2.<code>As we learned,</code> he passed the exam.</li>
</ul>
</li>
<li>as引导的定语从句<ul>
<li>概述<ul>
<li>传统语法认为：as通常 用于引导非限定性定语从句，此时as代替整个主句，相当于which。这种说法显然比较牵强附会，造成很多英语学习者理解困难。其实这种句型同样属于比较状语从句，只不过as后面省略了复合关系代词what，只要知道了这点，马上就能理解了。</li>
<li><code>As (what / the thing that) I soon learnt,</code> he was English himself! 我很快了解到，他自己就是个英国人!</li>
<li>主动式：<code>As I soon learnt</code>, he was English himself.</li>
<li>被动式：<code>As was soon learnt (by me),</code> he was English himself.</li>
<li>注意，本从句的谓语动词必须是及物动词！！而且主句必须是这个及物动词<code>逻辑上的宾语</code></li>
<li>上一句话，learn是及物动词，后面的主句he was English himself. 刚好就是learn的逻辑宾语</li>
</ul>
</li>
<li>例句<ul>
<li>But <code>as they soon discovered,</code> disguises can sometimes be too perfect. 但他们很快就发觉，化装的效果有时过分完美了。</li>
<li>Anyway, <code>as Brian pointed out,</code> it is the easiest thing in the world to give up smoking. 不管怎么说，正如布赖恩指出的那样，戒烟是世界上最容易的事情。</li>
<li><code>As is known to us all,</code> the whale is not fish but mammal. 就像我们都知道的一样，鲸不是鱼类而是哺乳动物。</li>
<li>She was married again, <code>as was expected.</code>她又结婚了，正如人们预料的一样。</li>
<li><code>As is reported,</code> it is 100 years since Tsing University was founded. 正如报道的那样，清华大学建校已经有100年历史了。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.正如她工作表现出的一样，她很细心。<ul>
<li>1.She is very careful, as her work shows.</li>
</ul>
</li>
<li>2.就像我们猜测的一样，这个调皮的学生没有通过考试。<ul>
<li>2.As we guessed, the naughty student didn’t pass the exam.</li>
</ul>
</li>
<li>3.正如常常被指出的，知识是一把双刃剑，可以同等地用于造福和作恶。<ul>
<li>3.As is so often pointed out, knowledge is a two-edged weapon which can be used equally for good or evil.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>that引导的定语从句<ul>
<li>概述<ul>
<li>先看这句话:</li>
<li>He smoked more cigarettes <code>than</code> were normally available. 他吸的香烟比他弄到的要多。</li>
<li>如果按照传统语法把than看成关系代词，是很难理解的。但是，只要我们按照下面的方式理解，就是一目了然了:</li>
<li>He smoked more cigarettes than (what) were normally available.</li>
<li>这里，than后面省略 了复合关系代词what,这样理解，立刻就能符合我们的正常思维方式。</li>
</ul>
</li>
<li>例句<ul>
<li>Don’t drink more wine than is good for health. 不要过量饮酒，适量饮酒有益于健康。</li>
<li>I have more money than he needs. 我的钱比他需要的多。</li>
<li>He is a good student than you are. 他是个好学生，比你还好。</li>
<li>The manufacturers had to pay more money than they had anticipated, for they bought the biscuit from the student for $24,000. 饼干公司不得不付出比他们预计多得多的钱，因为为买下那学生烘制的饼干他们支付了24,000美元。</li>
<li>To compensate for his unpleasant experiences in hospital, the man drank a little more than was good for him. 为了补偿住院这一段不愉快的经历，那人喝得稍许多了一点。</li>
<li>It seems that man was making a real effort to understand the seasons 20,000 years earlier than has been supposed. 看来人类早就致力于探索四季变迁了，比人们想象的要早20,000年。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.人们现在准备饭菜比以前容易多了。<ul>
<li>1.People today can prepare their meal much easier than has ever been before.</li>
</ul>
</li>
<li>2.父母最好别给孩子太多的钱，够用就行了。<ul>
<li>2.Parents had better not give kids more money than is needed.</li>
</ul>
</li>
<li>3.所以今天想在某一领域成为专业人士要比以前花费更长的时间。<ul>
<li>3.Therefore, to be a professional in a certain field today takes much longer time than has ever been before.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>but引导的定语从句<ul>
<li>but作为准关系代词引导定语从句，是一种少见的用法，且只引导<code>限定性定语从句</code>。而且要特别注意，but本身具有否定意义，故引导的定语从句具有<code>否定含义</code>。另外，but修饰的先行词，通常会被否定词修饰。且这个结构通常只能和there be句型搭配<ul>
<li>There is no man but errs.人必犯错。(but作主语，相当于There is no man who doesn’t err.)</li>
<li>There is nothing but he knows.没有他不知道的事情。(but作宾语，相当于There is nothing which he doesn’t know.)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.在场的人没人不知道这个故事<ul>
<li>1.There was no one present but knew the story already .</li>
</ul>
</li>
<li>2.没有不爱自己孩子的母亲<ul>
<li><ol start="2">
<li>There is no mother but loves her children.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="14-如何写好倒装句和强调句"><a href="#14-如何写好倒装句和强调句" class="headerlink" title="14.如何写好倒装句和强调句"></a>14.如何写好倒装句和强调句</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>所谓倒装句，就是改变句子主干的正常顺序，达到强调其中一部分内容的目的</li>
</ul>
<h2 id="否定倒装句"><a href="#否定倒装句" class="headerlink" title="否定倒装句"></a>否定倒装句</h2><ul>
<li>概述<ul>
<li>倒装的方法其实是：把否定副词后面的句子，变成一般疑问句语序</li>
<li>句中有be动词或者助动词的时候，将其与主语倒装</li>
<li>句中只有一般动词的时候，根据人称和时态在主语前加上do, does, did</li>
</ul>
</li>
<li>否定性质的副词<ul>
<li>never(从不)<ul>
<li><strong>Never</strong> <code>is he</code> happy. 他从不快乐。(原句是：He is never happy)</li>
</ul>
</li>
<li>hardly/scarcely(几乎不)<ul>
<li><strong>Hardly</strong> <code>is he</code> ever quiet. 他几乎从未安静过。(原句是: He is hardly ever quiet.)</li>
</ul>
</li>
<li>rarely/seldom(很少)<ul>
<li><strong>Rarely</strong> <code>does modern sculpture surprise</code> us any more. 现代雕塑再也不使我们感到惊讶了。(原句是：Modern sculpture rarely surprise us any more.)</li>
</ul>
</li>
<li>little/none(一点也不)</li>
<li>nowhere(哪里都不)</li>
</ul>
</li>
<li>否定性质的副词短语<ul>
<li>绝不：by no means, in no way, on no account, under no circumstances, in no situation<ul>
<li><code>By no means</code> are you the person we need. 你绝非我们需要的人。(原句: You are by no means the person we need. )</li>
<li><code>In no way</code> am I responsible for what has happened. 我决不对发生的事情负责。(原句是: I am in no way responsible for what has happened. )</li>
</ul>
</li>
<li>not until/only + 副词性质的短语或从句：直到…/就在…<ul>
<li><code>Not until</code> John arrived <code>did I</code> leave.直到约翰到了之后我才离开。(原句: I did not leave until John arrived. )</li>
<li><code>Only</code> in a sparsely-populated rural community <code>is it</code> possible to disregard it. 只有在人口稀少的农村，才可以忽视它。(原句: It is possible to disregard it only in a sparsely-populated rural community. )</li>
</ul>
</li>
<li>并列句里面的not only…but(also/…as well)（不仅…而且…）句型，在<code>连接两个完整的句子</code>时，要使用倒装。注：第二个句子不倒装，但also要省略<ul>
<li><strong>Not only</strong> <code>was the meal</code> well below the usual standard, but Bessie seemed unable to walk steadily.不仅饭菜远不如平时做得好，而且贝西走起路来似乎东倒西歪。(原句是：The meal was not only well below the …..)</li>
<li><strong>Not only</strong> <code>had the poor man</code> been arrested, but he had been sent to prison as well. 那个可怜的记者不仅被捕了，而且还被送进了监狱。(原句是：The poor man had not only been arrested, ….)</li>
</ul>
</li>
</ul>
</li>
<li>造句练习：(分别用正常语序和倒装)<ul>
<li>1.我很少晚上11点以后看电视。<ul>
<li>1.I seldom watch TV after 11:00 p. m.</li>
<li>Seldom do I watch TV after 11:00 p. m.</li>
</ul>
</li>
<li>2.我以前从没有想过玛丽会离开她的丈夫。<ul>
<li>2.I would never have guessed that Mary would leave her husband.</li>
<li>Never would I have guessed that Mary would leave her husband.</li>
</ul>
</li>
<li><ol start="3">
<li>你绝不会(by no means)找不到(have trouble finding)这座大楼的，因为它是全市最高的。<ul>
<li>3.You should by no means have trouble finding the building because it is the tallest in the city.</li>
<li>By no means should you have trouble finding the building because it is the tallest in the city.</li>
</ul>
</li>
</ol>
</li>
<li>4.只有在较浅的河段你才能涉水渡河。<ul>
<li>4.You can walk across the river only in the shallow part.</li>
<li>Only in the shallow part can you walk across the river.</li>
</ul>
</li>
<li>5.只有在他跟我说明问题时，我才了解我哪里错了。<ul>
<li>5.I can understand what I am doing wrong only when he explains the problems to me.</li>
<li>Only when he explains the problems to me can I understand what I am doing wrong.</li>
</ul>
</li>
<li>6.直到我抵达机场，才想起把护照忘在家里了。<ul>
<li>6.I did not remember that I had left my passport at home until I arrived at the airport.</li>
<li>Not until I arrived at the airport did I remember that I had left my passport at home.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="so-such倒装句"><a href="#so-such倒装句" class="headerlink" title="so/such倒装句"></a>so/such倒装句</h2><ul>
<li>形容词一般比较<ul>
<li>He is <code>so</code> helpful that we all like him. = <code>So</code> helpful <code>is he</code> that we all like him.他那么乐于助人，因此我们都很喜欢她。</li>
<li>He has done <code>so</code> well that he deserves our respect. = So well has he done that he deserves our respect.他做得那么好，所以值得我们尊敬。</li>
<li>Mrs. Sterling got <code>so</code> angry <code>that</code> she ran after them. = <code>So</code> angry <code>did Mrs. Sterling get</code> that she ran after them.斯特林夫人非常气愤，向着他们追了过去。</li>
<li>Peter is <code>such</code> an outstanding student <code>that</code> all the teachers that have taught him like him very much. = <code>Such</code> an outstanding student <code>is Peter that</code> all the teachers that have taught him like him very much.彼得是这么杰出的学生，以至于所有教过他的老师都非常喜欢她。</li>
</ul>
</li>
<li>so作为副词单独使用可表示“也”的意思，前面有连词and，后面的句子倒装<ul>
<li>I’m afraid of darkness, and my sister is, too. = I’m afraid of darkness, and so is my sister.我怕黑，我妹妹也是。</li>
</ul>
</li>
<li>造句练习：(分别用正常语序和倒装)<ul>
<li>1.彼得夫妇有这么好的女儿，使得我们都很羡慕他们。<ul>
<li>1.Mr. and Mrs.Peter have such a good daughter that I envy them.</li>
<li>Such a good son do Mr. and Mrs. Peter have that I envy them.</li>
</ul>
</li>
<li>2.这位老太太的生活如此悲惨，以至于我们都很同情(sympathize with)她。<ul>
<li>2.The old lady’ s life is so miserable that we all sympathize with him.</li>
<li>So miserable is the old lady S life that we all sympathize with him.</li>
</ul>
</li>
<li>3.很多年轻人喜欢周杰伦，我也是。<ul>
<li>3.Many young people like Jay Chou, and I do, too.</li>
<li>Many young people like Jay Chou, and so do I.</li>
</ul>
</li>
<li>4.奥巴马总统明天会来看我们，他老婆也会来。<ul>
<li>4.President Obama will be coming to see us tomorrow, and his wife will, too.</li>
<li>President Obama will be coming to see us tomorrow, and so will his wife.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="nor-and-neither倒装句"><a href="#nor-and-neither倒装句" class="headerlink" title="nor / and neither倒装句"></a>nor / and neither倒装句</h2><ul>
<li>nor和neither都表示“也不”，但nor是连词，而neither是副词，所以前面通常有连词and。（美语中有时也可省略）<ul>
<li>My girlfriend doesn’t like singing, and I don’t, either.</li>
<li>= My girlfriend doesn’t like singing, nor do I.</li>
<li>= My girlfriend doesn’t like singing, and neither do I.</li>
</ul>
</li>
<li>nor作为副词，还可以单独使用，表示“并非”<ul>
<li>Nor is it only the ignorant and ill-educated person who was such faith in the bottle of medicine.并不只是那些无知和没受过良好教育的人才迷信药瓶子</li>
<li>Nor is the city without its moments of beauty.城市也并非没有良辰美景</li>
</ul>
</li>
<li>造句练习：(分别用正常语序和倒装)<ul>
<li>1.我将不会出席明天的会议，我们老板也不会。<ul>
<li>1.I will not attend the meeting tomorrow, and our boss will not, either.</li>
<li>I wiII not attend the meet ing tomorrow, and neither will our boss .</li>
<li>I will not attend the meeting tomorrow, nor will our boss.</li>
</ul>
</li>
<li>2.这条消息也不是特别地令人吃惊。<ul>
<li>2.The news is not particularly surprising.</li>
<li>Nor is the news particularly surprising.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="副词倒装句"><a href="#副词倒装句" class="headerlink" title="副词倒装句"></a>副词倒装句</h2><ul>
<li>表示地点、方向、次序的副词放在句首，主语是名词，谓语是系动词或不及物动词的时候，必须倒装（主语是代词不倒装）<ul>
<li><strong>Up</strong> <code>came the sun</code> as we climbed to the mountain top. 太阳在我们爬到山顶时升起。(完全倒装)</li>
<li><strong>On the desk</strong> <code>is a book.</code> 桌上有本书(完全倒装)</li>
<li><strong>Among them</strong> <code>will be debbie&#39;s mother,</code> who swam the Channel herself when she was a girl. 他们当中还会有黛比的母亲，她本人还是个姑娘时，也曾横渡过英吉利海峡! (本句中 的mother被定语从句修饰，故倒装以后和紧邻定语从句，使句子主干更突出)</li>
<li><strong>Next</strong> <code>came a horse.</code> 随后来了一匹马。</li>
<li><strong>There</strong> <code>you have</code> it that’s the news for today.(不倒装)</li>
<li><strong>On the hill</strong> <code>I saw</code> Lulu.(不倒装)</li>
</ul>
</li>
<li>There be句型，其实是一种特殊的地点副词倒装句，翻译为“有…”，其本质是强调某种东西“存在”，be这时是一个不及物动词，相当于exist。而动词have的本质是强调“拥有”<ul>
<li><code>There is</code> only one happiness in this life, to love and to be loved.生命中只有一种情况叫幸福——爱和被爱。 (法国作家 乔治桑名言)</li>
<li><code>There will be</code> a large basketball match in our school next week.我们学校下周将有一场大型篮球比赛。</li>
<li><code>There have been</code> bicycles stolen from the parking lot recently. 最近停车场一直有自行车遭窃。</li>
<li>Many people wonder if <code>there might be</code> life in other galaxies.很多人想知道其它星系是否可能有生命存在。</li>
</ul>
</li>
<li>某些语法书说，have的主语是人，There be的主语是物*。这种说法显然是错误的。大家一定要记住：have是从属关系，there be仅仅强调某种东西“存在”，所以there be句型的主语一定是实体名词，而不能用抽象名词比如meeting, conversation等<ul>
<li>The house <code>has</code> many large rooms and there is a lovely garden.这栋房子里有许多房间，还有一个漂亮的花园。(本句里rooms属于house的组成部分，而garden属于house外的东西，故前面用has，后面用there is)</li>
</ul>
</li>
</ul>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><ul>
<li>普通强调句<ul>
<li>为了强调句中的某个成分，可以用下面两种句型</li>
<li>It is/was + 名词/代词 + who/whom/which引导的定语从句</li>
<li>It is/was + 副词/介词短语/状语从句 + that引导的名词从句<ul>
<li>Mary is visiting us tomorrow.玛丽明天来看我们。</li>
<li>=&gt; It is Mary who is visiting us tomorrow.明天来看我们的是玛丽。</li>
<li>I bought this watch yesterday.我昨天买了这块手表。</li>
<li>=&gt; It is this watch which I bought yesterday.我昨天买的就是这块手表。</li>
<li>I quit my job because I didn’t like the general manager.我辞职是因为我不喜欢总经理。</li>
<li>=&gt; It was because I didn’t like the general manager that I quit my job.我是因为不喜欢总经理才辞职的。</li>
<li>The tree was planted near a church fifty years ago, but it has gained an evil reputation only in recent years.该树是50年前栽在教堂附近的，但近几年得到了一个坏名声。</li>
<li>=&gt; The tree was planted near a church fifty years ago, but it is only in recent years that it has gained an evil reputation. 该树是50年前栽在教堂附近的，但只是近几年才得到了一个坏名声。</li>
</ul>
</li>
</ul>
</li>
<li>注：强调句中的It is /was…who/whom/which/that在句子中不作任何成分，这是与it作形式主语的句型的区别</li>
<li>一般疑问句的强调：把is/was提到it前面</li>
<li>特殊疑问句的强调：疑问句+一般疑问句的强调句<ul>
<li><code>Was it</code> yesterday <code>that</code> he met president Obama?他是昨天遇到奥巴马总统的吗?</li>
<li><code>What is it that</code> makes a person so special?使一个人与众不同的究竟是什么呢?</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我是在公园里遇到玛丽的。<ul>
<li>1.It was in the park that I ran into Mary.</li>
</ul>
</li>
<li>2.我是为了我的健康的缘故放弃这份待遇优厚的工作的。<ul>
<li>2.It was for the sake of my health thatI gave up this well-paying job.</li>
</ul>
</li>
<li>3.是直到昨天你才完成这个工作的吗?<ul>
<li>3.Was it until yesterday that you finished the work?</li>
</ul>
</li>
<li>4.究竟是哪个国家赢得了2010年世界杯呢?<ul>
<li>4.Which country was it that won the World Cup in 2010?</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="15-介词省略句型"><a href="#15-介词省略句型" class="headerlink" title="15.介词省略句型"></a>15.介词省略句型</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>先看几个汉语句子<ul>
<li>1、我<code>确信</code>他无法通过考试。</li>
<li>2、我很<code>高兴</code>你来参加我们的宴会。</li>
<li>3、我<code>恐怕</code>他不会来了。</li>
<li>4、我很<code>抱歉</code>这么晚打扰你。</li>
</ul>
</li>
<li>在汉语中是表示人的心理活动，应该是谓语动词，后面的句子是宾语</li>
<li>但是在英语中，并没有对应心理活动的动词，而是对应的表示心理活动的形容词: sure, glad, afraid, or….等等，我们将其称之为“主观形容词”</li>
<li>所以，需要一个固定搭配：be+主观形容词+ about/ of</li>
</ul>
<h2 id="后接名词"><a href="#后接名词" class="headerlink" title="后接名词"></a>后接名词</h2><ul>
<li>I <code>am</code> terribly <code>sorry about</code> that.听说这事我很难过。</li>
</ul>
<h2 id="后接动名词短语"><a href="#后接动名词短语" class="headerlink" title="后接动名词短语"></a>后接动名词短语</h2><ul>
<li>She <code>is tired of</code> doing her homework.她对写作业感到很厌倦.</li>
<li>John <code>has been aware of</code> having done something wrong.约翰已意识到自己做错了事</li>
</ul>
<h2 id="后接名词从句"><a href="#后接名词从句" class="headerlink" title="后接名词从句"></a>后接名词从句</h2><ul>
<li>只有whether从句和疑问句从句，才能直接作介词的宾语<ul>
<li>I am worried <strong>about</strong> <code>whether he can do it.</code> 我很担心他是否能做这件事。</li>
<li>I’m curious <strong>about</strong> <code>how he&#39;ll cope with the problem.</code> 我很好奇他将如何应付这个问题。</li>
</ul>
</li>
<li>介词后如果要用that从句，那么此时要省略介词about/of，其实这样的结构，就是去掉了介词about或of的宾语从句<ul>
<li>I am worried about that he plays around all day. (X)这句话应该为：I am worried that he plays around all day.</li>
<li>Sam <strong>was sure</strong> <code>that the wallet must have been found by one of the villagers</code>, but it was not returned to him. 萨姆确信那钱包一定是被某个村民捡到了，可是却不见有人来送还给他。</li>
<li>They <strong>were</strong> also quite <strong>sure</strong> <code>that a cigarette end did not start the fire.</code> 他们还十分肯定火灾也不是由烟头引起的。</li>
<li>My wife <strong>was delighted</strong> <code>that things had returned to normal once more.</code> 一切又都恢复了正常，为此我妻子十分高兴。</li>
<li><strong>I’m afraid</strong> <code>that I can&#39;t help you this time.</code> 恐怕这次我不能帮你了。</li>
</ul>
</li>
<li>此时还可用<code>介词+ the fact + that从句</code>，此时that从句为同位语从句。或将that从句化简为动名词短语<ul>
<li>如表达：</li>
<li>我确定这支队赢了这场比赛。I am sure of that the team has won the game. (X)</li>
<li>应改为：</li>
<li>I am sure of <strong>the fact</strong> <code>that the team has won the game.</code></li>
<li>I am sure of <code>the team&#39;s winning the game.</code></li>
</ul>
</li>
</ul>
<h2 id="后接不定式"><a href="#后接不定式" class="headerlink" title="后接不定式"></a>后接不定式</h2><ul>
<li>After his attempt, Campbell <strong>was disappointed</strong> <code>to learn that his average speed had been 299 miles per hour.</code> 比赛结束后，坎贝尔非常失望地得知他的平均时速是299英里。</li>
<li>I <strong>was excited</strong> <code>to receive a letter</code> from my girlfriend in Australia. 我很兴奋，因为我收到澳洲的女朋友给我的信。</li>
<li>以上的例句中，不定式的逻辑主语都是句子的主语</li>
</ul>
<h2 id="5个特殊形容词"><a href="#5个特殊形容词" class="headerlink" title="5个特殊形容词"></a>5个特殊形容词</h2><ul>
<li>easy/difficult/hard/possible/impossible，表示：做某事容易/很难/可能/不可能，其后的不定式，形式是主动的，但是意思是被动的<ul>
<li>He is <code>easy</code> to please.他很容易被取悦。</li>
<li>He is <code>difficult</code> to fool.他不容易受骗。</li>
<li>This book is hard to understand.这本书很难被理解。(绝对不能说: This book is hard to be understood.(X)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸语法4-6课</title>
    <url>/gramma4-6/</url>
    <content><![CDATA[<h1 id="4-被动语态的重难点——不完全及物动词和授予动词补充"><a href="#4-被动语态的重难点——不完全及物动词和授予动词补充" class="headerlink" title="4.被动语态的重难点——不完全及物动词和授予动词补充"></a>4.被动语态的重难点——不完全及物动词和授予动词补充</h1><ul>
<li>第四大句型，主谓宾补，其实就是“让某人做某事”<ul>
<li>My mother made me wash the car.</li>
<li>宾语是“我”，宾补是“洗车”，也就是说，宾语和宾补放在一起，逻辑上可以构成一个句子“我洗车”。</li>
<li>宾语和宾补之间的关系是被动语态呢?</li>
<li>他让这个任务完成了。</li>
<li>如果按照造句规律，应该是: He made this task be finished.或者He get this task to be finished.</li>
<li>宾补中，出现的be或者to be，通常要省略！所以，这句话应该说成: He made this task finished.</li>
</ul>
</li>
<li>英语中还有什么时候会出现be动词呢?<ul>
<li>除了被动语态(过去分词作表语)之外，还有主系表句型(be动词后面的名词作表语，形容词作表语，地点副词作表语)</li>
</ul>
</li>
<li>使役动词+宾语+过去分词（补语）<ul>
<li>Now a group of students will have the plane restored.一群学生计划修复这架飞机。</li>
<li>Officials have the clock checked twice a day.官员们每天两次派人检查此钟。</li>
</ul>
</li>
<li>使役动词+宾语+名词、形容词或地点副词<ul>
<li>使役动词也可加名词、形容词或地点副词等作补语，其原因是前面省略了不定式be或to be。<ul>
<li>His teacher made him a good student. (名词作宾补)他的老师使他成为好学生。</li>
<li>The trip made him happy.(形容词作宾补)这次旅行使他很愉快。</li>
<li>He let me in. (地点副词作宾补)他让我进来。</li>
<li>Get him out of here. (介词短语，相当于地点副词)把他弄出去!</li>
</ul>
</li>
</ul>
</li>
<li>各种不完全及物动词：接上宾语后意思仍然不完整<ul>
<li>让某人做某事，只能接不定时作宾语补语：ask、encourage、tell、push、expect、want、drive/force/oblige/compel、order、cause/urge<ul>
<li>The postman <code>wanted</code> me to sign for a letter!邮递员要我签收一封挂号信!</li>
<li>Last week at a dinner-party, the hostess <code>asked</code> me to sit next to Mrs. Rumbold.在上星期的一次宴会上，女主人安排我坐在兰伯尔德夫人的身旁。</li>
<li>Byrd at once <code>ordered</code> his men to throw out two heavy food sacks.伯德马上命令他的助手们把两个沉重的食物袋扔掉。</li>
<li>My dentist had <code>told</code> me to rest for a while.我的牙科医生叫我休息一会儿。</li>
<li>My old friend Brian <code>urged</code> me to accept a cigarette.我的老朋友布赖恩极力劝我接受一枝香烟。</li>
</ul>
</li>
<li>知觉动词（5看，2听，1感觉）：感觉：feel，听：hear, listen to，看：see, observe, watch, look at, notice<ul>
<li>表事实：此类动词+宾语+动词原形(补语)，译为”……..了。”<ul>
<li>I <code>saw</code> him dance.我看见他跳舞了。</li>
<li>I <code>heard</code> him sing.我听见他唱歌了。</li>
</ul>
</li>
<li>表进行状态：此类动词+宾语+现在分词(补语)，译为”…..正在……”<ul>
<li>Early next morning, she <code>heard</code> planes passing overhead. 第二天一大早，她听到头顶上飞机正在盘旋。</li>
<li>The pilot <code>saw</code> one of the men taking photographs.当气球飞临基地上空时，飞行员看见有一个人在拍照。</li>
</ul>
</li>
<li>表被动状态：此类动词+宾语+过去分词(补语)，译为”…..被…..”<ul>
<li>I <code>saw</code> him killed.我看见他被杀了。</li>
</ul>
</li>
</ul>
</li>
<li>认定动词：视…为…；认为…是…：动词 + 宾语 + 介词as + 名词或形容词(补语)<ul>
<li>regard<ul>
<li>In spite of this, the Italians <code>regarded</code> him <code>as</code> a sort of hero.尽管如此，意大利人还是把他视作某种英雄。</li>
</ul>
</li>
<li>look upon<ul>
<li>His students all <code>look upon</code> him <code>as</code> a friend.他的学生都把他看成是朋友。</li>
</ul>
</li>
<li>think of<ul>
<li>They <code>think of</code> themselves <code>as</code> the salt of the earth.他们自认为是社会中坚。</li>
</ul>
</li>
<li>see<ul>
<li>I’d like to <code>see</code> Europe <code>as</code> a nuclear-free zone.我希望欧洲成为无核区。</li>
</ul>
</li>
<li>view<ul>
<li>We <code>view</code> every customer <code>as</code> a partner.我们将每一位客户视为合作伙伴。</li>
</ul>
</li>
</ul>
</li>
<li>认定动词：视…为…；认为…是…：动词 + 宾语 + (to be) + 名词或形容词(补语)：consider, deem, think, find, believe<ul>
<li>He is <code>finding</code> his new work far more exciting.他发觉自己的新工作令人兴奋得多。</li>
<li>I <code>found</code> his advice really useful.我发现他的建议非常有用。</li>
<li>People <code>think</code> this problem determination.人们认为这个问题解决了。</li>
</ul>
</li>
<li>转变动词：使…变成…：change/turn + 宾语 + into + 名词(补语)<ul>
<li>I need to change my dollars into francs.我需要把美金换成法郎。</li>
<li>The experience turned him into a good student.这个经验使他变成了好学生。</li>
</ul>
</li>
<li>call/name + 宾语 + 名词(补语)<ul>
<li>‘Do you call that a hat?’ I said to my wife.“你把那个叫帽子吗?”我对妻子说。</li>
<li>You can name your pet dog Doctor.你可以把你的狗狗取名为博士。</li>
</ul>
</li>
<li>help后接不定式(to可省略) 作宾语补语。<ul>
<li>A short while ago, my sister helped me to carry my old bookcases up the stairs.几分钟前，我妹妹帮我把我的旧书橱抬上了楼。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.店员看见这个衣着很好的妇女正在偷东西。<ul>
<li>1.The shop assistant saw the well-dressed woman stealing something.</li>
</ul>
</li>
<li>2.你能帮我洗衣服吗?<ul>
<li>2.Can you help me to wash clothes?</li>
</ul>
</li>
<li>3.作为老师，你应该鼓励你的学生努力学习。<ul>
<li>3.As a teacher, you should encourage your students to study hard.</li>
</ul>
</li>
<li>4.父母不应该期望他们的孩子做任何事都成功。<ul>
<li>4.The parents should not expect their children to succeed in doing everything.</li>
</ul>
</li>
<li>5.你应该命令这个计划在一个月内完成。(order)<ul>
<li>5.You should order this project to finished within a month.</li>
</ul>
</li>
<li>6.我发现我们的老师被警察逮捕了。<ul>
<li>6.I found our teacher arrested by the police.</li>
</ul>
</li>
<li>7.工人们明天将把墙刷成绿色。<ul>
<li>7.The workers will paint the wall green.</li>
</ul>
</li>
<li>8.女主人邀请我们进去。<ul>
<li>8.The hostess invited us in.</li>
</ul>
</li>
<li>9.我们认为这个男人处于危险中。<ul>
<li>9.We considered the man in danger.</li>
</ul>
</li>
<li>10.大部分人把他当作英雄。<ul>
<li>10.Most people regarded him as a hero.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>特殊的授予动词<ul>
<li>间接宾语与直接宾语位置可以倒置，此时需要加介词to, for, of。<ul>
<li>表“给予”的概念，要用to<ul>
<li>My holidays passed quickly, but I did not send any cards <code>to</code> my friends.假期过得真快，可我还没有给我的朋友们寄过一张明信片。</li>
</ul>
</li>
<li>表“代劳”的概念(buy等) ，要用for<ul>
<li>I bought a book <code>for</code> him.我为他买了一本书</li>
</ul>
</li>
<li>ask要用of<ul>
<li>I asked a question <code>of</code> him.我问了他一个问题。</li>
</ul>
</li>
</ul>
</li>
<li>下列授予动词与of连用<ul>
<li>1.rob 抢夺<ul>
<li>He robbed me of my money.他抢了我的钱。</li>
<li>注:中式思维容易说成He robbed my money. (X) 这是绝对错误的!</li>
</ul>
</li>
<li>2.deprive 剥夺(权利)<ul>
<li>This law will deprive us of our most basic rights.这条法律将剥夺我们最基本的权利。</li>
</ul>
</li>
<li>3.cure 治愈<ul>
<li>The teacher cured him of bad habits.老师纠正了他的坏习惯。</li>
</ul>
</li>
<li>4.relieve 减轻<ul>
<li>It will relieve her of a tremendous burden. 这将给她解决一个巨大的负担。</li>
</ul>
</li>
<li>5.remind 提醒<ul>
<li>I continually have to remind him of his responsibilities.我得一再提醒他记住他的责任。</li>
</ul>
</li>
</ul>
</li>
<li>表“提供”概念的授予动词provide, furnish, supply必须与介词with连用。(但双宾语倒置的时候任然用to，for)<ul>
<li>He provided me with a lot of money.他提供给我很多钱。</li>
<li>The present conflict may provide fresh impetus for peace talk.目前的冲突可能会给和谈提供新的推动力。</li>
<li>The school doesn’t furnish students with lunch.学校不供给学生午饭。</li>
<li>The gas station usually supplies its nearby communities with gas.这个加油站通常为附近的社区提供汽油。</li>
<li>We supply power to the three nearby towns.我们对附近的三个城镇提供电力。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.这个著名的歌手给我们演唱了一首流行歌曲。<ul>
<li>1.The famous singer sang us a popular song.</li>
</ul>
</li>
<li>2.这座新桥带给当地人极大的方便。<ul>
<li>2.The new bridge brings the local people the great convenience.</li>
</ul>
</li>
<li>3.你不能剥夺她的权利。<ul>
<li>3.You can’t deprive her of her rights.</li>
</ul>
</li>
<li>4.这张照片使我想起了我们在夏令营度过的日子。<ul>
<li>4.The photo reminds me of the days which spent in the summer camp.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第四大句型:主语+不完全及物动词+宾语+宾语补语，变成被动语态时，原句的宾语补语，在被动语态中的名称为“主语补语”<ul>
<li>My father was shocked. Now we are not allowed to touch it. 我父亲大为吃惊，不许我们再动它。</li>
<li>The Games will be held just outside the capital and the whole area will be called ‘Olympic City’. 奥运会就在首都市郊举办，整个地区将被称作奥林匹克城”。</li>
<li>The man was ordered to pay 43,545 for the cost of the trip. 此人被责令交付旅费3,500英镑.</li>
</ul>
</li>
<li>make, have, let, get 这4个使役动词，只有make可以用于被动语态。这类句型在被动语态句里边，主语补语必须加上to!<ul>
<li>They made me repeat the story. / I was made to repeat the story.他们让我又把那事讲了一遍。</li>
</ul>
</li>
<li>能用动词原形作宾语补语的不完全(及物)动词有<ul>
<li>5看：see, observe, watch, look at, notice<ul>
<li>I saw him dance. / He was seen to dance. 我看见他跳舞了。</li>
</ul>
</li>
<li>1使：make</li>
<li>2听：hear, listen to</li>
<li>1感：feel</li>
</ul>
</li>
<li>第五大句型变成被动语态时，两个宾语都可以成为被动句的主语。但由于间接宾语是人，通常更常变成主语。<ul>
<li>I give him a book. = He was given a book by me. = A book was given to him by me.</li>
</ul>
</li>
</ul>
<h1 id="5-最简单的长句——并列句"><a href="#5-最简单的长句——并列句" class="headerlink" title="5.最简单的长句——并列句"></a>5.最简单的长句——并列句</h1><h2 id="简单句、复合句、并列句"><a href="#简单句、复合句、并列句" class="headerlink" title="简单句、复合句、并列句"></a>简单句、复合句、并列句</h2><ul>
<li>简单句：是只有一个主干的句子</li>
<li>复合句：是除主句外还包含一个或一个以上从句的句子</li>
<li>并列句：由并列连词连接两个或两个以上简单句而成的句子。</li>
<li>注意：汉语可以用逗号分隔两个完整的句子，英语绝对不可以！而是必须有连词连接，或者把其中一个句子，化简为分词短语或不定时短语</li>
</ul>
<h2 id="连接主句和从句的连词有三种"><a href="#连接主句和从句的连词有三种" class="headerlink" title="连接主句和从句的连词有三种"></a>连接主句和从句的连词有三种</h2><ul>
<li>引导词，连接名词性从句</li>
<li>副词连词，连接状语从句</li>
<li>关系词，连接定语从句</li>
</ul>
<h2 id="单一连接词：and-or-but"><a href="#单一连接词：and-or-but" class="headerlink" title="单一连接词：and, or, but"></a>单一连接词：and, or, but</h2><ul>
<li>连接对等的句子<ul>
<li>I had just lost $50 <code>and</code> I felt very upset. 我刚刚丢了50英镑，感到非常烦恼。(and连接不用加逗号)</li>
<li>The police had a difficult time, <code>but</code> they were most amused. 警察虽然吃了苦头，但他们还是感到很有趣。(but连接要加逗号)</li>
<li>注：or连接句子的时候，通常用于祈使句后面，翻译为“否则”</li>
<li>Obey your boss <code>or</code> you will be fired. 服从你的上司，否则你会被解雇。</li>
<li>Don’t cheat at exams <code>or</code> others will despise you. 考试不要作弊，否则别人会瞧不起你。</li>
<li>Give me liberty <code>or</code> give me death. 不自由，毋宁死。</li>
</ul>
</li>
<li>连接句子中任何对等的成分<ul>
<li>连接主语<ul>
<li>A young man <code>and</code> a young woman were sitting behind me.</li>
<li>一青年男子与一青年女子坐在我的身后。</li>
</ul>
</li>
<li>连接谓语：相当于是连接两个句子，省略了第二个句子的主语<ul>
<li>I visited museums <code>and</code> sat in public gardens. 我参观了博物馆，还去了公园。</li>
<li>I entered the hotel manager’s office <code>and</code> sat down. 我走进饭店经理的办公室，坐了下来</li>
<li>注：连接谓语的时候，只要助动词相同，即可省略助动词<ul>
<li>After taking off, we were flying low over the city <code>and</code> (were) slowly gaining height, when the plane suddenly turned round and flew back to the airport. 起飞之后，我们在城市上空低低地飞行，然后慢慢爬高。这时飞机突然调转头来，飞回了 机场。(括号里的助动词were可省略)</li>
</ul>
</li>
<li>谓语动词相同的，也可以省略。<ul>
<li>Mary is very happy <code>but</code> John (is) very miserable. 玛丽很幸福，但是约翰很悲惨。</li>
<li>Experience is the father of wisdom, <code>and</code> memory (is) the mother. 经验乃智慧之父，记忆为智慧之母。</li>
<li>Reading makes a full man; conference a ready man; <code>and</code> writing an exact man.读书使人渊博，交谈使人机敏，写作使人严谨。(conference和writing后省略了makes)- Francis Bacon(弗朗西斯培根)</li>
</ul>
</li>
</ul>
</li>
<li>连接宾语<ul>
<li>I looked at the man <code>and</code> the woman angrily. 我回过头去怒视着那一男一女。</li>
<li>He asked me for a meal <code>and</code> a glass of beer. 他问我要一顿饭和一杯啤酒。(连接介词for的两个宾语)</li>
</ul>
</li>
<li>连接表语<ul>
<li>The railway station was big, black <code>and</code> dark. 火车站很大，又黑又暗。</li>
<li>The explanation was simple <code>but</code> very unusual. 解释很简单，却异乎寻常</li>
</ul>
</li>
<li>连接宾语补语<ul>
<li>He saw two thieves rush out of a shop <code>and</code> run towards a waiting car. 他看到有两个小偷从一家商店里冲出来，奔向等在那里的一辆汽车。</li>
</ul>
</li>
<li>连接定语<ul>
<li>Pupils of the school, old <code>and</code> new, will be sending him a present to mark the occasion.为了纪念这个日子，学校的学生——无论老同学还是新同学——将送他一件礼物。</li>
</ul>
</li>
<li>连接状语<ul>
<li>We shall all remember Mr. Page for his patience <code>and</code> understanding and for the kindly encouragement.我们不会忘记佩奇先生对我们既有耐心又充满理解，还有亲切鼓励。</li>
</ul>
</li>
<li>注：or连接对等成分的时候，通常翻译为“或者”<ul>
<li>They will go to the zoo <code>or</code> play volleyball. 他们要去动物园或打排球</li>
<li>I want to have a talk with Mr. Jones <code>or</code> Mr. Smith. 我想和琼斯先生或者史密斯先生谈谈。</li>
</ul>
</li>
<li>And也可表示“然后”，“但是”，”那么，则”的意思<ul>
<li>Cease to struggle and you cease to live. 停止奋斗，则终止了生命。</li>
<li>Idleness is sweet, and its consequences are cruel.  懒惰是甜蜜的，但其结果是残酷的。</li>
<li>I will set my goal and work toward it. 我要确定目标，然后为此努力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="由单一连词衍生的连接词"><a href="#由单一连词衍生的连接词" class="headerlink" title="由单一连词衍生的连接词"></a>由单一连词衍生的连接词</h2><ul>
<li>要么…要么…：either…or…(连接2者以上的结构)<ul>
<li>In answer to these questions I <code>either</code> nodded <code>or</code> made strange noises. 作为对这些问题的回答，我不是点头，就是发出奇怪的声音。</li>
<li><code>Either</code> Bob <code>or</code> Jim or Sam will be the new vice president of the company. 不是鲍勃就是吉姆或者是山姆会成为这家公司的新副总裁。</li>
</ul>
</li>
<li>既不是…也不是…：neither…nor…，也可用其它否定词代替neither<ul>
<li>He answered me, but he spoke <code>neither</code> slowly <code>nor</code> clearly. 他回答了，但他讲得既不慢也不清楚。</li>
<li>We are worried about Mary. She <code>neither</code> eats <code>nor</code> drinks <code>nor</code> talks. 我们替玛丽担心。她不吃不喝也不说话</li>
<li>The story is <code>not</code> interesting <code>nor</code> instructive. 这个故事没有味道，也没有教育意义。</li>
<li>I have <code>never</code> spoken <code>nor</code> written to her. 我跟她从来没说过话，也没写过信。</li>
</ul>
</li>
<li>不是…而是…：not…but…<ul>
<li>I went to the concert <code>not</code> with my brother <code>but</code> with my friend. 我不是和我哥哥去音乐会，而是和我朋友去的。(只能省略动词，不能省略介词)</li>
<li>We choose to go to the moon in this decade and do the other things, <code>not</code> because they are easy, <code>but</code> because they are hard. 我们选择10年内登月以及另外一些事情，不是因为它们容易，而是因为它们困难。(肯尼迪总统在阿波罗登月计划动员会上的讲话)</li>
<li>“Listen, my dear, we must hold on to hope,” my father calm but insistently replied.“<code>Not</code> because hope is real, but because we have to live up to nobility.” “听着，亲爱的，我们必须抱有希望，”我爸爸平静但坚定地回答。“这并不是因为希望真的存在，而是因为我们要做高贵的人。” 《The wandering earth》Liu Cixin (刘慈欣《流浪地球》)</li>
</ul>
</li>
<li>不仅…而且…：not only…but(also)…/not only…but…as well<ul>
<li>He answered all the question <code>not only</code> quickly <code>but (also)</code> accurately. 他回答所有问题时不仅快，而且准确。</li>
<li>The Big Ben is <code>not only</code> of immense size, <code>but</code> is extremely accurate <code>as well.</code> 此钟不仅外型巨大，而且走时也非常准确。</li>
<li>英国英语常用not only… but… as well,</li>
<li>美国英语常用not only… but also…(also可省略)</li>
<li>I <code>not only</code> spoke English very carefully, <code>but</code> very clearly <code>as well</code>.(英)</li>
<li>I <code>not only</code> spoke English very carefully, <code>but (also)</code> very clearly. (美)我的英语讲得不但非常认真，而且咬字也非常清楚。</li>
</ul>
</li>
<li>注：上述并列连词连接的并列名词作主语时，谓语动词的单复数与靠后面的名词一致<ul>
<li>Either Thomas or I <code>am</code> going to call you tomorrow about the job.不是托马斯就是我明天会打电话给你谈工作的事。</li>
</ul>
</li>
<li>…和…两者都：both…and…<ul>
<li>To go far, you need <code>both</code> a dream <code>and</code> a positive attitude.要成功，你需要梦想和积极的态度。</li>
<li>注：本并列连接的并列名词作主语时，谓语动词一律用复数</li>
<li>Both my mother and my sister <code>work</code> at the grocery store. 我妈妈和我姐姐都在这个杂货店工作。</li>
</ul>
</li>
<li>既是…又是…：… as well as …<ul>
<li>Nursing is a vocation <code>as well as</code> a profession. 护理工作既是职业又是救死扶伤的责任。</li>
<li>He shared in my sorrows <code>as well as</code> in my joys. 他分担我的快乐也分享我的悲伤。</li>
<li>注：…as well as…的意思和not only…but (also)…相近，但是前者强调前面的名词，谓语动词与强调的名词一致。<ul>
<li>The bedrooms, as well as the kitchen, <code>need</code> to be repaired if we rent the house. 如果我们要租这个房子，卧室和厨房都需要维修。</li>
</ul>
</li>
</ul>
</li>
<li>是…而不是…：…rather than…<ul>
<li>These are political <code>rather than</code> social matters.这是政治问题而不是社会问题。</li>
</ul>
</li>
</ul>
<h2 id="造句练习"><a href="#造句练习" class="headerlink" title="造句练习"></a>造句练习</h2><ul>
<li>1.中国和印度的人口都超过了10亿。<ul>
<li>1.Both China and India have a population of over one billion.</li>
</ul>
</li>
<li>2.我们应该要么把电脑送修要么买台新的。<ul>
<li>2.We should either get the computer fixed or buy a new one.</li>
</ul>
</li>
<li>3.冰箱里既没有牛奶也没有蔬菜。<ul>
<li>3.Neither milk nor vegetables is in the refrigerator.</li>
</ul>
</li>
<li>4.无论下雪、下雨或者高温天气都不能阻止这些邮递员完成他们的投递工作。<ul>
<li>4.Neither snow nor rain nor hot weather prevents these postmen from completing their deliveries.</li>
</ul>
</li>
<li>5.不是公司董事长而是我将出席明天早上的商务会议。<ul>
<li>5.Not the company’s president but I am going to the business meeting tomorrow morning.</li>
</ul>
</li>
<li>6.我们都喜欢张小姐，不是因为她是我们老师，而是因为她是美女。<ul>
<li>6.We all like Miss Zhang not because she is our teacher but because she is very beautiful.</li>
</ul>
</li>
<li>7.恶心和呕吐都是食物中毒的症状。<ul>
<li>7.Both nausea and vomiting are signs of food poisoning.</li>
</ul>
</li>
<li>8.他不但英语说得非常好，而且还会说法语。<ul>
<li>8.He can not only speak English very well but also French.</li>
</ul>
</li>
<li>9.这名女子听到这个消息的时候是高兴而不是悲伤。<ul>
<li>9.The woman was happy rather than sad when she heard the news</li>
</ul>
</li>
</ul>
<h1 id="6-把句子套进另一个句子里，变身“大名词”"><a href="#6-把句子套进另一个句子里，变身“大名词”" class="headerlink" title="6.把句子套进另一个句子里，变身“大名词”"></a>6.把句子套进另一个句子里，变身“大名词”</h1><ul>
<li>从句是什么<ul>
<li>就是一个句子在另外一个句子里边做句子成分</li>
</ul>
</li>
<li>名词从句<ul>
<li>一个句子，在另外一个句子里边当名词使用</li>
<li>4种用法：主语、宾语、同位语、表语</li>
<li>名词从句需要有引导词：<code>That</code> he doesn’t like to study makes me angry.</li>
</ul>
</li>
<li>that从句：任何一个陈述句，前面加上引导词that，构成that从句。（作宾语/表语时，that可省略）<ul>
<li><code>That</code> everyone may receive a moderate education is an object of vital importance. 每个人能够接受适当的教育似乎是一个至关重要的目标。(主语从句)</li>
<li>Many people pretend <code>that</code> they understand modern art. 有很多人装成很懂现代艺术的样子。(宾语从句)</li>
<li>The most surprising thing about it, however, is <code>that</code> it can land anywhere: on snow, water, or even on a ploughed field. 然而，最令人惊奇的是它能够在任何地方降落:雪地，水面，甚至刚耕过的田里。(表语从句)</li>
<li>No one could account for the fact <code>that</code> one of the boxes was extremely heavy.其中有只箱子特别重，可谁也弄不清是怎么回事。(同位语从句)</li>
</ul>
</li>
<li>that从句作主语时，为了使主干更紧凑，通常可用it作行驶时主语，而将真正的主语后置<ul>
<li>It was obvious <code>that</code> he was very embarrassed. 显然他感到很尴尬。</li>
<li>It is a curious coincidence <code>that</code> Mr. Page will have been teaching for a total of forty years. 佩奇先生执教满总共40年，这真是奇妙的巧合。</li>
</ul>
</li>
<li>consider, deem, think, find, believe五个动词是宾补动词，构成第四大句型，表示“认为…是…”<ul>
<li>我认为健康是非常重要的</li>
<li>I think health very important.其中health是宾语，important是补语</li>
<li>我认为我们每天说英语是重要的</li>
<li>I think that we should speak English important. X</li>
<li>I think it important that we should speak English.√</li>
<li>I think it necessary that you do it at once.我认为你必须立刻做那件事。</li>
<li>We find it necessary that we practice spoken English every day. 我们发现每天练习英语口语很有必要。</li>
</ul>
</li>
<li>whether/if从句：任何一个一般疑问句，前面加上引导词whether或if，构成whether从句，但主语与be动词或助动词的位置还原。如果助动词为do, does, did, 还原后将do, does, did去掉，后面的动词根据人称和时态变化<ul>
<li><code>Whether</code> they would support us was a problem. 他们是否会支持我们还是一个问题。(主语从句) </li>
<li>He asked <code>if</code> Mr Gilbert’s operation had been successful and the doctor told him that it had been. 他问吉尔伯特先生的手术中否成功，医生告诉他手术很成功。(宾语从句)</li>
<li>On the way home, he asked Jenny <code>if</code> she had enjoyed the speech. 在回家的路上，他问珍妮是否喜欢他的祝词。(宾语从句， 直接宾语)</li>
</ul>
</li>
<li>介词后及or not结构中，通常用whether<ul>
<li>My sister is only seven, but she always tells me <code>whether</code> my pictures are good <code>or not</code>. 我的妹妹只有7岁，但她总能说出我的画是好还是坏。</li>
<li>I worry about <code>whether</code> I hurt his feeling. 我担心是否伤害了他的感情</li>
</ul>
</li>
<li>疑问词从句：构成方法与whether从句一样，只是将whether换成疑问词而已，句子必须改为陈述句语序<ul>
<li>He then asked <code>when</code> Mr Gilbert would be allowed to go home and the doctor told him that he would have to stay in hospital for another two weeks.然后他又问吉尔伯特先生什么时候可以回家，医生说他在医院还必须再住上两个星期。(宾语从句，其中when作从句中的状语)</li>
<li>The doctors have not yes decided <code>how</code> the woman died. 医生们至今还未确定这位妇女的死因。</li>
<li>I have no idea <code>what</code> has happened to him. 我不知道他发生了什么事?</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.谁将负责这项工程还没有(被)决定。(be in charge of)<ul>
<li>1.Who will be in charge of the project hasn’t been decided yet.</li>
</ul>
</li>
<li>2.他要来参加这个会议(已经)使得我们每个人激动了。<ul>
<li>2.That he will come to the conference has excited every one of us.</li>
</ul>
</li>
<li>3.他告诉我他们会帮助我们完成整个工作的。<ul>
<li>3.He told me that they would help us finish the whole work.</li>
</ul>
</li>
<li>4.我不知道(wonder)您是否能小声点。<ul>
<li>4.I wonder whether/if you would mind making less noise.</li>
</ul>
</li>
<li>5.我认为每天多喝水是有必要的。<ul>
<li>5.I think it necessary that we (should) take plenty of water every day.</li>
</ul>
</li>
<li>6.我不知道(have no idea)他们什么时候回来定居。<ul>
<li>6.I have no idea when they will be back and settle down.</li>
</ul>
</li>
<li>7.我(已经)发现所有的票都(已经)卖光了。<ul>
<li>7.I have found that all the tickets had been sold out.</li>
</ul>
</li>
<li>8.问题是这部电视剧是否值得一看。<ul>
<li>8.The question is whether the TV play is worth watching.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>《透视HTTP协议》基础篇+进阶篇</title>
    <url>/http-perspective-1/</url>
    <content><![CDATA[<h1 id="10-应该如何理解请求方法？"><a href="#10-应该如何理解请求方法？" class="headerlink" title="10 | 应该如何理解请求方法？"></a>10 | 应该如何理解请求方法？</h1><ul>
<li>Q:有哪些请求方法<ul>
<li><ol>
<li>GET：获取资源，可以理解为读取或者下载数据</li>
</ol>
</li>
<li><ol start="2">
<li>HEAD：获取资源的元信息</li>
</ol>
</li>
<li><ol start="3">
<li>POST：向资源提交数据，相当于写入或上传数据</li>
</ol>
</li>
<li><ol start="4">
<li>PUT：类似 POST</li>
</ol>
</li>
<li><ol start="5">
<li>DELETE：删除资源</li>
</ol>
</li>
<li><ol start="6">
<li>CONNECT：建立特殊的连接隧道</li>
</ol>
</li>
<li><ol start="7">
<li>OPTIONS：列出可对资源实行的方法</li>
</ol>
</li>
<li><ol start="8">
<li>TRACE：追踪请求 - 响应的传输路径</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="12-响应状态码该怎么用？"><a href="#12-响应状态码该怎么用？" class="headerlink" title="12 | 响应状态码该怎么用？"></a>12 | 响应状态码该怎么用？</h1><ul>
<li>Q:有哪些状态码<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作<ul>
<li>101 Switching Protocols：客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了</li>
</ul>
</li>
<li>2××：成功，报文已经收到并被正确处理<ul>
<li>200 OK：最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据</li>
<li>204 No Content：是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的</li>
<li>206 Partial Content：是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”， 表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获 取的是总计 2000 个字节的前 100 个字节</li>
</ul>
</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求<ul>
<li>301 Moved Permanently：即「永久重定向」，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问</li>
<li>302 Found：曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问</li>
<li>301 和 302 都会在响应头里使用字段Location指明后续要 跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个 是“临时”，所以在场景、用法上差距很大</li>
<li>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS</li>
<li>再比如，今天夜里网站后台要系统维护，服务暂时不可用， 这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址</li>
<li>304 Not Modified：是一个比较有意思的状态码，它用 于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）</li>
</ul>
</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理<ul>
<li>400 Bad Request：是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码</li>
<li>403 Forbidden：实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个「闭门羹」</li>
<li>404 Not Found：可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所 以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌</li>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大</li>
</ul>
</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误<ul>
<li>500 Internal Server Error：与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</li>
<li>501 Not Implemented：表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和「即将开业， 敬请期待」的意思差不多，不过具体什么时候“开业”就不好说了</li>
<li>502 Bad Gateway：通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的</li>
<li>503 Service Unavailable：表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个「Retry-After」字段，指示客户端可以在多久以后再次尝试发送请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="15-海纳百川：HTTP的实体数据"><a href="#15-海纳百川：HTTP的实体数据" class="headerlink" title="15 | 海纳百川：HTTP的实体数据"></a>15 | 海纳百川：HTTP的实体数据</h1><ul>
<li>Q:在 HTTP 里经常遇到的数据类型「MIME type」<ul>
<li>1.text：即文本格式的可读数据，最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等</li>
<li>2.image：即图像文件，有 image/gif、image/jpeg、image/png 等</li>
<li>3.audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等</li>
<li>4.application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据</li>
</ul>
</li>
<li>Q:HTTP压缩数据的编码格式「Encoding type」有哪些<ul>
<li>1.gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式</li>
<li>2.deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip</li>
<li>3.br：一种专门为 HTTP 优化的新压缩算法（Brotli）</li>
</ul>
</li>
<li>Q:HTTP 协议定义的客户端和服务端进行内容协商的字段是什么<ul>
<li>客户端用 Accept 头告诉服务器希望接收什么样的数据，如<code>Accept: text/html,application/xml,image/webp,image/png</code></li>
<li>服务器用 Content 头告诉客户端实际发送了什么样的数据，如<code>Content-Type: text/html</code></li>
<li>Accept-Encoding字段标记的是客户端支持的压缩格式，如<code>Accept-Encoding: gzip, deflate, br</code></li>
<li>服务器可以选择客户端支持的压缩格式来压缩数据，实际使用的压缩格式放在响应头字段Content-Encoding里，如<code>Content-Encoding: gzip</code></li>
<li>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩</li>
</ul>
</li>
<li>Q:HTTP 协议对语言与编码协商的字段是什么<ul>
<li>Accept-Language字段标记了客户端可理解的自然语言，也允许用「,」做分隔符列出多个类型，如<code>Accept-Language: zh-CN, zh, en</code></li>
<li>服务器应该在响应报文里用头字段Content-Language告诉客户端实体数据使用的实际语言类型，如<code>Content-Language: zh-CN</code></li>
<li>字符集在 HTTP 里使用的请求头字段是Accept-Charset，如浏览器请求 GBK 或 UTF-8 的字符集，即<code>Accept-Charset: gbk, utf-8</code></li>
<li>字符集的响应头是在Content-Type字段的数据类型后面用“charset=xxx”来表示，如服务器返回的是 UTF-8 编码，即<code>Content-Type: text/html; charset=utf-8</code></li>
<li>不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段</li>
</ul>
</li>
<li>Q:内容协商的质量值是什么<ul>
<li>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可用「q」参数(即quality factor)表示权重来设定优先级</li>
<li>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个「;」，然后是「q=value」</li>
<li>注意在 HTTP 的内容协商里“;”的意义是小于“,”的</li>
<li>如<code>Accept: text/html,application/xml;q=0.9,*/*;q=0.8</code></li>
<li>表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重 是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML</li>
</ul>
</li>
<li>Q:内容协商的结果<ul>
<li>内容协商的过程是不透明的，每个 Web 服务器使用的算法 都不一样。但有的时候，服务器会在响应头里多加一个Vary字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，如：<code>Vary: Accept-Encoding,User-Agent,Accept</code></li>
<li>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的 响应报文</li>
<li>Vary 字段可以认为是响应报文的一个特殊的“版本标 记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务</li>
</ul>
</li>
</ul>
<h1 id="16-把大象装进冰箱：HTTP传输大文件的方法"><a href="#16-把大象装进冰箱：HTTP传输大文件的方法" class="headerlink" title="16 | 把大象装进冰箱：HTTP传输大文件的方法"></a>16 | 把大象装进冰箱：HTTP传输大文件的方法</h1><ul>
<li>Q:HTTP如何分块传输？<ul>
<li>在响应报文里用头字段「Transfer-Encoding: chunked」来表示</li>
<li>注意：「Transfer-Encoding: chunked」和「Content-Length」两个字段时互斥的</li>
</ul>
</li>
<li>Q:分块传输的编码规则是怎样？<ul>
<li>1.每个分块包含两个部分，长度头和数据块</li>
<li>2.长度头以CRLF(回车换行，即\r\n)结尾的一行明文，用16进制数字表示长度</li>
<li>3.数据块紧跟在长度头后，最后也用CRLF结尾，但数据不包含CRLF</li>
<li>4.最后用一个长度为0的块表示结束，即「0\r\n\r\n」</li>
<li><img src="https://img.shiqi-lu.tech/20210321121431.png"></li>
</ul>
</li>
<li>Q:HTTP如何实现范围请求(range requests)<ul>
<li>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段「Accept-Ranges: bytes」明确告知客户端</li>
<li>如果不支持的话服务器可以发送「AcceptRanges: none」，或者干脆不发送“Accept-Ranges”字段，这样客户端就只能收发整块文件了</li>
</ul>
</li>
<li>Q:请求头Range的格式是怎样<ul>
<li>「bytes=x-y」，其中的 x 和 y 是以字节为单位的数据范围，它们表示的是「偏移量」，范围必须从0计数，如前10个字节表示为「0-9」，第二个10字节表示「10-19」</li>
<li>Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围</li>
<li>假设文件是 100 个字节，那么：<ul>
<li>「0-」表示从文档起点到文档终点，相当于「0-99」，即整个文件</li>
<li>「10-」是从第 10 个字节开始到文档末尾，相当于「10-99」</li>
<li>「-1」是文档的最后一个字节，相当于「99-99」</li>
<li>「-10」是从文档末尾倒数 10 个字节，相当于「90-99」</li>
</ul>
</li>
</ul>
</li>
<li>Q:服务器收到 Range 字段后，需要做哪四件事?<ul>
<li>1.检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码416</li>
<li>2.如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分</li>
<li>3.服务器要添加一个响应头字段Content-Range，告诉片段的实际偏移量和资源的总大小，格式是「bytes xy/length」，与 Range 头区别在没有「=」，范围后多了总长度。例如，对于「0-10」的范围请求，值就是「bytes 0-10/100」</li>
<li>4.发送数据，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了</li>
</ul>
</li>
<li>Q:下载工具里的多段下载、断点续传的实现要点是什么？<ul>
<li>1.先发HEAD，看服务器是否支持范围请求，同时获取文件的大小</li>
<li>2.开N个线程，每个线程使用Range字段划分出各自负责下载的片段，发请求传输数据</li>
<li>3.下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了</li>
</ul>
</li>
<li>Q:如何一次性获取多个片段数据？<ul>
<li>在请求头中的Range里使用多个「x-y」</li>
<li>响应头中使用「multipart/byteranges」，表示报文的body是由多段字节序列组成的，并且还要用一个参数「boundary=xxx」给出段之间的分隔标记</li>
<li><img src="https://img.shiqi-lu.tech/20210321131108.png"></li>
<li>每一个分段必须以「–boundary」开始，之后要用「Content-Type」和「Content-Range」标记这段数据的类型和所在范围，然后以回车换行结束，再加上分段数据，最后用一个「–boundary–」表示所有的分段结束</li>
</ul>
</li>
</ul>
<h1 id="17-排队也要讲效率：HTTP的连接管理"><a href="#17-排队也要讲效率：HTTP的连接管理" class="headerlink" title="17 | 排队也要讲效率：HTTP的连接管理"></a>17 | 排队也要讲效率：HTTP的连接管理</h1><ul>
<li>Q:如何在请求头中明确要求使用长连接？<ul>
<li>使用字段<code>Connection: keep-alive</code></li>
<li>不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keepalive”字段</li>
</ul>
</li>
<li>Q:客户端如何关闭长连接？<ul>
<li>在客户端，可以在请求头里加上「Connection: close」字段，告诉服务器：「这次通信后就关闭连接」。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接</li>
<li>客户端和服务器都可以在报文里附加通用头字段「Keep-Alive: timeout=value」，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见</li>
</ul>
</li>
<li>Q:不会主动关闭连接的服务器端关闭连接的策略是什么？<ul>
<li>1.使用「keepalive_timeout」指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源</li>
<li>2.使用「keepalive_requests」指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接</li>
</ul>
</li>
<li>Q:队头阻塞(Head-of-line blocking)是什么？<ul>
<li>这是由 HTTP 基本的「请求 - 应答」模型所导致的</li>
<li>因为HTTP规定报文必须是「一发一收」，这就形成了一个先进先出的「串行」队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理</li>
<li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本</li>
<li><img src="https://img.shiqi-lu.tech/20210321144626.png"></li>
</ul>
</li>
<li>Q:在HTTP/1.1里如何缓解「队头阻塞」的问题？<ul>
<li>1.并发连接(concurrent conncetions)：同时对一个域名发起多个长连接， 用数量来解决质量的问题</li>
<li>2.域名分片(domain sharding)：因HTTP 协议和浏览器限制并发连接数量，就多开几个域名，而这些域名都指向同一台服务器，这样实际长连接的数量就又上去了</li>
</ul>
</li>
</ul>
<h1 id="18-四通八达：HTTP的重定向和跳转"><a href="#18-四通八达：HTTP的重定向和跳转" class="headerlink" title="18 | 四通八达：HTTP的重定向和跳转"></a>18 | 四通八达：HTTP的重定向和跳转</h1><ul>
<li>Q:301/302重定向的过程<ul>
<li>「重定向」实际上发送了两次 HTTP 请求，第一个请求返回了 302，然后第二个请求就被重定向到了「Location」所指的位置</li>
<li>「Location」字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI</li>
<li>浏览器收到 301/302 报文，会检查响应头里有没有「Location」。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接，这个URI可使用绝对URI和相对URI</li>
</ul>
</li>
<li>Q:重定向状态码<ul>
<li>301 永久重定向 Moved Permanently：原 URI 已经「永久」性地不存在了，今后的所有请求都必须改用新的 URI，浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI</li>
<li>302 临时重定向 Moved Temporarily：原 URI 处于「临时维护」状态，浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI</li>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301「永久重定向」的含义</li>
<li>303、307、308这三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用</li>
</ul>
</li>
</ul>
<h1 id="19-让我知道你是谁：HTTP的Cookie机制"><a href="#19-让我知道你是谁：HTTP的Cookie机制" class="headerlink" title="19 | 让我知道你是谁：HTTP的Cookie机制"></a>19 | 让我知道你是谁：HTTP的Cookie机制</h1><ul>
<li>Q:如何使用cookie?<ul>
<li>响应头字段Set-Cookie和请求头字段Cookie，格式是「key=value」</li>
<li>服务器有时会在响应头里添加多个 Set-Cookie，浏览器这边发送时只要在Cookie中的一行里用「;」隔开就行</li>
</ul>
</li>
<li>Q:如何设置 Cookie 的生存周期<ul>
<li>可以使用 Expires 和 Max-Age 两个属性</li>
<li>「Expires」即过期时间：用的绝对时间点，即截止日期</li>
<li>「Max-Age」用的相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间</li>
<li>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期</li>
</ul>
</li>
<li>Q:如何设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用<ul>
<li>「Domain」和「Path」指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie</li>
<li>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑</li>
</ul>
</li>
<li>Q:Cookie的安全性<ul>
<li>「HttpOnly」：告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了</li>
<li>「SameSite」：防范「跨站请求伪造」(XSRF)，设置成「SameSite=Strict」可以严格限定Cookie不能随着跳转链接跨站发送，而「SameSite=Lax」略宽松一点，允许GET/HEAD等安全防范，但禁止POST跨站发送</li>
<li>「Secure」：这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在</li>
</ul>
</li>
</ul>
<h1 id="20-生鲜速递：HTTP的缓存控制"><a href="#20-生鲜速递：HTTP的缓存控制" class="headerlink" title="20 | 生鲜速递：HTTP的缓存控制"></a>20 | 生鲜速递：HTTP的缓存控制</h1><ul>
<li>Q:缓存的运行机制是什么？<ul>
<li>1.浏览器发现缓存无数据，于是发送请求，向服务器获取资源</li>
<li>2.服务器响应请求，返回资源，同时标记资源的有效期</li>
<li>3.浏览器缓存资源，等待下次重用</li>
</ul>
</li>
<li>Q:服务器的缓存控制是怎样<ul>
<li>服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</li>
<li>max-age：“生存时间”，时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间，单位是秒</li>
<li>no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面</li>
<li>no_cache：可以缓存，但在使用前必须要去服务器验证是否过期，是否有最新版本</li>
<li>must-revalidate：如果缓存不过期可以继续使用，但过期了如果还想用就必须去服务器验证</li>
<li><img src="https://img.shiqi-lu.tech/20210321160000.png"></li>
</ul>
</li>
<li>Q:客户端的缓存控制<ul>
<li>浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略</li>
<li>当点「刷新」按钮的时候，浏览器会在请求头里加一个「Cache-Control: maxage=0」，浏览器就不会使用缓存，而是向服 务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器</li>
<li>当使用Ctrl+F5的「强制刷新」时，其实是发了「Cache-Control: no-cache」，含义和“max-age=0”基本一样，就 看后台的服务器怎么理解，通常两者的效果是相同的</li>
</ul>
</li>
<li>Q:浏览器的缓存在什么时候生效呢?<ul>
<li>点一下浏览器的“前进”“后退”按钮，会看到Status Code中有(from disk cache)的</li>
</ul>
</li>
<li>Q:浏览器做缓存控制怎么去服务器验证是否为最新版？<ul>
<li>HTTP 协议就定义了一系列「If」开头的「条件请求」字段，专门用来检查验证资源是否过期，把验证缓存有效性和获取新版本内容两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”</li>
<li>条件请求一共有5个头字段，最常使用的是「If-Modified-Since」和「If-None-Match」这两个。需要第一次的响应报文预先提供「Last-modified」和「ETag」，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的</li>
<li>如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了</li>
<li>「Last-modified」：文件的最后修改时间</li>
<li>「ETag」：即实体标签(Entity Tag)，是资源的一个唯一标识，主要用来解决修改时间无法准确区分文件变化的问题。<ul>
<li>如一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分</li>
<li>再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽</li>
</ul>
</li>
<li>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存</li>
<li>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）</li>
</ul>
</li>
</ul>
<h1 id="21-良心中间商：HTTP的代理服务"><a href="#21-良心中间商：HTTP的代理服务" class="headerlink" title="21 | 良心中间商：HTTP的代理服务"></a>21 | 良心中间商：HTTP的代理服务</h1><ul>
<li>Q:代理隐藏了真实客户端和服务器，如果双方想要获得这些“丢失”的原始信息，该怎么办呢？<ul>
<li>1.代理服务器需要用字段「Via」标明代理的身份，Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾。如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。Via 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息</li>
<li>2.「X-Forwarded-For」字段，和「Via」差不多，每经过一个代理节点就会在字段里追加一个信息。但「Via」追加的是代理主机名（或者域名），而「X-Forwarded-For」追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就客户端的地址</li>
<li>3.「X-Real_IP」字段，记录客户端 IP 地址，没有中间的代理信息</li>
</ul>
</li>
<li>Q:代理协议(The PROXY protocol)v1是怎样<ul>
<li>在 HTTP 报文前增加了一行 ASCII 码文本</li>
<li>这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: www.xxx.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure></li>
<li>服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情</li>
<li>不过代理协议并不支持“X-Forwarded-For”的链式地址形式，所以拿到客户端地址后再如何处理就需要代理服务器与后端自行约定</li>
</ul>
</li>
</ul>
<h1 id="22-冷链周转：HTTP的缓存代理"><a href="#22-冷链周转：HTTP的缓存代理" class="headerlink" title="22 | 冷链周转：HTTP的缓存代理"></a>22 | 冷链周转：HTTP的缓存代理</h1><ul>
<li>Q:源服务器的缓存控制有哪些？<ul>
<li>1.使用两个新属性「private」和「public」来区分客户端上的缓存和代理上的缓存<ul>
<li>private：只能在客户端保存，不能放在代理上与别人共享</li>
<li>public：缓存完全开放，谁都可以存，谁都可以用</li>
</ul>
</li>
<li>2.缓存失效后的重新验证也要区分开（即使用条件请求「Last-modified」和「ETag」）<ul>
<li>must-revalidate：只要过期就必须回源服务器验证</li>
<li>proxy-revalidate：只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行</li>
</ul>
</li>
<li>3.缓存的生存时间可以使用新的「s-maxage」，只限定在代理上能够存多久，而客户端仍然使用「max-age」</li>
<li>4.代理专用的属性「no-transform」：代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而「no-transform」就会禁止这样做</li>
</ul>
</li>
<li>Q:可以同时控制客户端和代理的完整服务器端缓存控制策略的流程图<ul>
<li><img src="https://img.shiqi-lu.tech/20210323210741.png"></li>
</ul>
</li>
<li>Q:客户端的缓存控制<ul>
<li><img src="https://img.shiqi-lu.tech/20210323210930.png"></li>
<li>max-stale：如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要</li>
<li>min-fresh：缓存必须有效，而且必须在 x 秒后依然有效，即必须处于过期前 x 秒</li>
<li>only-if-cached：只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个504(Gateway Timeout)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《透视HTTP协议》安全篇</title>
    <url>/http-perspective-2/</url>
    <content><![CDATA[<h1 id="23-HTTPS是什么？SSL-TLS又是什么？"><a href="#23-HTTPS是什么？SSL-TLS又是什么？" class="headerlink" title="23 | HTTPS是什么？SSL/TLS又是什么？"></a>23 | HTTPS是什么？SSL/TLS又是什么？</h1><ul>
<li>Q:具备哪4给特性的通信过程才是安全的?<ul>
<li>机密性(Secrecy/Confidentiality)：对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西</li>
<li>完整性(Integrity，也叫一致性)：指数据在传输过程中没有被窜改</li>
<li>身份认证(Authentication)：确认对方的真实身份，保证消息只能发送给可信的人</li>
<li>不可否认(Non-repudiation/Undeniable，也叫不可抵赖)，不能否认已经发生过的行为</li>
</ul>
</li>
</ul>
<h1 id="24-固若金汤的根本（上）：对称加密与非对称加密"><a href="#24-固若金汤的根本（上）：对称加密与非对称加密" class="headerlink" title="24 | 固若金汤的根本（上）：对称加密与非对称加密"></a>24 | 固若金汤的根本（上）：对称加密与非对称加密</h1><ul>
<li>Q:对称加密是什么？<ul>
<li>指加密和解密时使用的密钥都是同一个，只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</li>
</ul>
</li>
<li>Q:目前常用的对称加密算法有哪两个<ul>
<li>AES：高级加密标准（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件 还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法</li>
<li>ChaCha20：Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能 要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所 以现在不再具有明显的优势，但仍然算得上是一个不错算法</li>
</ul>
</li>
<li>Q:加密分组模式是什么？<ul>
<li>让算法用固定长度的密钥加密任意长度的明文，把密钥转化为密文</li>
<li>最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305</li>
</ul>
</li>
<li>Q:非对称加密是什么？<ul>
<li>它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密</li>
<li>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密</li>
</ul>
</li>
<li>Q:有哪些非对称加密算法<ul>
<li>RSA：它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的</li>
<li>ECC（Elliptic Curve Cryptography）：它基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名</li>
<li>目前比较常用的两个曲线是 P-256（secp256r1，在 OpenSSL 称为 prime256v1）和 x25519。P-256 是 NIST（美国国家标准技术研究所）和 NSA（美国国家安全局）推荐使用的曲线，而 x25519 被认为是最安全、最快速的曲线</li>
</ul>
</li>
<li>Q:TLS里使用的混合加密是怎样呢？<ul>
<li>在通信刚开始的时候使用非对称算法，如RSA、ECDHE，首先解决密钥交换的问题</li>
<li>用随机数产生对称算法使用的「会话密钥」(session key)，再用公钥加密。因为会话密钥很短，通常只有16字节或32字节，所以慢一点也无所谓</li>
<li>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密</li>
</ul>
</li>
</ul>
<h1 id="25-固若金汤的根本（下）：数字签名与证书"><a href="#25-固若金汤的根本（下）：数字签名与证书" class="headerlink" title="25 | 固若金汤的根本（下）：数字签名与证书"></a>25 | 固若金汤的根本（下）：数字签名与证书</h1><ul>
<li>Q:目前推荐使用的摘要算法是什么<ul>
<li>SHA-2：一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、 SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要</li>
</ul>
</li>
<li>Q:如何保证数据完整性<ul>
<li>真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要</li>
</ul>
</li>
<li>Q:数字签名的原理是什么？<ul>
<li>把公钥私钥的用法反过来，之前是公钥加密、私钥解密， 现在是私钥加密、公钥解密</li>
<li>因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输</li>
<li>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</li>
</ul>
</li>
<li>Q:CA是什么<ul>
<li>证书认证机构(Certificate Authority)，具有极高的可信度，由它来给各个公钥签名，用自 身的信誉来保证公钥无法伪造，是可信的</li>
<li>CA 对公钥的签名认证是有格式的，包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）</li>
</ul>
</li>
<li>Q:CA签发的三种证书DV、OV、EV的区别是<ul>
<li>区别在于可信程度</li>
<li>DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）</li>
</ul>
</li>
<li>Q:CA 怎么证明自己呢<ul>
<li>这是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了</li>
<li><img src="https://img.shiqi-lu.tech/20210321183737.png"></li>
<li>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的</li>
</ul>
</li>
</ul>
<h1 id="26-信任始于握手：TLS1-2连接过程解析"><a href="#26-信任始于握手：TLS1-2连接过程解析" class="headerlink" title="26 | 信任始于握手：TLS1.2连接过程解析"></a>26 | 信任始于握手：TLS1.2连接过程解析</h1><ul>
<li>Q:TLS协议由哪几个子协议组成呢？<ul>
<li>记录协议(Record Protocol)：规定了TLS收发数据的基本单位：记录(record)。它有点像是TCP里的segment，所有的其它子协议都需要通过记录协议发出。但多个记录数据可以在一个TCP包里一次性发出，也不需要像TCP那样返回ACK</li>
<li>警报协议(Alert Protocol)：向对方发出警报信息，类似HTTP协议里的状态码。如，protocol_version是不支持旧版本，bad_certificate是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接</li>
<li>握手协议(Handshake Protocol)：浏览器和服务器会在握手过程中协商TLS版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商会得到会话密钥，用于后续的混合加密系统</li>
<li>变更密码规范协议(Change Cipher Spec Protocol)：就是一个「通知」，告诉对方，后续的数据都将使用加密保护。在它之前，数据都是明文的</li>
</ul>
</li>
<li>Q:TLS的握手过程<ul>
<li><img src="https://img.shiqi-lu.tech/20210321192338.png"></li>
<li>其中每一个“框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议</li>
<li><img src="https://img.shiqi-lu.tech/20210322090801.png"></li>
<li>1.在TCP建立连接后，浏览器会首先发一个「Client Hello」消息。里面有客户端的版本号、支持的密码套件，还有一个随机数(Client Random)，用于后续生成会话密钥</li>
<li>2.服务器收到「Client Hello」后，会返回一个「Server Hello」消息。把版本号对一下，也给出一个随机数(Server Random)，然后从客户端列表里选一个作为本次通信使用的密码套件</li>
<li>然后服务器为了证明自己的身份，就把证书也发给了客户端(Server Certificate)</li>
<li>接下来因为服务器选择了ECDHE算法，所以它会在证书后发送「Server Key Exchange」消息，里面是椭圆曲线的公钥(Server Params)，用来实现密钥交换，再加上自己的私钥签名认证</li>
<li>然后是「Server Hello Done」消息，表示所有信息就这些</li>
<li>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params</li>
<li>3.客户端拿到服务器的证书后，开始走证书链逐级验证，确认证书的真实性，再用证书公钥签名，确认服务器的身份</li>
<li>然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥(Client Params)，用「Client Key Exchange」消息发给服务器</li>
<li>现在客户端和服务器手里都难倒了密钥交换算法的两个参数(Client Params、Server Params)，就用ECDHE算法算出「Pre-Master」，也是一个随机数</li>
<li>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫「Master Secret」。而黑客因为拿不到「Pre-Master」，所以也就得不到主密钥</li>
<li>用三个随机数是因为保证真正的「完全随机」</li>
<li>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF (伪随机数函数)扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患</li>
<li>4.有了主密钥和派生的会话密钥，客户端发一个「Change Cipher Spec」，然后再发一个「Finished」消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证</li>
<li>服务器同样发「Change Cipher Spec」和「Finished」消息，双方都验证加密解密OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了</li>
</ul>
</li>
<li>Q:主流的TLS握手过程和传统的RSA握手过程的区别是什么？<ul>
<li>1.使用ECDHE实现密钥交换，而不是RSA，所以会在服务器端发出「Server Key Exchange」消息</li>
<li>2.因为使用了ECDHE，客户端可以不用等到服务器发回「Finished」确认握手完毕，，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫「TLS False Start」，意思就是「抢跑」，和「TCP Fast Open」有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率</li>
<li><img src="https://img.shiqi-lu.tech/20210322152509.png"></li>
<li>大体的流程没有变，只是「Pre-Master」不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过「Client Key Exchange」消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥</li>
</ul>
</li>
<li>Q:双向认证是什么？<ul>
<li>TLS握手是「单向认证」的握手过程，只认证了服务器的身份，而没有认证客户端的身份。这是因为通常单向认证通过后已经建立了安全通信，用账号、密码等简单的手段就能够确认用户的真实身份</li>
<li>双向认证的流程也没有太多变化，只是在「Server Hello Done」之后，「Client Key Exchange」之前，客户端要发送「Client Certificate」消息，服务器收到后也把证书链走一遍，验证客户端的身份</li>
</ul>
</li>
</ul>
<h1 id="27-更好更快的握手：TLS1-3特性解析"><a href="#27-更好更快的握手：TLS1-3特性解析" class="headerlink" title="27 | 更好更快的握手：TLS1.3特性解析"></a>27 | 更好更快的握手：TLS1.3特性解析</h1><ul>
<li>Q:TLS1.3的主要改进是什么？<ul>
<li>最大化兼容性<ul>
<li>TLS1.3 保持现有的记录格式不变，通过“伪装”来实现兼容TLS1.2，即不变更记录头字段里的版本号</li>
<li>使用一个新的扩展协议（Extension Protocol），通过在记录末尾添加一系列的「扩展字段」来增加新的功能，老版本的 TLS 不认识它可以直接忽略，这就实现了「后向兼容」</li>
<li>在记录头的 Version 字段被兼容性“固定”的情况下，只要是 TLS1.3 协议，握手的“Hello”消息后面就必须有“supported_versions”扩展，它标记了 TLS 的版本号， 使用它就能区分新旧协议</li>
</ul>
</li>
<li>强化安全<ul>
<li>精简算法，废除不安全的算法</li>
</ul>
</li>
<li>提升性能<ul>
<li>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重</li>
<li>现在因为密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了。TLS1.3 压缩了以前的「Hello」协商过程，删除了「Key Exchange」消息，把握手时间减少到了1-RTT，效率提高了一倍</li>
<li>具体的做法是利用扩展。客户端在「Client Hello」消息里直接 用「supported_groups」带上支持的曲线，比如 P-256、x25519，用「key_share」带上曲线对应的客户端公钥参数，用「signature_algorithms」带上签名算法</li>
<li>服务器收到后在这些扩展里选定一个曲线和参数，再用「key_share」扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 1.2 基本一样了</li>
</ul>
</li>
</ul>
</li>
<li>Q:TLS1.3的握手过程<ul>
<li><img src="https://img.shiqi-lu.tech/20210322162027.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210322162054.png"></li>
<li>在 TCP 建立连接之后，浏览器首先还是发一个「Client Hello」</li>
<li>因为 1.3 的消息兼容 1.2，所以开头的版本号、支持的密码套件和随机数（Client Random）结构都是一样的（不过这时的随机数是 32 个字节）</li>
<li>注意「Client Hello」里的扩展，「supported_versions」表示这是 TLS1.3，「supported_groups」是支持的曲线，「key_share」是曲线对应的参数</li>
<li>服务器收到「Client Hello」同样返回「Server Hello」消息，还是要给出一个随机数(Server Random)和选定密码套件，表面上看和 TLS1.2 是一样的，重点是后面的扩展。「supported_versions」里确认使用的是 TLS1.3，然后在「key_share」扩展带上曲线和对应的公钥参数</li>
<li>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random和 Server Random、Client Params和Server Params，两边就可以各自用 ECDHE 算出「Pre-Master」，再用 HKDF 生成主密钥「Master Secret」，效率比 TLS1.2 提高了一大截</li>
<li>在算出主密钥后，服务器立刻发出「Change Cipher Spec」消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露</li>
<li>这里 TLS1.3 还有一个安全强化措施，多了个「Certificate Verify」消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和「Finished」消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改</li>
<li>这两个「Hello」消息之后，客户端验证服务器证书，再发「Finished」消息，就正式完成了握手，开始收发 HTTP 报文</li>
</ul>
</li>
</ul>
<h1 id="28-连接太慢该怎么办：HTTPS的优化"><a href="#28-连接太慢该怎么办：HTTPS的优化" class="headerlink" title="28 | 连接太慢该怎么办：HTTPS的优化"></a>28 | 连接太慢该怎么办：HTTPS的优化</h1><ul>
<li>Q:TLS握手过程中影响性能的部分有哪些呢<ul>
<li><img src="https://img.shiqi-lu.tech/20210322163414.png"></li>
</ul>
</li>
<li>Q:如何使用硬件优化的方式优化HTTPS<ul>
<li>1.选择更快的 CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输</li>
<li>2.选择“SSL 加速卡”，加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力</li>
<li>3.SSL 加速服务器，用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多</li>
</ul>
</li>
<li>Q:如何使用软件优化的方式优化HTTPS<ul>
<li>1.软件升级：把现在正在使用的软件尽量升级到最新版本，由于这些软件在更新版本的时候都会做性能优化、修复错误，只要运维能够主动配合，这种软件优化是最容易做的，也是最容易达成优化效果的</li>
<li>2.协议优化：尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全</li>
<li>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果</li>
<li>椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点</li>
<li>在 Nginx 里可以用“ssl_ciphers”“ssl_ecdh_curve”等指令配置服务器使用的密码套件和椭圆曲线，把优先使用的放在前面<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20;</span><br><span class="line">ssl_ecdh_curve X25519:P-256;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:如何进行证书优化<ul>
<li>1.证书传输<ul>
<li>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的“个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量</li>
</ul>
</li>
<li>2.证书验证<ul>
<li>客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加好几个 RTT</li>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</li>
<li>但 CRL 因为是“定期”发布，就有“时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上 MB。想象一下，每次需要预先下载几 M 的“无用数据”才能连接网站，实用性实在是太低了</li>
<li>所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态</li>
<li>但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的</li>
<li>于是又出来了一个“补丁”，叫“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间</li>
</ul>
</li>
</ul>
</li>
<li>Q:如何进行会话复用（TLS session resumption）的「Session ID」<ul>
<li>客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信</li>
<li>服务器在“ServerHello”消息后直接发送了“Change Cipher Spec”和“Finished”消息，复用会话完成了握手</li>
<li><img src="https://img.shiqi-lu.tech/20210322164911.png"></li>
<li>「Session ID」是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担</li>
</ul>
</li>
<li>Q:如何进行会话复用（TLS session resumption）的「Session Ticket」即会话票证<ul>
<li>有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存</li>
<li>重连的时候，客户端使用扩展“session_ticket”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信</li>
<li>不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天</li>
</ul>
</li>
<li>Q:如何进行预共享密钥<ul>
<li>“False Start”“Session ID”“Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了“0-RTT”，原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”</li>
<li><img src="https://img.shiqi-lu.tech/20210322165457.png"></li>
<li>但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送</li>
<li>解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放</li>
</ul>
</li>
</ul>
<h1 id="29-我应该迁移到HTTPS吗？"><a href="#29-我应该迁移到HTTPS吗？" class="headerlink" title="29 | 我应该迁移到HTTPS吗？"></a>29 | 我应该迁移到HTTPS吗？</h1><ul>
<li>Q:如何申请证书<ul>
<li>“Let’s Encrypt”一直在推动证书的自动化部署，为此还实现了专门的 ACME 协议（RFC8555）。有很多的客户端软件可以完成申请、验证、下载、更新的“一条龙”操作，比如 Certbot、acme.sh 等等</li>
<li>注意：</li>
<li>第一，申请证书时应当同时申请 RSA 和 ECDSA 两种证书，在 Nginx 里配置成双证书验证，这样服务器可以自动选择快速的椭圆曲线证书，同时也兼容只支持 RSA 的客户端</li>
<li>第二，如果申请 RSA 证书，私钥至少要 2048 位，摘要算法应该选用 SHA-2，例如 SHA256、SHA384 等</li>
<li>第三，出于安全的考虑，“Let’s Encrypt”证书的有效期很短，只有 90 天，时间一到就会过期失效，所以必须要定期更新。你可以在 crontab 里加个每周或每月任务，发送更新请求，不过很多 ACME 客户端会自动添加这样的定期任务，完全不用你操心</li>
</ul>
</li>
<li>Q:如何配置HTTPS<ul>
<li>在 Nginx 上非常简单，只要在“listen”指令后面加上参数“ssl”，再配上刚才的证书文件就可以实现最基本的 HTTPS<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen                443 ssl;</span><br><span class="line"> </span><br><span class="line">ssl_certificate       xxx_rsa.crt;  #rsa2048 cert</span><br><span class="line">ssl_certificate_key   xxx_rsa.key;  #rsa2048 private key</span><br><span class="line"> </span><br><span class="line">ssl_certificate       xxx_ecc.crt;  #ecdsa cert</span><br><span class="line">ssl_certificate_key   xxx_ecc.key;  #ecdsa private ke</span><br></pre></td></tr></table></figure></li>
<li>为了提高 HTTPS 的安全系数和性能，你还可以强制 Nginx 只支持 TLS1.2 以上的协议，打开“Session Ticket”会话复用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_protocols               TLSv1.2 TLSv1.3;</span><br><span class="line"> </span><br><span class="line">ssl_session_timeout         5m;</span><br><span class="line">ssl_session_tickets         on;</span><br><span class="line">ssl_session_ticket_key      ticket.key;</span><br></pre></td></tr></table></figure></li>
<li>密码套件的选择方面，我给你的建议是以服务器的套件优先。这样可以避免恶意客户端故意选择较弱的套件、降低安全等级，然后密码套件向 TLS1.3“看齐”，只使用 ECDHE、AES 和 ChaCha20，支持“False Start”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_prefer_server_ciphers   on;</span><br><span class="line"></span><br><span class="line">ssl_ciphers   ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-CHACHA20-POLY1305:ECDHE+AES128:!MD5:!SHA1;</span><br></pre></td></tr></table></figure></li>
<li>如果你的服务器上使用了 OpenSSL 的分支 BorringSSL，那么还可以使用一个特殊的“等价密码组”（Equal preference cipher groups）特性，它可以让服务器配置一组“等价”的密码套件，在这些套件里允许客户端优先选择，比如这么配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_ciphers </span><br><span class="line">[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305];</span><br></pre></td></tr></table></figure></li>
<li>如果客户端硬件没有 AES 优化，服务器就会顺着客户端的意思，优先选择与 AES“等价”的 ChaCha20 算法，让客户端能够快一点</li>
<li>全部配置完成后，你可以访问“<a href="https://www.ssllabs.com/">SSLLabs</a>”网站，测试网站的安全程度，它会模拟多种客户端发起测试，打出一个综合的评分</li>
</ul>
</li>
<li>Q:服务器名称指示是怎样？<ul>
<li>在 HTTP 协议里，多个域名可以同时在一个 IP 地址上运行，这就是“虚拟主机”，Web 服务器会使用请求头里的 Host 字段来选择</li>
<li>但在 HTTPS 里，因为请求头只有在 TLS 握手之后才能发送，在握手时就必须选择“虚拟主机”对应的证书，TLS 无法得知域名的信息，就只能用 IP 地址来区分。所以，最早的时候每个 HTTPS 域名必须使用独立的 IP 地址，非常不方便</li>
<li>这得用到 TLS 的“扩展”，给协议加个SNI（Server Name Indication）的“补充条款”。它的作用和 Host 字段差不多，客户端会在“Client Hello”时带上域名信息，这样服务器就可以根据名字而不是 IP 地址来选择证书</li>
</ul>
</li>
<li>Q:如何把原有的HTTP重定向到HTTPS服务<ul>
<li>可用「重定向跳转」技术，把不安全的 HTTP 网址用 301 或 302“重定向”到新的 HTTPS 网站，这在 Nginx 里也很容易做到，使用“return”或“rewrite”都可以<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return 301 https:&#x2F;&#x2F;$host$request_uri;             # 永久重定向</span><br><span class="line">rewrite ^  https:&#x2F;&#x2F;$host$request_uri permanent;   # 永久重定向</span><br></pre></td></tr></table></figure></li>
<li>但这种方式有两个问题。一个是重定向增加了网络成本，多出了一次请求；另一个是存在安全隐患，重定向的响应可能会被“中间人”窜改，实现“会话劫持”，跳转到恶意网站</li>
<li>可使用HSTS（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。HTTPS 服务器需要在发出的响应头里添加一个「Strict-Transport-Security」的字段，再设定一个有效期，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: max-age&#x3D;15768000; includeSubDomains</span><br></pre></td></tr></table></figure></li>
<li>相当于告诉浏览器：我这个网站必须严格使用 HTTPS 协议，在半年之内（182.5 天）都不允许用 HTTP，你以后就自己做转换吧，不要再来麻烦我了</li>
<li>有了“HSTS”的指示，以后浏览器再访问同样的域名的时候就会自动把 URI 里的“http”改成“https”，直接访问安全的 HTTPS 网站。这样“中间人”就失去了攻击的机会，而且对于客户端来说也免去了一次跳转，加快了连接速度</li>
<li>在配置文件里用“add_header”指令添加“HSTS”字段：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header Strict-Transport-Security max-age&#x3D;15768000; #182.5days</span><br></pre></td></tr></table></figure></li>
<li>那么 Chrome 浏览器只会在第一次连接时使用 HTTP 协议，之后就会都走 HTTPS 协议</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《透视HTTP协议》飞翔篇</title>
    <url>/http-perspective-3/</url>
    <content><![CDATA[<h1 id="30-时代之风（上）：HTTP-2特性概览"><a href="#30-时代之风（上）：HTTP-2特性概览" class="headerlink" title="30 | 时代之风（上）：HTTP/2特性概览"></a>30 | 时代之风（上）：HTTP/2特性概览</h1><ul>
<li>Q:HTTP/2怎么做头部压缩？<ul>
<li>开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率</li>
</ul>
</li>
<li>Q:HTTP/2怎么使用二进制<ul>
<li>把TCP协议的部分特性挪到了应用层，把原来的「Header+Body」的消息打散为数个小片的二进制「帧」(Frame)，用「HEADERS」帧存放头数据、「DATA」帧存放实体数据</li>
</ul>
</li>
<li>Q:HTTP/2的流(Stream)是什么？<ul>
<li>它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流ID。在里面的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文</li>
<li>因为「流」是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用「流」同时发送多个「碎片化」的消息，这就是常说的“多路复用”（Multiplexing）——多个往返通信都复用一个连接来处理</li>
<li>在「流」的层面上看，消息是一些有序的「帧」序列，而在「连接」的层面上看，消息是乱序收发的「帧」。多个请求/响应之间没有了顺序关系，不需要排队等待， 也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率</li>
<li><img src="https://img.shiqi-lu.tech/20210323130302.png"></li>
<li>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的「流」，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似</li>
<li>HTTP/2 还在一定程度上改变了传统的「请求 - 应答」工作模式，服务器不再是完全被动地响应请求，也可以新建「流」主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）</li>
</ul>
</li>
</ul>
<h1 id="31-时代之风（下）：HTTP-2内核剖析"><a href="#31-时代之风（下）：HTTP-2内核剖析" class="headerlink" title="31 | 时代之风（下）：HTTP/2内核剖析"></a>31 | 时代之风（下）：HTTP/2内核剖析</h1><ul>
<li>Q:HTTP/2的连接前言(connection preface)是什么<ul>
<li>由于 HTTP/2是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和 TLS 握手，TLS 握手成功之后，客户端必须要发送一个连接前言用来确认建立 HTTP/2 连接</li>
<li>这个连接前言是标准的HTTP/1请求报文，使用纯文本的ASCII码格式，请求方法是特别注册的一个关键字「PRI」，全文只有24个字节：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PRI * HTTP&#x2F;2.0\r\n\r\nSM\r\n\r\n</span><br></pre></td></tr></table></figure></li>
<li>在 Wireshark 里，HTTP/2 的连接前言被称为「Magic」，只要服务器收到这个「有魔力的字符串」，就知道客户端在 TLS 上想要的是 HTTP/2 协议，后面就会都使用 HTTP/2 的数据格式</li>
</ul>
</li>
<li>Q:HTTP/2的头部压缩是怎样？<ul>
<li>确立了连接之后，HTTP/2 就开始准备请求报文</li>
<li>因为语义上它与 HTTP/1 兼容，所以报文还是由「Header+Body」构成的，但在请求发送前，必须要用「HPACK」算法来压缩头部数据</li>
<li>「HPACK」算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，压缩和解压缩就是查表和更新表的操作</li>
<li>为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，即「伪头字段」(pseudo-header fields)。并废除起始行里的版本号和错误原因短语</li>
<li>伪头字段会在名字前加一个「:」，比如「:authority」、「:method」、「:status」，分别表示的是域名、请求方法和状态码</li>
<li>现在HTTP报文头全都是「Key-Value」形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的静态表（Static Table），如下表，如数字「2」代表「GET」，数字「8」代表状态码200</li>
<li><img src="https://img.shiqi-lu.tech/20210323144257.png"></li>
<li>但如果表里只有 Key 没有 Value，或者是自定义字段根本找不到就要用到“动态表”（Dynamic Table），它添加在静态表后面，结构相同，但会在编码解码的时候随时更新</li>
<li>如第一次发送请求时的「user-agent」字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号「65」。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好</li>
<li><img src="https://img.shiqi-lu.tech/20210323144506.png"></li>
<li>随着在 HTTP/2 连接上发送的报文越来越多，两边的「字典」也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多</li>
</ul>
</li>
<li>Q:HTTP/2的二进制帧是怎样<ul>
<li>头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送</li>
<li>HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节</li>
<li>二进制的格式也保证了不会有歧义，而且使用位运算能够非常简单高效地解析</li>
<li><img src="https://img.shiqi-lu.tech/20210323145002.png"></li>
<li>帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M</li>
<li>长度后面的一个字节是帧类型，大致可分为数据帧和控制帧两类，HEADERS帧和DATA帧属于数据帧，存放的HTTP报文，而SETTINGS、PING、PRIORITY等则是用来管理流的控制帧</li>
<li>HTTP/2 总共定义了 10 种类型的帧，但一个字节可以表示最多 256 种，所以也允许在标准之外定义其他类型实现功能扩展。比如 Google 的 gRPC 就利用了这个特点，定义了几种自用的新帧类型</li>
<li>第5个字节是帧标志，可以保存8个标志位，携带简单的控制信息。常用的标志位有END_HEADERS表示头数据结束，相当于HTTP/1里头后的空行「\r\0」，END_STREAM表示单方向数据发送接受(EOS，End Of Stream)，相当于HTTP/1里Chunked分块结束标志「\0\r\n\r\n」</li>
<li>报文投里最后4个字节是流标识符，即帧所属的「流」，接收方使用它就可从乱序的帧里识别出具有相同流ID的帧序列，按顺序组装起来就实现了虚拟的「流」</li>
<li>流标识符虽然有4个字节，但最高位被保留不用，所以只有31位可使用，即流标识符的上限是2^31，大约21亿</li>
</ul>
</li>
<li>Q:HTTP/2 的流与多路复用是怎样？<ul>
<li>流是二进制帧的双向传输序列</li>
<li>在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序</li>
<li>在概念上，一个 HTTP/2 的流就等同于一个 HTTP/1 里的「请求-应答」。在 HTTP/1 里一个「请求 - 响应」报文来回是一次 HTTP 通信，在 HTTP/2 里一个流也承载了相同的功能</li>
</ul>
</li>
<li>Q:HTTP/2 的流有哪些特点呢<ul>
<li>1.流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”</li>
<li>2.客户端和服务器都可以创建流，双方互不干扰</li>
<li>3.流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回</li>
<li>4.流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的</li>
<li>5.流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验</li>
<li>6.流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数</li>
<li>7.在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送</li>
<li>8.第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制</li>
</ul>
</li>
<li>Q:连接中无序的帧是如何依据流 ID 重组成流的<ul>
<li>在 Wireshark 抓包里，就有“0、1、3”一共三个流，实际上就是分配了三个流 ID 号，把这些帧按编号分组，再排一下队，就成了流</li>
<li><img src="https://img.shiqi-lu.tech/20210324075750.png"></li>
<li><img src="https://img.shiqi-lu.tech/20210324075756.png"></li>
<li>HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）</li>
<li>下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持</li>
<li>因为客户端和服务器两端都可以创建流，而流 ID 有奇数偶数和上限的区分，所以大多数的流 ID 都会是奇数，而且客户端在一个连接里最多只能发出 2^30，也就是 10 亿个请求</li>
<li>ID 用完了可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接</li>
</ul>
</li>
<li>Q:HTTP/2如何根据帧的标志位实现流状态转换<ul>
<li><img src="https://img.shiqi-lu.tech/20210324080322.png"></li>
<li>最开始的时候流都是空闲(idle)状态</li>
<li>当客户端发送HEADERS帧后，有了流ID，流就进入了「打开」状态，两端都可以收发数据，然后客户端发送一个带「END_STREAM」标志位的帧，流就进入了「半关闭」状态。意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据</li>
<li>响应数据发完了之后，也要带上「END_STREAM」标志位，表示数据发送完毕，这样流两端就都进入了关闭状态，流就结束了</li>
<li>流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的「请求 - 应答」，流关闭就是一次通信结束</li>
<li>下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送「GOAWAY」帧开一个新的 TCP 连接，流 ID 就又可以重头计数</li>
<li>因为流可以并发，所以 HTTP/2 就可以实现无阻塞的多路复用</li>
</ul>
</li>
</ul>
<h1 id="32-未来之路：HTTP-3展望"><a href="#32-未来之路：HTTP-3展望" class="headerlink" title="32 | 未来之路：HTTP/3展望"></a>32 | 未来之路：HTTP/3展望</h1><ul>
<li>Q:为什么HTTP/2没有完全解决队头阻塞呢？<ul>
<li>因为 HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”</li>
<li>从协议栈的角度来仔细看一下。在 HTTP/2 把多个“请求 - 响应”分解成流，交给 TCP 后，TCP 会再拆成更小的包依次发送（其实在 TCP 里应该叫 segment，也就 是“段”）</li>
<li>在网络良好的情况下，包可以很快送达目的地。但如果网络质量比较差，而 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能等待</li>
</ul>
</li>
<li>Q:不同HTTP协议栈图的对比<ul>
<li><img src="https://img.shiqi-lu.tech/20210324100732.png"></li>
</ul>
</li>
<li>Q:QUIC有什么特点？<ul>
<li>基于 UDP，而 UDP 是无连接的，不需要握手和挥手，所以比 TCP 快</li>
<li>基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响</li>
<li>为了防止网络上的中间设备（Middle Box）识别协议的细节，QUIC 全面采用加密通信，可以很好地抵御窜改和“协议僵化”（ossification）</li>
<li>直接应用了 TLS1.3，也就获得了 0-RTT、1-RTT 连接的好处</li>
<li>不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销</li>
</ul>
</li>
<li>Q:QUIC内部介绍<ul>
<li>QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”</li>
<li>QUIC 使用不透明的“连接 ID”来标记通信的两个端点，客户端和服务器可以自行选择一组 ID 来标记自己，这样就解除了 TCP 里连接对“IP 地址 + 端口”（即常说的四元组）的强绑定，支持“连接迁移”（Connection Migration）</li>
<li><img src="https://img.shiqi-lu.tech/20210324103531.png"></li>
<li>即当 IP 地址会发生变化，TCP 就必须重新建立连接。而 QUIC 连接里的两端连接 ID 不会变，所以连接在“逻辑上”没有中断，它就可以在新的 IP 地址上继续使用之前的连接，消除重连的成本，实现连接的无缝迁移</li>
<li>QUIC 的帧里有多种类型，PING、ACK 等帧用于管理连接，而 STREAM 帧专门用来实流</li>
<li>QUIC 里的流与 HTTP/2 的流非常相似，也是帧的序列，但 HTTP/2 里的流都是双向的，而 QUIC 则分为双向流和单向流</li>
<li><img src="https://img.shiqi-lu.tech/20210324103702.png"></li>
<li>QUIC 帧普遍采用变长编码，最少只要 1 个字节，最多有 8 个字节。流 ID 的最大可用位数是 62，数量上比 HTTP/2 的 2^31 大大增加</li>
<li>流 ID 还保留了最低两位用作标志，第 1 位标记流的发起者，0 表示客户端，1 表示服务器；第 2 位标记流的方向，0 表示双向流，1 表示单向流</li>
<li>所以 QUIC 流 ID 的奇偶性质和 HTTP/2 刚好相反，客户端的 ID 是偶数，从 0 开始计数</li>
</ul>
</li>
<li>Q:HTTP/3 协议<ul>
<li>因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数</li>
<li>HTTP/3 里使用QUIC流来发送「请求 - 响应」</li>
<li>HTTP/3 里的“双向流”可以完全对应到 HTTP/2 的流，而“单向流”在 HTTP/3 里用来实现控制和推送，近似地对应 HTTP/2 的 0 号流</li>
<li>HTTP/3 里帧的结构变简单了。帧头只有两个字段：类型和长度，而且同样都采用变长编码，最小只需要两个字节</li>
<li><img src="https://img.shiqi-lu.tech/20210324103944.png"></li>
<li>HTTP/3 里的帧仍然分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧传输数据，但其他一些帧因为在下层的 QUIC 里有了替代，所以在 HTTP/3 里就都消失了，比如 RST_STREAM、WINDOW_UPDATE、PING 等</li>
<li>头部压缩算法在 HTTP/3 里升级成了“QPACK”，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送 HEADERS 帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了 HPACK 的“队头阻塞”问题</li>
<li>另外，QPACK 的字典也做了优化，静态表由之前的 61 个增加到了 98 个，而且序号从 0 开始，也就是说“:authority”的编号是 0</li>
</ul>
</li>
<li>Q:HTTP/3 服务发现是怎样的呢<ul>
<li>用到 HTTP/2 里的“扩展帧”了。浏览器需要先用 HTTP/2 协议连接服务器，然后服务器可以在启动 HTTP/2 连接后发送一个“Alt-Svc”帧，包含一个“h3=host:port”的字符串，告诉浏览器在另一个端点上提供等价的 HTTP/3 服务。浏览器收到“Alt-Svc”帧，会使用 QUIC 异步连接指定的端口，如果连接成功，就会断开 HTTP/2 连接，改用新的 HTTP/3 收发数据</li>
</ul>
</li>
</ul>
<h1 id="33-我应该迁移到HTTP-2吗？"><a href="#33-我应该迁移到HTTP-2吗？" class="headerlink" title="33 | 我应该迁移到HTTP/2吗？"></a>33 | 我应该迁移到HTTP/2吗？</h1><ul>
<li>Q:HTTP/2 的优点是什么<ul>
<li>1.完全保持了与 HTTP/1 的兼容，在语义上没有任何变化</li>
<li>2.对 HTTPS 在各方面都做了强化。下层的 TLS 至少是 1.2，而且只能用前向安全的密码套件（即 ECDHE），这同时也就默认实现了“TLS False Start”，支持 1-RTT 握手，所以不需要再加额外的配置就可以自动实现 HTTPS 加速</li>
<li>3.在 HTTP/1 里只能压缩 body，而 HTTP/2 则可以用 HPACK 算法压缩 header，这对高流量的网站非常有价值，有数据表明能节省大概 5%~10% 的流量</li>
<li>4.HTTP/2 的“多路复用”特性要求对一个域名（或者 IP）只用一个 TCP 连接，所有的数据都在这一个连接上传输，这样不仅节约了客户端、服务器和网络的资源，还可以把带宽跑满</li>
<li>5.“优先级”可以让客户端告诉服务器，哪个文件更重要，更需要优先传输，服务器就可以调高流的优先级，合理地分配有限的带宽资源，让高优先级的 HTML、图片更快地到达客户端，尽早加载显示</li>
<li>6.“服务器推送”也是降低延迟的有效手段，它不需要客户端预先请求，服务器直接就发给客户端，这就省去了客户端解析 HTML 再请求的时间</li>
</ul>
</li>
<li>Q:HTTP/2 的缺点是什么<ul>
<li>在 TCP 级别还是存在“队头阻塞”的问题。所以，如果网络连接质量差，发生丢包，那么 TCP 会等待重传，传输速度就会降低</li>
<li>在移动网络中发生 IP 地址切换的时候，下层的 TCP 必须重新建连，要再次“握手”，经历“慢启动”，而且之前连接里积累的 HPACK 字典也都消失了，必须重头开始计算，导致带宽浪费和时延</li>
<li>HTTP/2 对一个域名只开一个连接，所以一旦这个连接出问题，那么整个网站的体验也就变差了</li>
</ul>
</li>
<li>Q:如何配置HTTP/2<ul>
<li>Nginx 里启用 HTTP/2 只需要在 server 配置里再多加一个参数就可以搞定<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl http2;</span><br><span class="line"> </span><br><span class="line">    server_name  www.xxx.net;</span><br><span class="line">    </span><br><span class="line">    ssl_certificate         xxx.crt;</span><br><span class="line">    ssl_certificate_key     xxx.key;</span><br></pre></td></tr></table></figure></li>
<li>“listen”指令在“ssl”后面多了一个“http2”，这就表示在 443 端口上开启了 SSL 加密，然后再启用 HTTP/2</li>
<li>配置服务器推送特性可以使用指令“http2_push”和“http2_push_preload”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http2_push         &#x2F;style&#x2F;xxx.css;</span><br><span class="line">http2_push_preload on;</span><br></pre></td></tr></table></figure></li>
<li>不过如何合理地配置推送是个难题，如果推送给浏览器不需要的资源，反而浪费了带宽</li>
<li>优化方面，HTTPS 的一些策略依然适用，比如精简密码套件、ECC 证书、会话复用、HSTS 减少重定向跳转等等</li>
<li>但还有一些优化手段在 HTTP/2 里是不适用的，而且还会有反效果，比如说常见的精灵图（Spriting）、资源内联（inlining）、域名分片（Sharding）等，至于原因是什么，我把它留给你自己去思考（提示，与缓存有关）</li>
<li>还要注意一点，HTTP/2 默认启用 header 压缩（HPACK），但并没有默认启用 body 压缩，所以不要忘了在 Nginx 配置文件里加上“gzip”指令，压缩 HTML、JS 等文本数据</li>
</ul>
</li>
<li>Q:HTTP/2 的“服务发现”，浏览器怎么知道服务器支持 HTTP/2 呢<ul>
<li>在 TLS 的扩展里，使用ALPN（Application Layer Protocol Negotiation）来与服务器就 TLS 上跑的应用协议进行“协商”</li>
<li>客户端在发起“Client Hello”握手的时候，后面会带上一个“ALPN”扩展，里面按照优先顺序列出客户端支持的应用协议</li>
<li>如下图，最优先的是“h2”，其次是“http/1.1”，以前还有“spdy”，以后还可能会有“h3”</li>
<li><img src="https://img.shiqi-lu.tech/20210324110303.png"></li>
<li>服务器看到 ALPN 扩展以后就可以从列表里选择一种应用协议，在“Server Hello”里也带上“ALPN”扩展，告诉客户端服务器决定使用的是哪一种。因为我们在 Nginx 配置里使用了 HTTP/2 协议，所以在这里它选择的就是“h2”</li>
<li><img src="https://img.shiqi-lu.tech/20210324110315.png"></li>
<li>这样在 TLS 握手结束后，客户端和服务器就通过“ALPN”完成了应用层的协议协商，后面就可以使用 HTTP/2 通信了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》学习笔记1-10章</title>
    <url>/mysql-crash-course-1-10/</url>
    <content><![CDATA[<h1 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h1><h1 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h1><h1 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h1><ul>
<li><p>Q:显示数据库列表</p>
<ul>
<li><code>show databases;</code></li>
</ul>
</li>
<li><p>Q:连接数据库</p>
<ul>
<li><code>use crashcourse</code></li>
</ul>
</li>
<li><p>Q:获得数据库内的表的列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| Tables_in_crashcourse |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| customers             |</span><br><span class="line">| orderitems            |</span><br><span class="line">| orders                |</span><br><span class="line">| productnotes          |</span><br><span class="line">| products              |</span><br><span class="line">| vendors               |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li><p>Q:显示表列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM customers;</span><br><span class="line">+<span class="comment">--------------+-----------+------+-----+---------+----------------+</span></span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">--------------+-----------+------+-----+---------+----------------+</span></span><br><span class="line">| cust_id      | int(11)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+<span class="comment">--------------+-----------+------+-----+---------+----------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>和使用<code>DESCRIBE customers;</code>一个效果</li>
</ul>
</li>
</ul>
<h1 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h1><ul>
<li>Q:检索单个列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select prod_name from products;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| prod_name      |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索多个列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name, prod_price FROM products;</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">| prod_id | prod_name      | prod_price |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">| ANV01   | .5 ton anvil   |       5.99 |</span><br><span class="line">| ANV02   | 1 ton anvil    |       9.99 |</span><br><span class="line">| ANV03   | 2 ton anvil    |      14.99 |</span><br><span class="line">| DTNTR   | Detonator      |      13.00 |</span><br><span class="line">| FB      | Bird seed      |      10.00 |</span><br><span class="line">| FC      | Carrots        |       2.50 |</span><br><span class="line">| FU1     | Fuses          |       3.42 |</span><br><span class="line">| JP1000  | JetPack 1000   |      35.00 |</span><br><span class="line">| JP2000  | JetPack 2000   |      55.00 |</span><br><span class="line">| OL1     | Oil can        |       8.99 |</span><br><span class="line">| SAFE    | Safe           |      50.00 |</span><br><span class="line">| SLING   | Sling          |       4.49 |</span><br><span class="line">| TNT1    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT2    | TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索所有列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM products;</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete <span class="keyword">with</span> handy hook                  |</span><br><span class="line">| ANV02   |    <span class="number">1001</span> | <span class="number">1</span> ton anvil    |       <span class="number">9.99</span> | <span class="number">1</span> ton anvil, black, <span class="keyword">complete</span> <span class="keyword">with</span> handy hook <span class="keyword">and</span> carrying <span class="keyword">case</span> |</span><br><span class="line">| ANV03   |    <span class="number">1001</span> | <span class="number">2</span> ton anvil    |      <span class="number">14.99</span> | <span class="number">2</span> ton anvil, black, <span class="keyword">complete</span> <span class="keyword">with</span> handy hook <span class="keyword">and</span> carrying <span class="keyword">case</span> |</span><br><span class="line">| DTNTR   |    <span class="number">1003</span> | Detonator      |      <span class="number">13.00</span> | Detonator (plunger powered), fuses <span class="keyword">not</span> included                |</span><br><span class="line">| FB      |    <span class="number">1003</span> | Bird <span class="keyword">seed</span>      |      <span class="number">10.00</span> | <span class="keyword">Large</span> bag (suitable <span class="keyword">for</span> road runners)                          |</span><br><span class="line">| FC      |    <span class="number">1003</span> | Carrots        |       <span class="number">2.50</span> | Carrots (rabbit hunting season <span class="keyword">only</span>)                           |</span><br><span class="line">| FU1     |    <span class="number">1002</span> | Fuses          |       <span class="number">3.42</span> | <span class="number">1</span> dozen, extra <span class="keyword">long</span>                                            |</span><br><span class="line">| JP1000  |    <span class="number">1005</span> | JetPack <span class="number">1000</span>   |      <span class="number">35.00</span> | JetPack <span class="number">1000</span>, intended <span class="keyword">for</span> single <span class="keyword">use</span>                          |</span><br><span class="line">| JP2000  |    <span class="number">1005</span> | JetPack <span class="number">2000</span>   |      <span class="number">55.00</span> | JetPack <span class="number">2000</span>, multi-<span class="keyword">use</span>                                        |</span><br><span class="line">| OL1     |    <span class="number">1002</span> | Oil can        |       <span class="number">8.99</span> | Oil can, red                                                   |</span><br><span class="line">| <span class="keyword">SAFE</span>    |    <span class="number">1003</span> | <span class="keyword">Safe</span>           |      <span class="number">50.00</span> | <span class="keyword">Safe</span> <span class="keyword">with</span> combination <span class="keyword">lock</span>                                     |</span><br><span class="line">| SLING   |    <span class="number">1003</span> | Sling          |       <span class="number">4.49</span> | Sling, one <span class="keyword">size</span> fits <span class="keyword">all</span>                                       |</span><br><span class="line">| TNT1    |    <span class="number">1003</span> | TNT (<span class="number">1</span> stick)  |       <span class="number">2.50</span> | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    <span class="number">1003</span> | TNT (<span class="number">5</span> sticks) |      <span class="number">10.00</span> | TNT, red, pack <span class="keyword">of</span> <span class="number">10</span> sticks                                    |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索并去重<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT vend_id FROM products;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| vend_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:只返回不多于5行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products LIMIT 5;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索返回从第5行开始的5行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products LIMIT 5,5;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| Carrots      |</span><br><span class="line">| Fuses        |</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">| Oil can      |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>其中第一个数表示开始的位置，从0开始，第二个数为要检索的行数</li>
<li>支持另一种语法<code>LIMIT 5 OFFSET 3</code>：从第3行开始取5行</li>
</ul>
</li>
<li>Q:使用完全限定的表名查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT products.prod_name FROM crashcourse.products;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| prod_name      |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第５章-排序检索数据"><a href="#第５章-排序检索数据" class="headerlink" title="第５章 排序检索数据"></a>第５章 排序检索数据</h1><ul>
<li>Q:检索数据并按字母顺序排列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products ORDER BY prod_name;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| prod_name      |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索时按照多个条件进行排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name </span><br><span class="line">    -&gt; FROM products ORDER BY prod_price, prod_name;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检索并降序排列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name </span><br><span class="line">    -&gt; FROM products ORDER BY prod_price DESC, prod_name;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第６章-过滤数据"><a href="#第６章-过滤数据" class="headerlink" title="第６章 过滤数据"></a>第６章 过滤数据</h1><ul>
<li>Q:根据指定的搜索条件进行过滤<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price = 2.50;</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| prod_name     | prod_price |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| Carrots       |       2.50 |</span><br><span class="line">| TNT (1 stick) |       2.50 |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:WHERE子句操作符的条件<ul>
<li><img src="https://img.shiqi-lu.tech/20210209151932.png"></li>
</ul>
</li>
<li>Q:使用不同WHERE条件的例子<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price &lt; 10;</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| prod_name     | prod_price |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| .5 ton anvil  |       5.99 |</span><br><span class="line">| 1 ton anvil   |       9.99 |</span><br><span class="line">| Carrots       |       2.50 |</span><br><span class="line">| Fuses         |       3.42 |</span><br><span class="line">| Oil can       |       8.99 |</span><br><span class="line">| Sling         |       4.49 |</span><br><span class="line">| TNT (1 stick) |       2.50 |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price BETWEEN 5 AND 10;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| .5 ton anvil   |       5.99 |</span><br><span class="line">| 1 ton anvil    |       9.99 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检查具有空值<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price IS NULL;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id</span><br><span class="line">    -&gt; FROM customers</span><br><span class="line">    -&gt; WHERE cust_email IS NULL;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| cust_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|   10002 |</span><br><span class="line">|   10005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h1><ul>
<li>Q:使用AND操作符组合WHERE子句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:使用OR操作符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id = 1002 OR vend_id = 1003;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:多条件组合<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:IN操作符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id IN (1002, 1003)</span><br><span class="line">    -&gt; ORDER BY prod_name;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:NOT操作符示例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id NOT IN (1002,1003)</span><br><span class="line">    -&gt; ORDER BY prod_name;</span><br><span class="line">+<span class="comment">--------------+------------+</span></span><br><span class="line">| prod_name    | prod_price |</span><br><span class="line">+<span class="comment">--------------+------------+</span></span><br><span class="line">| .5 ton anvil |       5.99 |</span><br><span class="line">| 1 ton anvil  |       9.99 |</span><br><span class="line">| 2 ton anvil  |      14.99 |</span><br><span class="line">| JetPack 1000 |      35.00 |</span><br><span class="line">| JetPack 2000 |      55.00 |</span><br><span class="line">+<span class="comment">--------------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h1><ul>
<li>Q:百分号%通配符示例<ul>
<li>可匹配0、1或多个字符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_name LIKE &#x27;jet%&#x27;;</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| JP1000  | JetPack 1000 |</span><br><span class="line">| JP2000  | JetPack 2000 |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:下划线_通配符示例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_name LIKE &#x27;_ ton anvil&#x27;;</span><br><span class="line">+<span class="comment">---------+-------------+</span></span><br><span class="line">| prod_id | prod_name   |</span><br><span class="line">+<span class="comment">---------+-------------+</span></span><br><span class="line">| ANV02   | 1 ton anvil |</span><br><span class="line">| ANV03   | 2 ton anvil |</span><br><span class="line">+<span class="comment">---------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h1><ul>
<li>Q:基本字符匹配<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_name REGEXP &#x27;1000&#x27;</span><br><span class="line">    -&gt; ORDER BY prod_name;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| JetPack 1000 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配范围<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_name REGEXP &#x27;[1-5] Ton&#x27;;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配特殊字符<ul>
<li><code>\\-</code>为查找<code>-</code>，<code>\\.</code>为查找<code>.</code>，<code>\\\</code>查找<code>\</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name </span><br><span class="line">    -&gt; FROM products </span><br><span class="line">    -&gt; WHERE prod_name REGEXP &#x27;\\.&#x27;;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>基本和Linux的正则没区别了，不展开</li>
</ul>
<h1 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h1><ul>
<li>Q:拼接字段的使用<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT Concat(vend_name, &#x27;  (&#x27;, vend_country, &#x27;)&#x27;)</span><br><span class="line">    -&gt; FROM vendors</span><br><span class="line">    -&gt; ORDER BY vend_name;</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| Concat(vend_name, &#x27;  (&#x27;, vend_country, &#x27;)&#x27;) |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| ACME  (USA)                                 |</span><br><span class="line">| Anvils R Us  (USA)                          |</span><br><span class="line">| Furball Inc.  (USA)                         |</span><br><span class="line">| Jet <span class="keyword">Set</span>  (England)                          |</span><br><span class="line">| Jouets Et Ours  (France)                    |</span><br><span class="line">| LT Supplies  (USA)                          |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:使用列别名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT Concat(vend_name, &#x27;  (&#x27;, vend_country, &#x27;)&#x27;) AS vend_title</span><br><span class="line">    -&gt; FROM vendors</span><br><span class="line">    -&gt; ORDER BY vend_name;</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| vend_title               |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| ACME  (USA)              |</span><br><span class="line">| Anvils R Us  (USA)       |</span><br><span class="line">| Furball Inc.  (USA)      |</span><br><span class="line">| Jet <span class="keyword">Set</span>  (England)       |</span><br><span class="line">| Jouets Et Ours  (France) |</span><br><span class="line">| LT Supplies  (USA)       |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:进行计算<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id,</span><br><span class="line">    -&gt;        quantity,</span><br><span class="line">    -&gt;        item_price,</span><br><span class="line">    -&gt;        quantity*item_price AS expanded_price</span><br><span class="line">    -&gt; FROM orderitems</span><br><span class="line">    -&gt; WHERE order_num = 20005;</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch第一周学习笔记</title>
    <url>/pytorch-week1/</url>
    <content><![CDATA[<p>最原始编辑版在<a href="https://nbviewer.jupyter.org/github/shiqi-lu/Learn-AI/blob/master/pytorch_deepshare/week1.ipynb">Github链接</a></p>
<h1 id="1-PyTorch简介与安装"><a href="#1-PyTorch简介与安装" class="headerlink" title="1.PyTorch简介与安装"></a>1.PyTorch简介与安装</h1><p>Q:如何安装Pytorch?</p>
<ul>
<li>安装anaconda：<code>conda install pytorch torchvision</code></li>
<li>测试是否安装成功：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cuda.is_available()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.__version__</span><br><span class="line"><span class="string">&#x27;1.3.1&#x27;</span></span><br></pre></td></tr></table></figure>


<h1 id="2-张量简介与创建"><a href="#2-张量简介与创建" class="headerlink" title="2.张量简介与创建"></a>2.张量简介与创建</h1><p>Q:张量是什么？</p>
<ul>
<li>一个多维数组，它是标量、向量、矩阵的高维拓展</li>
<li><img src="https://img.shiqi-lu.tech/20200918142143.png?imageView2/2/h/150"></li>
</ul>
<p>Q:Pytorch中的Variable是什么？与Tensor的关系是什么？</p>
<ul>
<li>Variable是torch.autograd中的数据类型主要用于封装Tensor，进行自动求导</li>
<li>data:被包装的Tensor</li>
<li>grad:data的梯度</li>
<li>grad_fn:创建Tensor的Function，是自动求导的关键</li>
<li>requires_grad:指示是否需要梯度</li>
<li>is_leaf:指示是否是叶子结点（张量）</li>
<li><img src="https://img.shiqi-lu.tech/20200918143346.png?imageView2/2/w/200"></li>
</ul>
<p>Q:Pytorch中的Tensor是什么？</p>
<ul>
<li>PyTorch 0.4.0开始，Variable并入Tensor</li>
<li>dtype: 张量的数据类型，如torch.FloatTensor, torch.cuda.FloatTensor</li>
<li>shape: 张量的形状，如（64，3， 224， 224）</li>
<li>device: 张量所在设备，GPU/CPU，是加速的关键</li>
<li><img src="https://img.shiqi-lu.tech/20200918143722.png?imageView2/2/h/100"></li>
</ul>
<p>Q:Tensor的函数原型是怎样？</p>
<ul>
<li><code>torch.tensor(data, dtype=None, device=None, requires_grad=False, pin_memory=False)</code></li>
<li>功能：从data创建tensor</li>
<li>data: 数据，可以是list，numpy</li>
<li>dtype: 数据类型，默认与data一致</li>
<li>device: 所在设备，cuda/cpu</li>
<li>requires_grad: 是否需要梯度</li>
<li>pin_memory:是否存于锁页内存</li>
</ul>
<p>Q:通过torch.tensor创建Tensor的代码是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">&#x27;ndarray的数据类型:&#x27;</span>, arr.dtype)</span><br><span class="line"></span><br><span class="line">t = torch.tensor(arr)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放到gpu上</span></span><br><span class="line">t = torch.tensor(arr, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>

<pre><code>[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
ndarray的数据类型: float64
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]], dtype=torch.float64)
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]], device=&#39;cuda:0&#39;, dtype=torch.float64)</code></pre>
<p>Q:如何通过torch.from_numpy创建张量？</p>
<ul>
<li>函数原型：<code>torch.from_numpy(ndarray)</code></li>
<li>功能：从numpy创建tensor</li>
<li>注意事项：从torch.from_numpy创建的tensor于原ndarray共享内存，当修改其中一个的数据，另外一个也将会被改动</li>
<li><img src="https://img.shiqi-lu.tech/20200918151039.png?imageView2/2/h/150"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">t = torch.from_numpy(arr)</span><br><span class="line">print(<span class="string">&quot;numpy array:&quot;</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">&quot;tensor:&quot;</span>)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;修改arr:&quot;</span>)</span><br><span class="line">arr[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">print(<span class="string">&quot;numpy array:&quot;</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">&quot;tensor:&quot;</span>)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;修改tensor:&quot;</span>)</span><br><span class="line">arr[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">-10</span></span><br><span class="line">print(<span class="string">&quot;numpy array:&quot;</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">&quot;tensor:&quot;</span>)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>

<pre><code>numpy array:
[[1 2 3]
 [4 5 6]]
tensor:
tensor([[1, 2, 3],
        [4, 5, 6]])
修改arr:
numpy array:
[[0 2 3]
 [4 5 6]]
tensor:
tensor([[0, 2, 3],
        [4, 5, 6]])
修改tensor:
numpy array:
[[  0   2   3]
 [  4 -10   6]]
tensor:
tensor([[  0,   2,   3],
        [  4, -10,   6]])</code></pre>
<p>Q:如何通过torch.zeros或torch.ones创建张量？</p>
<ul>
<li>函数原型：<code>torch.zeros(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>函数原型：<code>torch.ones(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>功能：依size创建全0张量和全1</li>
<li>size:张量的形状</li>
<li>out:输出的张量，貌似其原始类型必须为tensor，通过out得到的和返回值得到的是完全一样的，相当于赋值</li>
<li>layout:内存中布局形式，有strided,sparse_coo等</li>
<li>device:所在设备,gpu/cpu</li>
<li>requires_grad: 是否需要梯度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out_t = torch.tensor([<span class="number">1</span>])</span><br><span class="line">t = torch.zeros((<span class="number">3</span>,<span class="number">3</span>), out=out_t)</span><br><span class="line">print(t)</span><br><span class="line">print(out_t)</span><br><span class="line">print(id(t), id(out_t), id(t) == id(out_t))</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
140556294938560 140556294938560 True</code></pre>
<p>Q:如何通过torch.zeros_like或torch.ones_like创建张量？</p>
<ul>
<li>函数原型：<code>torch.zeros_like(input, dtype=None, layout=None, device=None, requires_grad=False)</code></li>
<li>函数原型：<code>torch.ones_like(input, dtype=None, layout=None, device=None, requires_grad=False)</code></li>
<li>功能：依input形状创建全0张量或全1，input是一个tensor类型</li>
<li>input:创建与input同形状的全0张量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.empty(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(torch.zeros_like(t))</span><br><span class="line">print(torch.ones_like(t))</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[0., 0., 0.],
        [0., 0., 0.]])
tensor([[1., 1., 1.],
        [1., 1., 1.]])</code></pre>
<p>Q:如何通过torch.full创建张量？</p>
<ul>
<li><code>torch.full(size, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li><code>torch.full_like(input, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format)</code></li>
<li>功能：创建全等张量</li>
<li>size: 张量的形状，如（3,3）</li>
<li>fill_value: 张量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.full((<span class="number">3</span>,<span class="number">3</span>), <span class="number">8</span>)</span><br></pre></td></tr></table></figure>


<pre><code>tensor([[8., 8., 8.],
        [8., 8., 8.],
        [8., 8., 8.]])</code></pre>
<p>Q:如何通过torch.arange创建等差数列的1维张量？</p>
<ul>
<li>函数原型：<code>torch.arange(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>功能：创建等差为1的张量</li>
<li>注意事项：数值区间为[start, end)</li>
<li>start: 数列起始值</li>
<li>end: 数列“结束值”</li>
<li>step: 数列公差，默认为1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arange(<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>tensor([2, 4, 6, 8])</code></pre>
<p>Q:如何通过torch.linspace创建均分数列张量</p>
<ul>
<li>函数原型：<code>torch.linspace(start=0, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>功能：创建均分的1维张量</li>
<li>注意事项：数值区间为[start, end]</li>
<li>start: 数列起始值</li>
<li>end: 数列结束值</li>
<li>steps: 数列长度</li>
<li>步长为：(end-start)/(steps-1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.linspace(<span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>




<pre><code>tensor([ 2.0000,  3.3333,  4.6667,  6.0000,  7.3333,  8.6667, 10.0000])</code></pre>
<p>Q:如何通过torch.logspace创建对数均分的1维张量？</p>
<ul>
<li>函数原型：<code>torch.logspace(start, end, steps=100, base=10.0, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>功能：创建对数均分的1维张量</li>
<li>注意事项：长度为steps，底为base</li>
<li>base: 对数函数的低，默认为10</li>
</ul>
<p>Q:如何通过torch.eye创建单位对角矩阵？</p>
<ul>
<li>函数原型：<code>torch.eye(n, m=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False)</code></li>
<li>功能：创建单位对角矩阵（2维张量）</li>
<li>注意事项：默认为方阵</li>
<li>n: 矩阵行数</li>
<li>m: 矩阵列数</li>
</ul>
<p>Q:如何通过torch.normal生成正态分布的张量？</p>
<ul>
<li>函数原型：<code>torch.normal(mean, std, *, generator=None, out=None)</code></li>
<li>功能：生成正态分布（高斯分布）</li>
<li>mean: 均值</li>
<li>std: 标准差</li>
<li>因mean和std可以分别为标量和张量，有4种不同的组合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mean：张量 std: 张量</span></span><br><span class="line"><span class="comment"># 其中t[i]是从mean[i],std[i]的标准正态分布中采样得来</span></span><br><span class="line">mean = torch.arange(<span class="number">1</span>, <span class="number">5</span>, dtype=torch.float)</span><br><span class="line">std = torch.arange(<span class="number">1</span>, <span class="number">5</span>, dtype=torch.float)</span><br><span class="line">t = torch.normal(mean, std)</span><br><span class="line">print(<span class="string">&quot;mean:&#123;&#125;\nstd:&#123;&#125;&quot;</span>.format(mean, std))</span><br><span class="line">print(t)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"><span class="comment"># mean：标量 std: 标量，此时要指定size大小</span></span><br><span class="line">t_normal = torch.normal(<span class="number">0.</span>, <span class="number">1.</span>, size=(<span class="number">4</span>,))</span><br><span class="line">print(t_normal)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"><span class="comment"># mean：张量 std: 标量</span></span><br><span class="line">mean = torch.arange(<span class="number">1</span>, <span class="number">5</span>, dtype=torch.float)</span><br><span class="line">std = <span class="number">1</span></span><br><span class="line">t_normal = torch.normal(mean, std)</span><br><span class="line">print(<span class="string">&quot;mean:&#123;&#125;\nstd:&#123;&#125;&quot;</span>.format(mean, std))</span><br><span class="line">print(t_normal)</span><br></pre></td></tr></table></figure>

<pre><code>mean:tensor([1., 2., 3., 4.])
std:tensor([1., 2., 3., 4.])
tensor([ 0.6063,  2.9914,  4.0138, -0.5877])

tensor([ 1.1977, -0.1746,  1.5572, -1.1905])

mean:tensor([1., 2., 3., 4.])
std:1
tensor([0.7165, 1.5649, 3.2308, 3.2504])</code></pre>
<p>Q:如何创建标准正态分布的张量？</p>
<ul>
<li><code>torch.randn(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code></li>
<li><code>torch.randn_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) → Tensor</code></li>
<li>size:张量的形状</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(torch.randn(<span class="number">4</span>))</span><br><span class="line">print(torch.randn(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<pre><code>tensor([-0.2387, -0.3638,  0.3597,  0.1225])
tensor([[ 0.4709,  0.8593, -0.5970],
        [-0.1133,  0.3273,  0.0106]])</code></pre>
<p>Q:如何生成均匀分布和整数均匀分布的张量？</p>
<ul>
<li>在[0,1)区间上，生成均匀分布</li>
<li><code>torch.rand(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code></li>
<li><code>torch.rand_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) → Tensor</code></li>
<li>在[low, high)区间生成整数均匀分布</li>
<li><code>torch.randint(low=0, high, size, *, generator=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code></li>
<li><code>torch.randint_like(input, low=0, high, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) → Tensor</code></li>
<li>其中size是张量形状</li>
</ul>
<p>Q:如何生成从0到n-1的随机排列？</p>
<ul>
<li><code>torch.randperm(n, out=None, dtype=torch.int64, layout=torch.strided, device=None, requires_grad=False) → LongTensor</code></li>
<li>n是张量的长度</li>
<li>经常用于生成乱序索引</li>
</ul>
<p>Q:如何生成一个伯努利分布的张量？</p>
<ul>
<li><code>torch.bernoulli(input, *, generator=None, out=None) → Tensor</code></li>
<li>以input为概率，生成伯努利分布（0-1分布，两点分布）</li>
</ul>
<h1 id="3-张量操作与线性回归"><a href="#3-张量操作与线性回归" class="headerlink" title="3.张量操作与线性回归"></a>3.张量操作与线性回归</h1><h2 id="张量的操作：拼接、切分、索引和变换"><a href="#张量的操作：拼接、切分、索引和变换" class="headerlink" title="张量的操作：拼接、切分、索引和变换"></a>张量的操作：拼接、切分、索引和变换</h2><p>Q:如何用torch.cat对张量进行拼接？</p>
<ul>
<li><code>torch.cat(tensors, dim=0, out=None) → Tensor</code></li>
<li>功能：将张量按维度dim进行拼接</li>
<li>tensors: 张量序列</li>
<li>dim：要拼接的维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(t)</span><br><span class="line">t1 = torch.cat([t,t], dim=<span class="number">0</span>)</span><br><span class="line">print(t1)</span><br><span class="line">print(<span class="string">&quot;shape:&quot;</span>, t1.shape)</span><br><span class="line">t2 = torch.cat([t,t], dim=<span class="number">1</span>)</span><br><span class="line">print(t2)</span><br><span class="line">print(<span class="string">&quot;shape:&quot;</span>, t2.shape)</span><br><span class="line"><span class="comment"># dim是指在哪个方向上进行叠加</span></span><br></pre></td></tr></table></figure>

<pre><code>tensor([[-0.6851,  0.0099, -1.4586],
        [ 0.2965,  0.4991, -0.4938]])
tensor([[-0.6851,  0.0099, -1.4586],
        [ 0.2965,  0.4991, -0.4938],
        [-0.6851,  0.0099, -1.4586],
        [ 0.2965,  0.4991, -0.4938]])
shape: torch.Size([4, 3])
tensor([[-0.6851,  0.0099, -1.4586, -0.6851,  0.0099, -1.4586],
        [ 0.2965,  0.4991, -0.4938,  0.2965,  0.4991, -0.4938]])
shape: torch.Size([2, 6])</code></pre>
<p>Q:如何用torch.stack对张量进行拼接？</p>
<ul>
<li><code>torch.stack(tensors, dim=0, out=None) → Tensor</code></li>
<li>功能：在新创建的维度dim上进行拼接</li>
<li>tensors:张量序列</li>
<li>dim：要拼接的维度</li>
<li>注意：cat不会扩张张量的维度，stack会扩张，相当于insert</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(t)</span><br><span class="line">t1 = torch.stack([t,t], dim=<span class="number">0</span>)</span><br><span class="line">print(t1)</span><br><span class="line">print(<span class="string">&quot;shape:&quot;</span>, t1.shape)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[ 0.6266,  0.8918,  0.6165],
        [ 1.1646, -1.8152, -0.7309]])
tensor([[[ 0.6266,  0.8918,  0.6165],
         [ 1.1646, -1.8152, -0.7309]],

        [[ 0.6266,  0.8918,  0.6165],
         [ 1.1646, -1.8152, -0.7309]]])
shape: torch.Size([2, 2, 3])</code></pre>
<p>Q:如何用torch.chunk对切分张量？</p>
<ul>
<li><code>torch.chunk(input, chunks, dim=0) → List of Tensors</code></li>
<li>功能：将张量按维度dim进行平均切分</li>
<li>返回值：张量列表</li>
<li>注意事项：若不能整除，最后一份张量小于其它张量</li>
<li>input：要切分的张量</li>
<li>chunks：要切分的份数</li>
<li>dim：要切分的维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones((<span class="number">2</span>,<span class="number">7</span>))</span><br><span class="line">print(a)</span><br><span class="line">list_of_tensors = torch.chunk(a, dim=<span class="number">1</span>, chunks=<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(list_of_tensors):</span><br><span class="line">    print(<span class="string">f&quot;第<span class="subst">&#123;i&#125;</span>个张量：&quot;</span>)</span><br><span class="line">    print(t)</span><br><span class="line"><span class="comment"># 切分后的长度的计算方式为：7/3向上取整为3</span></span><br></pre></td></tr></table></figure>

<pre><code>tensor([[1., 1., 1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1., 1., 1.]])
第0个张量：
tensor([[1., 1., 1.],
        [1., 1., 1.]])
第1个张量：
tensor([[1., 1., 1.],
        [1., 1., 1.]])
第2个张量：
tensor([[1.],
        [1.]])</code></pre>
<p>Q:如何用torch.split对张量进行切分？</p>
<ul>
<li><code>torch.split(tensor, split_size_or_sections, dim=0)</code></li>
<li>功能：将张量按维度dim进行平均切分</li>
<li>返回值：张量列表</li>
<li>tensor：要切分的张量</li>
<li>split_size_or_sections：为int时，表示每一份的长度；为list时，按list元素切分，list元素和必须为该维度的长度</li>
<li>dim：要切分的维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones((<span class="number">2</span>,<span class="number">7</span>))</span><br><span class="line">print(a)</span><br><span class="line">list_of_tensors = torch.split(a, [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], dim=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(list_of_tensors):</span><br><span class="line">    print(<span class="string">f&quot;第<span class="subst">&#123;i&#125;</span>个张量：&quot;</span>)</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[1., 1., 1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1., 1., 1.]])
第0个张量：
tensor([[1., 1.],
        [1., 1.]])
第1个张量：
tensor([[1., 1., 1., 1.],
        [1., 1., 1., 1.]])
第2个张量：
tensor([[1.],
        [1.]])</code></pre>
<p>Q:如何在dim维度上，按index索引数据？</p>
<ul>
<li><code>torch.index_select(input, dim, index, out=None) → Tensor</code></li>
<li>返回值：按index索引数据拼接的张量</li>
<li>input：要索引的张量</li>
<li>dim：要索引的维度</li>
<li>index：要索引数据的序号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.randint(<span class="number">0</span>,<span class="number">9</span>, size=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">idx = torch.tensor([<span class="number">0</span>,<span class="number">2</span>], dtype=torch.long)</span><br><span class="line">t_select = torch.index_select(t, dim=<span class="number">0</span>, index=idx)</span><br><span class="line">print(t)</span><br><span class="line">print(idx)</span><br><span class="line">print(t_select)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[1, 2, 8],
        [2, 3, 0],
        [0, 2, 0]])
tensor([0, 2])
tensor([[1, 2, 8],
        [0, 2, 0]])</code></pre>
<p>Q:如何对张量按mask中的True进行索引？</p>
<ul>
<li><code>torch.masked_select(input, mask, out=None) → Tensor</code></li>
<li>返回值：一维张量</li>
<li>input：要索引的张量</li>
<li>mask：与input同形状的布尔类型张量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.randint(<span class="number">0</span>, <span class="number">9</span>, size=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(t)</span><br><span class="line">mask = t.le(<span class="number">5</span>) <span class="comment"># le是小于等于，还有lt,gt,ge</span></span><br><span class="line">print(mask)</span><br><span class="line">t_select = torch.masked_select(t, mask)</span><br><span class="line">print(t_select)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[2, 5, 0],
        [5, 8, 5],
        [2, 8, 5]])
tensor([[ True,  True,  True],
        [ True, False,  True],
        [ True, False,  True]])
tensor([2, 5, 0, 5, 5, 2, 5])</code></pre>
<p>Q:如何改变张量的形状？</p>
<ul>
<li><code>torch.reshape(input, shape) → Tensor</code></li>
<li>注意事项：当张量在内存中是连续时，新张量与input共享数据内存</li>
<li>input：要变换的张量</li>
<li>shape：新张量的形状，允许某个维度为-1，意味着这个维度根据其它的算出来的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.randperm(<span class="number">8</span>)</span><br><span class="line">t_reshape = torch.reshape(t, (<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(t)</span><br><span class="line">print(t_reshape)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([2, 0, 7, 5, 6, 4, 3, 1])
tensor([[2, 0, 7, 5],
        [6, 4, 3, 1]])</code></pre>
<p>Q:如何交换张量的两个维度？</p>
<ul>
<li><code>torch.transpose(input, dim0, dim1) → Tensor</code></li>
<li>input：要交换的张量</li>
<li>dim0，dim1：要交换的维度</li>
<li>若为2维张量转置，即矩阵转置，可使用<code>torch.t(input) → Tensor</code>，等价于<code>torch.transpose(input, 0, 1)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.rand((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">t_transpose = torch.transpose(t, dim0=<span class="number">1</span>,dim1=<span class="number">2</span>)</span><br><span class="line">print(t)</span><br><span class="line">print(t_transpose)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([[[0.8657, 0.5869, 0.1105, 0.4381],
         [0.7276, 0.6606, 0.3778, 0.3643],
         [0.6180, 0.6693, 0.9983, 0.4252]],

        [[0.3526, 0.6365, 0.6643, 0.5310],
         [0.4653, 0.5056, 0.1065, 0.7873],
         [0.6175, 0.6650, 0.1325, 0.5837]]])
tensor([[[0.8657, 0.7276, 0.6180],
         [0.5869, 0.6606, 0.6693],
         [0.1105, 0.3778, 0.9983],
         [0.4381, 0.3643, 0.4252]],

        [[0.3526, 0.4653, 0.6175],
         [0.6365, 0.5056, 0.6650],
         [0.6643, 0.1065, 0.1325],
         [0.5310, 0.7873, 0.5837]]])</code></pre>
<p>Q:如何压缩长度为1的维度（轴）？</p>
<ul>
<li><code>torch.squeeze(input, dim=None, out=None) → Tensor</code></li>
<li>dim: 若为None，移除所有长度为1的轴；若指定维度，当且仅当该轴长度为1时，可以被移除</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.rand((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">t_sq = torch.squeeze(t)</span><br><span class="line">t_0 = torch.squeeze(t, dim=<span class="number">0</span>)</span><br><span class="line">t_1 = torch.squeeze(t, dim=<span class="number">1</span>)</span><br><span class="line">print(t.shape)</span><br><span class="line">print(t_sq.shape)</span><br><span class="line">print(t_0.shape)</span><br><span class="line">print(t_1.shape)</span><br></pre></td></tr></table></figure>

<pre><code>torch.Size([1, 2, 3, 1])
torch.Size([2, 3])
torch.Size([2, 3, 1])
torch.Size([1, 2, 3, 1])</code></pre>
<p>Q:如何根据dim扩展维度？</p>
<ul>
<li><code>torch.unsqueeze(input, dim) → Tensor</code></li>
<li>dim:扩展的维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(t)</span><br><span class="line">t1 = torch.unsqueeze(t, <span class="number">0</span>)</span><br><span class="line">print(t1)</span><br><span class="line">t2 = torch.unsqueeze(t, <span class="number">1</span>)</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([1, 2, 3, 4])
tensor([[1, 2, 3, 4]])
tensor([[1],
        [2],
        [3],
        [4]])</code></pre>
<h2 id="张量的数学运算"><a href="#张量的数学运算" class="headerlink" title="张量的数学运算"></a>张量的数学运算</h2><p>Q:有哪些常见的数学运算？</p>
<ul>
<li>一、加减乘除<ul>
<li>torch.add()</li>
<li>torch.addcdiv()</li>
<li>torch.addcmul()</li>
<li>torch.sub() </li>
<li>torch.div()</li>
<li>torch.mul()</li>
</ul>
</li>
<li>二、对数，指数，幂函数<ul>
<li>torch.log(input, out=None)</li>
<li>torch.log10(input, out=None)</li>
<li>torch.log2(input, out=None)</li>
<li>torch.exp(input, out=None)</li>
<li>torch.pow()</li>
</ul>
</li>
<li>三、三角函数<ul>
<li>torch.abs(input, out=None)</li>
<li>torch.acos(input, out=None)</li>
<li>torch.cosh(input, out=None)</li>
<li>torch.cos(input, out=None)</li>
<li>torch.asin(input, out=None)</li>
<li>torch.atan(input, out=None)</li>
<li>torch.atan2(input, other, out=None)</li>
</ul>
</li>
</ul>
<p>Q:如何逐元素计算input + alpha x other?</p>
<ul>
<li><code>torch.add(input, other, *, alpha=1, out=None)</code></li>
<li>input：第一个张量</li>
<li>alpha：乘项因子</li>
<li>other：第二个张量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_0 = torch.randn((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">t_1 = torch.ones_like(t_0)</span><br><span class="line">t_add = torch.add(t_0, t_1, alpha=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;t_0:\n&#123;&#125;\nt_1:\n&#123;&#125;\nt_add_10:\n&#123;&#125;&quot;</span>.format(t_0, t_1, t_add))</span><br></pre></td></tr></table></figure>

<pre><code>t_0:
tensor([[ 0.5570, -0.4743,  1.0113],
        [-1.2665,  0.1997, -0.6957],
        [-0.0714, -0.7002, -1.4687]])
t_1:
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]])
t_add_10:
tensor([[10.5570,  9.5257, 11.0113],
        [ 8.7335, 10.1997,  9.3043],
        [ 9.9286,  9.2998,  8.5313]])</code></pre>
<p>Q:如何计算$\text { out }<em>{i}=\text { input }</em>{i}+\text { value } \times \text { tensor } 1_{i} \times \text { tensor } 2_{i}$</p>
<ul>
<li><code>torch.addcmul(input, tensor1, tensor2, *, value=1, out=None) → Tensor</code></li>
</ul>
<p>Q:如何计算$\text { out }<em>{i}=\text { input }</em>{i}+\text { value } \times \frac{\text { tensor } 1}{\text { tensor } 2_{i}}$</p>
<ul>
<li><code>torch.addcdiv(input, tensor1, tensor2, *, value=1, out=None) → Tensor</code></li>
</ul>
<h2 id="线性回归的Pytorch实现"><a href="#线性回归的Pytorch实现" class="headerlink" title="线性回归的Pytorch实现"></a>线性回归的Pytorch实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">torch.manual_seed(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.05</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建训练数据</span></span><br><span class="line">x = torch.rand(<span class="number">20</span>, <span class="number">1</span>) * <span class="number">10</span>  <span class="comment"># x data (tensor), shape=(20, 1)</span></span><br><span class="line">y = <span class="number">2</span>*x + (<span class="number">5</span> + torch.randn(<span class="number">20</span>, <span class="number">1</span>))  <span class="comment"># y data (tensor), shape=(20, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建线性回归参数的初始值</span></span><br><span class="line">w = torch.randn((<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros((<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播，计算y_pred=w * x+b</span></span><br><span class="line">    wx = torch.mul(w, x)</span><br><span class="line">    y_pred = torch.add(wx, b)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 MSE loss</span></span><br><span class="line">    loss = (<span class="number">0.5</span> * (y - y_pred) ** <span class="number">2</span>).mean()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    b.data.sub_(lr * b.grad)</span><br><span class="line">    w.data.sub_(lr * w.grad)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清零张量的梯度</span></span><br><span class="line">    w.grad.zero_()</span><br><span class="line">    b.grad.zero_()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    <span class="keyword">if</span> iteration % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(x.data.numpy(), y.data.numpy())</span><br><span class="line">        plt.plot(x.data.numpy(), y_pred.data.numpy(), <span class="string">&#x27;r-&#x27;</span>, lw=<span class="number">5</span>)</span><br><span class="line">        plt.text(<span class="number">2</span>, <span class="number">20</span>, <span class="string">&#x27;Loss=%.4f&#x27;</span> % loss.data.numpy(), fontdict=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;color&#x27;</span>:  <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">        plt.xlim(<span class="number">1.5</span>, <span class="number">10</span>)</span><br><span class="line">        plt.ylim(<span class="number">8</span>, <span class="number">28</span>)</span><br><span class="line">        plt.title(<span class="string">f&quot;Iteration: <span class="subst">&#123;iteration&#125;</span>\nw: <span class="subst">&#123;w.data.numpy()&#125;</span> b: <span class="subst">&#123;b.data.numpy()&#125;</span>&quot;</span>)</span><br><span class="line">        plt.pause(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> loss.data.numpy() &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.shiqi-lu.tech/20200920095346.png"></p>
<h1 id="4-计算图与动态图机制"><a href="#4-计算图与动态图机制" class="headerlink" title="4.计算图与动态图机制"></a>4.计算图与动态图机制</h1><p>Q:计算图是什么？</p>
<ul>
<li>用来描述运算的有向无环图</li>
<li>有两个主要元素：结点（Node）和边（Edge）</li>
<li>结点表示数据，如向量、矩阵、张量，边表示运算，如加减乘除卷积等</li>
</ul>
<p>Q:如何用计算图表示$y = (x+w)*(w+1)$?</p>
<ul>
<li>$a = x + w, b = w + 1, y = a * b$</li>
<li><img src="https://img.shiqi-lu.tech/20200919144309.png?imageView2/2/h/200"></li>
</ul>
<p>Q:如何用计算图进行梯度求导，如$y = (x+w)*(w+1)$</p>
<ul>
<li>$a = x + w, b = w + 1, y = a * b$</li>
<li>$$\begin{aligned}<br>\frac{\partial \mathrm{y}}{\partial w} &amp;=\frac{\partial \mathrm{y}}{\partial a} \frac{\partial a}{\partial w}+\frac{\partial \mathrm{y}}{\partial b} \frac{\partial b}{\partial w} \\<br>&amp;=b * 1+\mathrm{a} * 1 \\<br>&amp;=\mathrm{b}+\mathrm{a} \\<br>&amp;=(\mathrm{w}+1)+(\mathrm{x}+\mathrm{w}) \\<br>&amp;=2 * \mathrm{w}+\mathrm{x}+1 \\<br>&amp;=2 * 1+2+1=5\end{aligned}$$</li>
<li><img src="https://img.shiqi-lu.tech/20200919144541.png?imageView2/2/h/200"></li>
<li>y对w求导在计算图中其实就是找到y到w的所有路径上的导数，进行求和</li>
</ul>
<p>Q:叶子结点是什么？</p>
<ul>
<li><img src="https://img.shiqi-lu.tech/20200919144541.png?imageView2/2/h/200"></li>
<li>用户创建的结点称为叶子结点，如X和W</li>
<li>torch.Tensor中有is_leaf指示张量是否为叶子结点</li>
<li>设置叶子结点主要是为了节省内存，因为非叶子结点的梯度在反向传播后会被释放掉</li>
<li>若需要保留非叶子结点的梯度，可使用retain_grad()方法</li>
</ul>
<p>Q:torch.Tensor中的grad_fn作用是什么？</p>
<ul>
<li>记录创建该张量时所用的方法（函数）</li>
<li><img src="https://img.shiqi-lu.tech/20200919144541.png?imageView2/2/h/200"></li>
<li>y.grad_fn = &lt;MulBackward0&gt;</li>
<li>a.grad_fn = &lt;AddBackward0&gt;</li>
</ul>
<p>Q:$y = (x+w)*(w+1)$计算图的代码示例，求解y对w的梯度？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = torch.add(w, x)</span><br><span class="line"><span class="comment"># 若需要保留非叶子结点a的梯度，否则调用a.grad时为None</span></span><br><span class="line"><span class="comment"># a.retain_grad()</span></span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line">y = torch.mul(a, b)</span><br><span class="line"></span><br><span class="line">y.backward()</span><br><span class="line">print(w.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看叶子结点</span></span><br><span class="line">print(<span class="string">&quot;\nis_leaf:\n&quot;</span>, w.is_leaf, x.is_leaf, a.is_leaf, b.is_leaf, y.is_leaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line">print(<span class="string">&quot;\ngradient:\n&quot;</span>, w.grad, x.grad, a.grad, b.grad, y.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 grad_fn</span></span><br><span class="line">print(<span class="string">&quot;\ngrad_fn:\n&quot;</span>, w.grad_fn, x.grad_fn, a.grad_fn, b.grad_fn, y.grad_fn)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([5.])

is_leaf:
 True True False False False

gradient:
 tensor([5.]) tensor([2.]) None None None

grad_fn:
 None None &lt;AddBackward0 object at 0x7fd54938bb00&gt; &lt;AddBackward0 object at 0x7fd5285f4c50&gt; &lt;MulBackward0 object at 0x7fd5285f4be0&gt;</code></pre>
<h1 id="5-autograd与逻辑回归"><a href="#5-autograd与逻辑回归" class="headerlink" title="5.autograd与逻辑回归"></a>5.autograd与逻辑回归</h1><p>Q:torch.autograd.backward是什么？</p>
<ul>
<li>torch.autograd.backward(tensors: Union[torch.Tensor, Sequence[torch.Tensor]], grad_tensors: Union[torch.Tensor, Sequence[torch.Tensor], None] = None, retain_graph: Optional[bool] = None, create_graph: bool = False, grad_variables: Union[torch.Tensor, Sequence[torch.Tensor], None] = None) → None</li>
<li>功能：自动求取梯度</li>
<li>tensors：用于求导的张量，如loss</li>
<li>retain_graph：保存计算图，若不保存，则紧接着再调用一次backward()会报错</li>
<li>create_graph：创建导数计算图，用于高阶求导</li>
<li>grad_tensors：多梯度权重</li>
</ul>
<p>Q:torch.autograd.backward中的retain_graph的代码示例？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = torch.add(w, x)</span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line">y = torch.mul(a, b)</span><br><span class="line"></span><br><span class="line">y.backward(retain_graph=<span class="literal">True</span></span><br><span class="line">          )</span><br><span class="line">print(w.grad)</span><br><span class="line">y.backward()</span><br><span class="line">print(w.grad)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([5.])
tensor([10.])</code></pre>
<p>Q:torch.autograd.backward中的grad_tensors的代码示例？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = torch.add(w, x)     <span class="comment"># retain_grad()</span></span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">y0 = torch.mul(a, b)    <span class="comment"># y0 = (x+w) * (w+1)</span></span><br><span class="line">y1 = torch.add(a, b)    <span class="comment"># y1 = (x+w) + (w+1)    dy1/dw = 2</span></span><br><span class="line"></span><br><span class="line">loss = torch.cat([y0, y1], dim=<span class="number">0</span>)       <span class="comment"># [y0, y1]</span></span><br><span class="line">grad_tensors = torch.tensor([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># gradient 传入 torch.autograd.backward()中的grad_tensors</span></span><br><span class="line">loss.backward(gradient=grad_tensors)</span><br><span class="line"><span class="comment"># 实际上相当于1*y0导数+2*y1导数</span></span><br><span class="line"></span><br><span class="line">print(w.grad)</span><br></pre></td></tr></table></figure>

<pre><code>tensor([9.])</code></pre>
<p>Q:torch.autograd.grad是什么？</p>
<ul>
<li>torch.autograd.grad(outputs: Union[torch.Tensor, Sequence[torch.Tensor]], inputs: Union[torch.Tensor, Sequence[torch.Tensor]], grad_outputs: Union[torch.Tensor, Sequence[torch.Tensor], None] = None, retain_graph: Optional[bool] = None, create_graph: bool = False, only_inputs: bool = True, allow_unused: bool = False) → Tuple[torch.Tensor, …]</li>
<li>功能：求取梯度</li>
<li>outputs：用于求导的张量，如loss</li>
<li>inputs：需要梯度的张量</li>
<li>create_graph：创建导数计算图，用于高阶求导</li>
<li>retain_graph：保存计算图</li>
<li>grad_outputs：多梯度权重</li>
</ul>
<p>Q:如何使用torch.autograd.grad对$y=x^2$进行一阶和二阶求导？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">3.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = torch.pow(x, <span class="number">2</span>)  <span class="comment"># y = x**2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grad_1 = dy/dx = 2x = 2 * 3 = 6</span></span><br><span class="line">grad_1 = torch.autograd.grad(y, x, create_graph=<span class="literal">True</span>)</span><br><span class="line">print(grad_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># grad_2 = d(dy/dx)/dx = d(2x)/dx = 2</span></span><br><span class="line"><span class="comment"># grad_1的返回值是元组，所以要取出第一个</span></span><br><span class="line">grad_2 = torch.autograd.grad(grad_1[<span class="number">0</span>], x)</span><br><span class="line">print(grad_2)</span><br></pre></td></tr></table></figure>

<pre><code>(tensor([6.], grad_fn=&lt;MulBackward0&gt;),)
(tensor([2.]),)</code></pre>
<p>Q:autograd的3点使用小贴士是什么？</p>
<ul>
<li>1.梯度不自动清零，每次传播时会一直叠加上去，所以使用梯度之后要手动进行清零，即w.grad.zero_()，其中下划线表示inplace（原地）操作</li>
<li>2.依赖于叶子结点的节点，requires_grad默认为True</li>
<li>3.叶子结点不可执行in-place</li>
</ul>
<p>Q:逻辑回归的pytorch代码实现是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">torch.manual_seed(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">sample_nums = <span class="number">100</span></span><br><span class="line">mean_value = <span class="number">1.7</span></span><br><span class="line">bias = <span class="number">1</span></span><br><span class="line">n_data = torch.ones(sample_nums, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 类别0 数据 shape=(100, 2)</span></span><br><span class="line">x0 = torch.normal(mean_value * n_data, <span class="number">1</span>) + bias</span><br><span class="line"><span class="comment"># 类别0 标签 shape=(100)</span></span><br><span class="line">y0 = torch.zeros(sample_nums)</span><br><span class="line"><span class="comment"># 类别1 数据 shape=(100, 2)</span></span><br><span class="line">x1 = torch.normal(-mean_value * n_data, <span class="number">1</span>) + bias</span><br><span class="line"><span class="comment"># 类别1 标签 shape=(100)</span></span><br><span class="line">y1 = torch.ones(sample_nums)</span><br><span class="line">train_x = torch.cat((x0, x1), <span class="number">0</span>)</span><br><span class="line">train_y = torch.cat((y0, y1), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LR</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super(LR, self).__init__()</span><br><span class="line">        self.features = nn.Linear(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.features(x)</span><br><span class="line">        x = self.sigmoid(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化逻辑回归模型</span></span><br><span class="line">lr_net = LR()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择损失函数，交叉熵损失</span></span><br><span class="line">loss_fn = nn.BCELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择优化器</span></span><br><span class="line">lr = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line">optimizer = torch.optim.SGD(lr_net.parameters(), lr=lr, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    y_pred = lr_net(train_x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算loss</span></span><br><span class="line">    loss = loss_fn(y_pred.squeeze(), train_y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    <span class="keyword">if</span> iteration % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 以0.5为阈值进行分类</span></span><br><span class="line">        mask = y_pred.ge(<span class="number">0.5</span>).float().squeeze()</span><br><span class="line">        <span class="comment"># 计算正确预测的样本个数</span></span><br><span class="line">        correct = (mask == train_y).sum()</span><br><span class="line">        <span class="comment"># 计算分类准确率</span></span><br><span class="line">        acc = correct.item() / train_y.size(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        plt.scatter(x0.data.numpy()[:, <span class="number">0</span>], x0.data.numpy()[:, <span class="number">1</span>], c=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;class 0&#x27;</span>)</span><br><span class="line">        plt.scatter(x1.data.numpy()[:, <span class="number">0</span>], x1.data.numpy()[:, <span class="number">1</span>], c=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;class 1&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        w0, w1 = lr_net.features.weight[<span class="number">0</span>]</span><br><span class="line">        w0, w1 = float(w0.item()), float(w1.item())</span><br><span class="line">        plot_b = float(lr_net.features.bias[<span class="number">0</span>].item())</span><br><span class="line">        plot_x = np.arange(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">0.1</span>)</span><br><span class="line">        plot_y = (-w0 * plot_x - plot_b) / w1</span><br><span class="line">        </span><br><span class="line">        plt.xlim(<span class="number">-5</span>, <span class="number">7</span>)</span><br><span class="line">        plt.ylim(<span class="number">-7</span>, <span class="number">7</span>)</span><br><span class="line">        plt.plot(plot_x, plot_y)</span><br><span class="line">        </span><br><span class="line">        plt.text(<span class="number">-5</span>, <span class="number">5</span>, <span class="string">&#x27;Loss=%.4f&#x27;</span> % loss.data.numpy(), fontdict=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">20</span>, <span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">        plt.title(<span class="string">&quot;Iteration: &#123;&#125;\nw0:&#123;:.2f&#125; w1:&#123;:.2f&#125; b: &#123;:.2f&#125; accuracy:&#123;:.2%&#125;&quot;</span>.format(iteration, w0, w1, plot_b, acc))</span><br><span class="line">        plt.legend()</span><br><span class="line"></span><br><span class="line">        plt.show()</span><br><span class="line">        plt.pause(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> acc &gt; <span class="number">0.99</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.shiqi-lu.tech/20200920100028.png"></p>
]]></content>
      <categories>
        <category>pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第6-8章学习笔记</title>
    <url>/tcpip-network-programming-2/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-6-章-基于-UDP-的服务端-客户端"><a href="#第-6-章-基于-UDP-的服务端-客户端" class="headerlink" title="第 6 章 基于 UDP 的服务端/客户端"></a>第 6 章 基于 UDP 的服务端/客户端</h1><h2 id="6-1-理解-UDP"><a href="#6-1-理解-UDP" class="headerlink" title="6.1 理解 UDP"></a>6.1 理解 UDP</h2><ul>
<li>Q:UDP原理和使用<ul>
<li>UDP比TCP简单，编程难度较小，性能比TCP高。TCP相对UDP的主要区别是流控制</li>
<li><img src="https://img.shiqi-lu.tech/20210213210402.png"></li>
<li>IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字</li>
<li>UDP 也具有一定的可靠性。在网络实时传递的视频或者音频的场景下，丢失一部分多媒体数据也没有太大问题，这只是会暂时引起画面抖动，或者出现细微的杂音。但是要提供实时服务，速度就成为了一个很重要的因素。此时TCP流控制就显得有一点多余，这时就要考虑使用 UDP </li>
<li>TCP 比 UDP 慢的原因主要有以下两点：<ul>
<li>收发数据前后进行的连接设置及清除过程</li>
<li>收发过程中为保证可靠性而添加的流控制</li>
</ul>
</li>
<li>如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效</li>
</ul>
</li>
</ul>
<h2 id="6-2-实现基于-UDP-的服务端-客户端"><a href="#6-2-实现基于-UDP-的服务端-客户端" class="headerlink" title="6.2 实现基于 UDP 的服务端/客户端"></a>6.2 实现基于 UDP 的服务端/客户端</h2><ul>
<li>Q:基于 UDP 的服务端/客户端的特点<ul>
<li>UDP 的服务端和客户端无需经过连接过程，只有创建套接字和数据交换的过程</li>
<li>UDP 的服务端和客户端均只需1个套接字</li>
</ul>
</li>
<li>Q:基于 UDP 的数据 I/O 函数<ul>
<li>UDP 套接字不会保持连接状态，因此每次传输数据时都需要添加目标的地址信息<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sock, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">void</span> * buff,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">size_t</span> nbytes, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">               struct sockaddr * to,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sock：用于传输数据的UDP套接字文件描述符</span></span><br><span class="line"><span class="comment">// buff：保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">// nbytes：待传输的数据长度，以字节为单位</span></span><br><span class="line"><span class="comment">// flags：可选参数，若没有则传递0</span></span><br><span class="line"><span class="comment">// to：存有目标地址信息的sockaddr结构体变量的地址值</span></span><br><span class="line"><span class="comment">// addrlen：传递给参数to的地址值结构体变量长度</span></span><br><span class="line"><span class="comment">// 成功时返回传输的字节数，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
<li>UDP 数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回 UDP 数据包中的发送端信息<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sock, </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">void</span> * buff,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> nbytes, </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct sockaddr * from,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">socklen_t</span> * addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sock：用于传输数据的UDP套接字文件描述符</span></span><br><span class="line"><span class="comment">// buff：保存接收数据的缓冲地址值</span></span><br><span class="line"><span class="comment">// nbytes：可接收的最大字节数，故无法超过参数buff所指的缓冲大小</span></span><br><span class="line"><span class="comment">// flags：可选项参数，若没有则传递0</span></span><br><span class="line"><span class="comment">// from：存有发送端地址信息的sockaddr结构体变量的地址值</span></span><br><span class="line"><span class="comment">// addrlen：保存参数from的结构体变量长度的变量地址值</span></span><br><span class="line"><span class="comment">// 成功时返回接收的字节数，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:基于 UDP 的服务端/客户端的程序实现<ul>
<li>服务端uecho_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UDP 套接字后，向 socket 的第二个参数传递 SOCK_DGRAM</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;UDP socket creation error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配地址接受数据，不限制数据传输对象</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, </span><br><span class="line">             (struct sockaddr *)&amp;serv_adr, </span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        str_len = recvfrom(serv_sock, message, </span><br><span class="line">                           BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                           (struct sockaddr *)&amp;clnt_adr, </span><br><span class="line">                           &amp;clnt_adr_sz);</span><br><span class="line">        <span class="comment">// 通过上面的函数调用同时获取数据传输端的地址。</span></span><br><span class="line">        <span class="comment">// 正是利用该地址进行逆向重传</span></span><br><span class="line">        sendto(serv_sock, message, str_len, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;clnt_adr, clnt_adr_sz);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面未加入break语句，因此无限循环，下面不会执行</span></span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端uecho_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">from_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Insert message(q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, <span class="keyword">sizeof</span>(message), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendto(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(from_adr);</span><br><span class="line">        str_len = recvfrom(sock, message, BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                           (struct sockaddr *)&amp;from_adr, &amp;adr_sz);</span><br><span class="line">        message[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc uecho_server.c -o userver</span><br><span class="line">shiqi@inspiron:~/network$ ./userver 9190</span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc uecho_client.c -o uclient</span><br><span class="line">shiqi@inspiron:~/network$ ./uclient 127.0.0.1 9190</span><br><span class="line">Insert message(q to quit): xp</span><br><span class="line">Message from server: xp</span><br><span class="line">Insert message(q to quit): q</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Q:UDP 客户端套接字的地址分配<ul>
<li>在首次调用sendto函数时，发现尚未分配地址信息，则给相应套接字自动分配 IP 和端口，此时分配的地址一直保留到程序结束为止</li>
</ul>
</li>
</ul>
<h2 id="6-3-UDP-的数据传输特性和调用-connect-函数"><a href="#6-3-UDP-的数据传输特性和调用-connect-函数" class="headerlink" title="6.3 UDP 的数据传输特性和调用 connect 函数"></a>6.3 UDP 的数据传输特性和调用 connect 函数</h2><ul>
<li>Q:存在数据边界的UDP套接字程序示例<ul>
<li>bound_host1.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_adr</span>, <span class="title">your_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;my_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_adr));</span><br><span class="line">    my_adr.sin_family = AF_INET;</span><br><span class="line">    my_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    my_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;my_adr, <span class="keyword">sizeof</span>(my_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(your_adr);</span><br><span class="line">        str_len = recvfrom(sock, message, BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                           (struct sockaddr *)&amp;your_adr, &amp;adr_sz);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message %d: %s \n&quot;</span>, i + <span class="number">1</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>bound_host2.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> msg1[] = <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> msg2[] = <span class="string">&quot;I&#x27;m another UDP host!&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> msg3[] = <span class="string">&quot;Nice to meet you&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">your_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> your_adr_sz;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;your_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(your_adr));</span><br><span class="line">    your_adr.sin_family = AF_INET;</span><br><span class="line">    your_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    your_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    sendto(sock, msg1, <span class="keyword">sizeof</span>(msg1), <span class="number">0</span>,</span><br><span class="line">           (struct sockaddr *)&amp;your_adr, <span class="keyword">sizeof</span>(your_adr));</span><br><span class="line">    sendto(sock, msg2, <span class="keyword">sizeof</span>(msg2), <span class="number">0</span>,</span><br><span class="line">           (struct sockaddr *)&amp;your_adr, <span class="keyword">sizeof</span>(your_adr));</span><br><span class="line">    sendto(sock, msg2, <span class="keyword">sizeof</span>(msg2), <span class="number">0</span>,</span><br><span class="line">           (struct sockaddr *)&amp;your_adr, <span class="keyword">sizeof</span>(your_adr));</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>bound_host1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc bound_host1.c -o host1</span><br><span class="line">shiqi@inspiron:~/network$ ./host1 9190</span><br><span class="line">Message 1: Hi!</span><br><span class="line">Message 2: I&#x27;m another UDP host!</span><br><span class="line">Message 3: I&#x27;m another UDP host!</span><br></pre></td></tr></table></figure></li>
<li>bound_host2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc bound_host2.c -o host2</span><br><span class="line">shiqi@inspiron:~/network$ ./host2 127.0.0.1 9190</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Q:sendto 函数传输数据的过程的 3 个阶段<ul>
<li>向 UDP 套接字注册目标 IP 和端口号</li>
<li>传输数据</li>
<li>删除 UDP 套接字中注册的目标地址信息</li>
</ul>
</li>
<li>Q:未连接UDP套接字和已连接UDP套接字<ul>
<li>未连接UDP套接字：未注册目标地址信息的套接字，每次都变更目标地址，可重复利用同一 UDP 套接字向不同目标传递数据</li>
<li>已连接UDP套接字：注册了目标地址的套接字，要与同一主机长时间通信时，将UDP套接字变成已连接套接字会提高效率</li>
</ul>
</li>
<li>Q:针对UDP套接字调用connect函数创建已连接UDP套接字<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(adr));</span><br><span class="line">adr.sin_family = AF_INET;</span><br><span class="line">adr.sin_addr.s_addr = ...</span><br><span class="line">adr.sin_port = ...</span><br><span class="line">connect(sock, (struct sockaddr *)&amp;adr, <span class="keyword">sizeof</span>(adr));</span><br></pre></td></tr></table></figure>
<ul>
<li>因已经指定了收发对象，所以不仅可以使用 sendto、recvfrom 函数，还可以使用 write、read 函数进行通信</li>
</ul>
</li>
<li>Q:已连接UDP套接字程序示例<ul>
<li>服务端同uecho_server.c</li>
<li>客户端uecho_con_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Insert message(q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, <span class="keyword">sizeof</span>(message), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = read(sock, message, <span class="keyword">sizeof</span>(message) - <span class="number">1</span>);</span><br><span class="line">        message[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行同echo的udp服务器</li>
</ul>
</li>
</ul>
<h1 id="第-7-章-优雅的断开套接字的连接"><a href="#第-7-章-优雅的断开套接字的连接" class="headerlink" title="第 7 章 优雅的断开套接字的连接"></a>第 7 章 优雅的断开套接字的连接</h1><h2 id="7-1-基于-TCP-的半关闭"><a href="#7-1-基于-TCP-的半关闭" class="headerlink" title="7.1 基于 TCP 的半关闭"></a>7.1 基于 TCP 的半关闭</h2><ul>
<li>Q:单方面断开连接带来的问题<ul>
<li>Linux 的 close 函数意味着完全断开连接。即不仅无法传输数据，而且也不能接收数据。因此在某些情况下，通信一方单方面的断开套接字连接，显得不太优雅</li>
<li>断开一部分连接，即可以传输数据但是无法接收，或可以接受数据但无法传输。即关闭流的一半</li>
</ul>
</li>
<li>Q:针对优雅断开的 shutdown 函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">// sock：需要断开的套接字文件描述符</span></span><br><span class="line"><span class="comment">// howto：传递断开方式信息</span></span><br><span class="line"><span class="comment">// 成功时返回 0 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第二个参数决定断开连接的方式<ul>
<li>SHUT_RD：断开输入流</li>
<li>SHUT_WR：断开输出流</li>
<li>SHUT_RDWR：同时断开I/O流</li>
</ul>
</li>
</ul>
</li>
<li>Q:基于半关闭的文件传输程序<ul>
<li>服务端file_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sd, clnt_sd;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> read_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(<span class="string">&quot;file_server.c&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    serv_sd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    bind(serv_sd, </span><br><span class="line">         (struct sockaddr *)&amp;serv_adr, </span><br><span class="line">         <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    listen(serv_sd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sd = accept(serv_sd, </span><br><span class="line">                     (struct sockaddr *)&amp;clnt_adr, </span><br><span class="line">                     &amp;clnt_adr_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read_cnt = fread((<span class="keyword">void</span> *)buf, <span class="number">1</span>, BUF_SIZE, fp);</span><br><span class="line">        <span class="keyword">if</span> (read_cnt &lt; BUF_SIZE) &#123;</span><br><span class="line">            write(clnt_sd, buf, read_cnt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(clnt_sd, buf, BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    shutdown(clnt_sd, SHUT_WR);</span><br><span class="line">    read(clnt_sd, buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from client: %s \n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(clnt_sd);</span><br><span class="line">    close(serv_sd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端file_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> read_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;receive.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    sd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    connect(sd, </span><br><span class="line">            (struct sockaddr *)&amp;serv_adr, </span><br><span class="line">            <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((read_cnt = read(sd, buf, BUF_SIZE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fwrite((<span class="keyword">void</span> *)buf, <span class="number">1</span>, read_cnt, fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Received file data&quot;</span>);</span><br><span class="line">    write(sd, <span class="string">&quot;Thank you&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc file_server.c -o fserver</span><br><span class="line">shiqi@inspiron:~/network$ ./fserver 9190</span><br><span class="line">Message from client: Thank you</span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc file_client.c -o fclient</span><br><span class="line">shiqi@inspiron:~/network$ ./fclient 127.0.0.1 9190</span><br><span class="line">Received file data</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第-8-章-域名及网络地址"><a href="#第-8-章-域名及网络地址" class="headerlink" title="第 8 章 域名及网络地址"></a>第 8 章 域名及网络地址</h1><h2 id="8-1-域名系统"><a href="#8-1-域名系统" class="headerlink" title="8.1 域名系统"></a>8.1 域名系统</h2><h2 id="8-2-IP地址和域名之间的转换"><a href="#8-2-IP地址和域名之间的转换" class="headerlink" title="8.2 IP地址和域名之间的转换"></a>8.2 IP地址和域名之间的转换</h2><ul>
<li>Q:利用域名获取IP地址的函数gethostbyname<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent * <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * hostname)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回 hostent 结构体地址，失败时返回 NULL 指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只要传递字符串，就可以返回域名对应的IP地址。返回时地址信息装入 hostent 结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * h_name;       <span class="comment">// official name</span></span><br><span class="line">    <span class="keyword">char</span> ** h_aliases;   <span class="comment">// alias list</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;      <span class="comment">// host address type</span></span><br><span class="line">    <span class="keyword">int</span> h_length;        <span class="comment">// address length</span></span><br><span class="line">    <span class="keyword">char</span> ** h_addr_list; <span class="comment">// address list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>h_name：该变量中存有官方域名（Official domain name）。即代表某一主页，但实际上，一些著名公司的域名并没有用官方域名注册</li>
<li>h_aliases：可通过多个域名访问同一主页。同一IP可以绑定多个域名，因此，除官方域名外还可以指定其他域名。这些信息可以通过 h_aliases 获得</li>
<li>h_addrtype：gethostbyname 函数不仅支持 IPV4 还支持 IPV6 。因此可以通过此变量获取保存在 h_addr_list 的IP地址族信息。若是 IPV4 ，则此变量中存有 AF_INET</li>
<li>h_length：保存IP地址长度。若是 IPV4 地址，因为是 4 个字节，则保存4；IPV6 时，因为是 16 个字节，故保存 16</li>
<li>h_addr_list：通过此变量以整数形式保存域名对应的IP地址。另外，用户较多的网站有可能分配多个IP给同一域名，利用多个服务器进行负载均衡。此时同样可通过此变量获取IP地址信息，注意，字符串指针数组中的元素实际指向的是 in_addr 结构体变量地址值而非字符串，所以需要进行类型转换，并调用 inet_ntoa 函数</li>
<li>调用 gethostbyname 函数后，返回的结构体变量如图所示</li>
<li><img src="https://img.shiqi-lu.tech/20210217153812.png"></li>
</ul>
</li>
<li>Q:gethostbyname函数示例gethostbyname.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;addr&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!host) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;gethost... error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出官方域名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出除官方域名以外的域名</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s \n&quot;</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看是不是ipv4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">           (host-&gt;h_addrtype == AF_INET)? <span class="string">&quot;AF_INET&quot;</span>: <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出ip地址信息</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>, i+<span class="number">1</span>,</span><br><span class="line">               inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc gethostbyname.c -o hostname</span><br><span class="line">shiqi@inspiron:~/network$ ./hostname www.naver.com</span><br><span class="line">Official name: www.naver.com.gccdn.net</span><br><span class="line">Aliases 1: www.naver.com</span><br><span class="line">Aliases 2: www.naver.com.nheos.com</span><br><span class="line">Address type: AF_INET</span><br><span class="line">IP addr 1: 43.243.234.60</span><br><span class="line">shiqi@inspiron:~/network$ ./hostname www.baidu.com</span><br><span class="line">Official name: www.a.shifen.com</span><br><span class="line">Aliases 1: www.baidu.com</span><br><span class="line">Address type: AF_INET</span><br><span class="line">IP addr 1: 220.181.38.149</span><br><span class="line">IP addr 2: 220.181.38.150</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:利用IP地址获取域名gethostbyaddr函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent * <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * addr, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">socklen_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> family)</span></span>;</span><br><span class="line"><span class="comment">// addr: 含有IP地址信息的 in_addr 结构体指针。</span></span><br><span class="line"><span class="comment">//       为了同时传递IPv4地址之外的其它信息，</span></span><br><span class="line"><span class="comment">//       该变量的类型声明为char指针</span></span><br><span class="line"><span class="comment">// len: 向第一个参数传递的地址信息的字节数，IPV4 时为 4，IPV6 时为 16</span></span><br><span class="line"><span class="comment">// family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6</span></span><br><span class="line"><span class="comment">// 成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针</span></span><br></pre></td></tr></table></figure></li>
<li>Q:gethostbyaddr函数示例gethostbyaddr.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    host = gethostbyaddr((<span class="keyword">char</span> *)&amp;addr.sin_addr, <span class="number">4</span>, AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (!host) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;gethost... error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出官方域名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出除官方域名以外的域名</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s \n&quot;</span>, i+<span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看是不是ipv4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">           (host-&gt;h_addrtype == AF_INET)? <span class="string">&quot;AF_INET&quot;</span>: <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出ip地址信息</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>, i+<span class="number">1</span>,</span><br><span class="line">               inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc gethostbyaddr.c -o hostaddr</span><br><span class="line">shiqi@inspiron:~/network$ ./hostaddr 8.8.8.8</span><br><span class="line">Official name: dns.google</span><br><span class="line">Address type: AF_INET</span><br><span class="line">IP addr 1: 8.8.8.8</span><br><span class="line">shiqi@inspiron:~/network$ ./hostaddr 114.114.114.114</span><br><span class="line">Official name: public1.114dns.com</span><br><span class="line">Address type: AF_INET</span><br><span class="line">IP addr 1: 114.114.114.114</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第12-14章学习笔记</title>
    <url>/tcpip-network-programming-4/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-12-章-I-O-复用"><a href="#第-12-章-I-O-复用" class="headerlink" title="第 12 章 I/O 复用"></a>第 12 章 I/O 复用</h1><h2 id="12-2-理解-select-函数并实现服务端"><a href="#12-2-理解-select-函数并实现服务端" class="headerlink" title="12.2 理解 select 函数并实现服务端"></a>12.2 理解 select 函数并实现服务端</h2><ul>
<li>Q:select函数将多个文件描述符集中到一起统一监视的3个项目是<ul>
<li>是否存在套接字接收数据？</li>
<li>无需阻塞传输数据的套接字有哪些</li>
<li>哪些套接字发生了异常</li>
</ul>
</li>
<li>Q:select函数的调用方法和顺序<ul>
<li>1.设置文件描述符、指定监视范围、设置超时</li>
<li>2.调用select函数</li>
<li>3.查看调用结果</li>
</ul>
</li>
<li>Q:操作select中的fd_set数组有哪四个宏？<ul>
<li><code>FD_ZERO(fd_set *fdset)</code>：将 fd_set 变量的所有位初始化为0</li>
<li><code>FD_SET(int fd, fd_set * fdset)</code>：在参数 fdset 指向的变量中注册文件描述符 fd 的信息</li>
<li><code>FD_CLR(int fd, fd_set * fdset)</code>：从参数 fdset 指向的变量中清除文件描述符 fd 的信息</li>
<li><code>FD_ISSET(int fd, fd_set * fdset)</code>：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」</li>
<li><img src="https://img.shiqi-lu.tech/20210627202414.png"></li>
</ul>
</li>
<li>c12p199:select函数原型是怎样？<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set * readset,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set * writeset,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set * exceptset,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct timeval * timeout)</span></span>;</span><br><span class="line"><span class="comment">// maxfd：监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">// readset：将所有关注「是否存在待读取数据」的文件描述符</span></span><br><span class="line"><span class="comment">//          注册到 fd_set 型变量，并传递其地址值</span></span><br><span class="line"><span class="comment">// writeset：将所有关注「是否可传输无阻塞数据」的文件描述符</span></span><br><span class="line"><span class="comment">//          注册到 fd_set 型变量，并传递其地址值</span></span><br><span class="line"><span class="comment">// exceptset：将所有关注「是否发生异常」的文件描述符</span></span><br><span class="line"><span class="comment">//          注册到 fd_set 型变量，并传递其地址值</span></span><br><span class="line"><span class="comment">// timeout：调用 select 函数后，为防止陷入无限阻塞的状态，</span></span><br><span class="line"><span class="comment">//         传递超时（time-out）信息</span></span><br><span class="line"><span class="comment">// 返回值：1.发生错误时返回 -1，</span></span><br><span class="line"><span class="comment">//        2.超时返回时返回 0</span></span><br><span class="line"><span class="comment">//        3.因发生关注的事件返回时，返回大于 0 的值，</span></span><br><span class="line"><span class="comment">//          该值是发生事件的文件描述符数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>select 函数用来验证 3 种监视项的变化情况。根据监视声明 3 个 fd_set 型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数</li>
<li>文件描述符的监视范围：<ul>
<li>select 函数要求通过第一个参数传递监视对象文件描述符的数量。因每次新建文件描述符时，其值都会增1，故只需将最大的文件描述符值加 1 再传递即可，加 1 是因为文件描述符的值从 0 开始</li>
</ul>
</li>
<li>select 函数的超时时间：<ul>
<li>timeout传递NULL，select 函数只有在监视的文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。</li>
<li>只要过了设置的超时时间，也可返回，此时返回值为 0<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; <span class="comment">// seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; <span class="comment">// microseconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>select 函数返回正整数时，向其传递的 fd_set 变量将发生变化，可通过值为 1 的位置上的文件描述符获知哪些 fd 发生了变化</li>
<li><img src="https://img.shiqi-lu.tech/20210628200050.png"></li>
</ul>
</li>
<li>c12p201:select调用示例select.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set reads, temps;</span><br><span class="line">    <span class="keyword">int</span> result, str_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    <span class="comment">// 将文件描述符0对应的位设置为1</span></span><br><span class="line">    <span class="comment">// 即监视标准输入的变化</span></span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;reads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将准备好的fd_set变量reads的内容复制到temps变量，</span></span><br><span class="line">        <span class="comment">// 因为调用select函数后，除发生变化的文件描述符对应位外，</span></span><br><span class="line">        <span class="comment">// 剩下的位将初始化为0。为了记住初始化值，必须复制</span></span><br><span class="line">        temps = reads;</span><br><span class="line">        <span class="comment">// 设置select函数的超时，因调用select后，timeval的成员的值</span></span><br><span class="line">        <span class="comment">// 将被替换为超时前剩余时间。所以在调用select前均需初始化</span></span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果控制台输入数据会返回大于0的整数</span></span><br><span class="line">        <span class="comment">// 如果没有输入数据而引发超时，返回0</span></span><br><span class="line">        result = select(<span class="number">1</span>, &amp;temps, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;select() error!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Time-out!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(<span class="number">0</span>, &amp;temps)) &#123;</span><br><span class="line">                <span class="comment">// 验证发生变化的文件描述符是否为标准输入</span></span><br><span class="line">                <span class="comment">// 若是，从标准输入读取数据并向控制台输出</span></span><br><span class="line">                str_len = read(<span class="number">0</span>, buf, BUF_SIZE);</span><br><span class="line">                buf[str_len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;message from concole: %s&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch12$ gcc select.c -o select</span><br><span class="line">shiqi@pc:~/network/ch12$ ./select</span><br><span class="line">Hi~~</span><br><span class="line">message from concole: Hi~~</span><br><span class="line">hahaahhaha</span><br><span class="line">message from concole: hahaahhaha</span><br><span class="line">Time-out!</span><br><span class="line">Time-out!</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></li>
<li>Q:select函数实现I/O服用服务器端<ul>
<li>服务端echo_selectserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    fd_set reads, cpy_reads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, </span><br><span class="line">             (struct sockaddr *)&amp;serv_adr, </span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    <span class="comment">// 注册服务端套接字</span></span><br><span class="line">    FD_SET(serv_sock, &amp;reads);</span><br><span class="line">    fd_max = serv_sock;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cpy_reads = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd_num = select(fd_max+<span class="number">1</span>, &amp;cpy_reads, </span><br><span class="line">                             <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_max + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!FD_ISSET(i, &amp;cpy_reads)) &#123;</span><br><span class="line">                <span class="comment">// 查找发生状态变化的(有接收数据套接字的)</span></span><br><span class="line">                <span class="comment">// 文件描述符</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == serv_sock) &#123;</span><br><span class="line">                <span class="comment">// 服务端套接字有变化，受理连接请求</span></span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = accept(serv_sock,</span><br><span class="line">                                   (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                                   &amp;adr_sz);</span><br><span class="line">                <span class="comment">// 注册与客户端连接的套接字文件描述符</span></span><br><span class="line">                FD_SET(clnt_sock, &amp;reads);</span><br><span class="line">                <span class="keyword">if</span> (fd_max &lt; clnt_sock) &#123;</span><br><span class="line">                    fd_max = clnt_sock;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str_len = read(i, buf, BUF_SIZE);</span><br><span class="line">                <span class="comment">// 确认接收的数据是字符串还是断开连接的EOF</span></span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">                    FD_CLR(i, &amp;reads);</span><br><span class="line">                    close(i);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(i, buf, str_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端同ehco_client.c</li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch12$ gcc echo_selectserv.c -o selserv</span><br><span class="line">shiqi@pc:~/network/ch12$ ./selserv 9190</span><br><span class="line">connected client: 4</span><br><span class="line">connected client: 5</span><br><span class="line">closed client: 5</span><br><span class="line">closed client: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch04$ ./eclient2 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): ur</span><br><span class="line">Message from server: ur</span><br><span class="line">Input message(Q to quit): d</span><br><span class="line">Message from server: d</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch04$ ./eclient2 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): x</span><br><span class="line">Message from server: x</span><br><span class="line">Input message(Q to quit): p</span><br><span class="line">Message from server: p</span><br><span class="line">Input message(Q to quit): m</span><br><span class="line">Message from server: m</span><br><span class="line">Input message(Q to quit): a</span><br><span class="line">Message from server: a</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第-13-章-多种I-O函数"><a href="#第-13-章-多种I-O函数" class="headerlink" title="第 13 章  多种I/O函数"></a>第 13 章  多种I/O函数</h1><h2 id="13-1-send＆recv函数"><a href="#13-1-send＆recv函数" class="headerlink" title="13.1  send＆recv函数"></a>13.1  send＆recv函数</h2><ul>
<li>c13p211：linux send函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> * buf,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：表示与数据传输对象的连接的套接字文件描述符</span></span><br><span class="line"><span class="comment">// buf：保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">// nbytes：待传输的字节数</span></span><br><span class="line"><span class="comment">// flags：传输数据时指定的可选项信息</span></span><br><span class="line"><span class="comment">// 成功时返回发送的字节数，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
<li>c13p212：linux write函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> * buf,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：表示数据接收对象的连接的套接字文件描述符</span></span><br><span class="line"><span class="comment">// buf：保存接收数据的缓冲地址值</span></span><br><span class="line"><span class="comment">// nbytes：可接收的最大字节数</span></span><br><span class="line"><span class="comment">// flags：接收数据时指定的可选项信息</span></span><br><span class="line"><span class="comment">// 成功时返回接收的字节数(收到EOF时返回0)，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
<li>c13p212：send和recv函数最后一个 flag 参数的可选项有哪些？<ul>
<li>该可选项可利用位或(bit OR)运算(|运算符)传递多个信息</li>
<li><img src="https://img.shiqi-lu.tech/20210628211019.png"></li>
</ul>
</li>
<li>c13p212：使用 MSG_OOB 发送紧急消息的程序示例 oob_send.c 和 oob_recv.c<ul>
<li>oob_send.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">    recv_adr.sin_family = AF_INET;</span><br><span class="line">    recv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    recv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock,</span><br><span class="line">                (struct sockaddr *)&amp;recv_adr,</span><br><span class="line">                <span class="keyword">sizeof</span>(recv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处使用 send 紧急传输数据</span></span><br><span class="line">    write(sock, <span class="string">&quot;123&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    send(sock, <span class="string">&quot;4&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;4&quot;</span>), MSG_OOB);</span><br><span class="line">    write(sock, <span class="string">&quot;567&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;567&quot;</span>));</span><br><span class="line">    send(sock, <span class="string">&quot;890&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;890&quot;</span>), MSG_OOB);</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>oob_recv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> acpt_sock;</span><br><span class="line"><span class="keyword">int</span> recv_sock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urg_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    str_len = recv(recv_sock, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, MSG_OOB);</span><br><span class="line">    buf[str_len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Urgent message: %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_adr</span>, <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">socklen_t</span> serv_adr_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = urg_handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    acpt_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;recv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_adr));</span><br><span class="line">    recv_adr.sin_family = AF_INET;</span><br><span class="line">    recv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    recv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(acpt_sock,</span><br><span class="line">             (struct sockaddr *)&amp;recv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(recv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(acpt_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    serv_adr_sz = <span class="keyword">sizeof</span>(serv_adr);</span><br><span class="line">    recv_sock = accept(acpt_sock,</span><br><span class="line">                       (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">                       &amp;serv_adr_sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定当前进程为处理 SIGURG 信号的主体</span></span><br><span class="line">    fcntl(recv_sock, F_SETOWN, getpid());</span><br><span class="line">    state = sigaction(SIGURG, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((str_len = recv(recv_sock, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(recv_sock);</span><br><span class="line">    close(acpt_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch13$ gcc oob_recv.c -o recv</span><br><span class="line">shiqi@pc:~/network/ch13$ ./recv 9190</span><br><span class="line">Urgent message: 0</span><br><span class="line">123456789</span><br><span class="line">shiqi@pc:~/network/ch13$ ./recv 9190</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch13$ gcc oob_send.c -o send</span><br><span class="line">shiqi@pc:~/network/ch13$ ./send 127.0.0.1 9190</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c13p217：紧急模式的工作原理是怎样？<ul>
<li>调用如下函数后的输出缓冲状态如下图：</li>
<li><code>send(sock, &quot;890&quot;, strlen(&quot;890&quot;), MSG_OOB)</code></li>
<li><img src="https://img.shiqi-lu.tech/20210808173857.png"></li>
<li>如果将缓冲最左端的位置视作偏移量为 0，字符 0 保存与偏移量为 2 的位置。另外，字符 0 右侧偏移量为 3 的位置存有紧急指针(Urgent Pointer)。紧急指针指向紧急消息的下一个位置。</li>
<li>实际只用 1 个字节表示紧急消息信息，见如下 TCP 数据包结构</li>
<li><img src="https://img.shiqi-lu.tech/20210808174605.png"></li>
<li>指定 MSG_OOB 选项的数据包本身就是紧急数据包，并通过紧急紧急指针表示紧急消息所在位置</li>
<li>除紧急指针的前面 1 个字节外，数据接收方将通过调用常用输入函数读取剩余部分</li>
</ul>
</li>
<li>c13p218：同时设置 MSG_PEEK 和 MSG_DONTWAIT 选项来验证输入缓冲中是否存在接收的数据的程序示例 peek_send.c 和 peek_recv.c<ul>
<li>设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲中的数据也不会删除。因此通常与 MSG_DONTWAIT 合作，用于非阻塞方式验证待读数据存在与否</li>
<li>通过运行结果可以验证，仅发送1次的数据被读取了2次，因为第一次调用recv函数时设置了MSG_PEEK可选项。以上就是MSG_PEEK可选项的功能</li>
<li>peek_send.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">send_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;send_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(send_adr));</span><br><span class="line">    send_adr.sin_family = AF_INET;</span><br><span class="line">    send_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    send_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock,</span><br><span class="line">                (struct sockaddr *)&amp;send_adr,</span><br><span class="line">                <span class="keyword">sizeof</span>(send_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(sock, <span class="string">&quot;123&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>peek_recv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acpt_sock, recv_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">acpt_adr</span>, <span class="title">recv_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">socklen_t</span> recv_adr_sz;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acpt_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;acpt_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(acpt_adr));</span><br><span class="line">    acpt_adr.sin_family = AF_INET;</span><br><span class="line">    acpt_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    acpt_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(acpt_sock,</span><br><span class="line">             (struct sockaddr *)&amp;acpt_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(acpt_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(acpt_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    recv_adr_sz = <span class="keyword">sizeof</span>(recv_adr);</span><br><span class="line">    recv_sock = accept(acpt_sock, (struct sockaddr *)&amp;recv_adr, &amp;recv_adr_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        str_len = recv(recv_sock, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, MSG_PEEK|MSG_DONTWAIT);</span><br><span class="line">        <span class="keyword">if</span> (str_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffering %d byets: %s\n&quot;</span>, str_len, buf);</span><br><span class="line"></span><br><span class="line">    str_len = recv(recv_sock, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    buf[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read again: %s\n&quot;</span>, buf);</span><br><span class="line">    close(acpt_sock);</span><br><span class="line">    close(recv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch13$ gcc peek_recv.c -o recv</span><br><span class="line">shiqi@pc:~/network/ch13$ ./recv 9190</span><br><span class="line">Buffering 3 byets: 123</span><br><span class="line">Read again: 123</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch13$ gcc peek_send.c -o send</span><br><span class="line">shiqi@pc:~/network/ch13$ ./send 127.0.0.1 9190</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="13-2-readv＆writev函数"><a href="#13-2-readv＆writev函数" class="headerlink" title="13.2  readv＆writev函数"></a>13.2  readv＆writev函数</h2><ul>
<li>c13p221:将分散保存在多个缓冲中的数据一并发送的 writev 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> filedes, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct iovec * iov, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="comment">// filedes: 表示数据传输对象的套接字文件描述符。但该函数并不只</span></span><br><span class="line"><span class="comment">//          限于套接字，因此可以像 read 函数一样向其传递文件或</span></span><br><span class="line"><span class="comment">//          标准输出描述符</span></span><br><span class="line"><span class="comment">// iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送</span></span><br><span class="line"><span class="comment">//      数据的位置和大小信息</span></span><br><span class="line"><span class="comment">// iovcnt: 向第二个参数传递的数组长度</span></span><br><span class="line"><span class="comment">// 成功时返回发送的字节数，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * iov_base; <span class="comment">// 缓冲地址</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">// 缓冲大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="https://img.shiqi-lu.tech/20210808180034.png"></li>
<li>如图，writev 第一个参数 1 是文件描述符，向控制台输出数据，ptr 是存有待发送数据信息的 iovec 数组指针。第三个参数是 2，即从 ptr 指向的地址开始，共浏览 2 个 iovec 结构体变量，发送这些指针指向的缓冲数据。</li>
</ul>
</li>
<li>c13p222:writev 函数的使用示例 writev.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">    <span class="keyword">char</span> buf1[] = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[] = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    vec[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = <span class="number">3</span>;</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    str_len = writev(<span class="number">1</span>, vec, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write byets: %d\n&quot;</span>, str_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch13$ gcc writev.c -o wv</span><br><span class="line">shiqi@pc:~/network/ch13$ ./wv</span><br><span class="line">ABC1234</span><br><span class="line">Write byets: 7</span><br></pre></td></tr></table></figure></li>
<li>c13p223:由多个缓冲分别接收的 readv 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inclde <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> filedes,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> struct iovec * iov,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="comment">// filedes: 表示数据传输对象的套接字文件描述符</span></span><br><span class="line"><span class="comment">// iov: iovec 结构体数组的地址值</span></span><br><span class="line"><span class="comment">// iovcnt: 向第二个参数传递的数组长度</span></span><br><span class="line"><span class="comment">// 成功时返回发送的字节数，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>c13p223:readv 函数的使用示例 readv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">    <span class="keyword">char</span> buf1[BUF_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">char</span> buf2[BUF_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = BUF_SIZE;</span><br><span class="line"></span><br><span class="line">    str_len = readv(<span class="number">0</span>, vec, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read bytes: %d\n&quot;</span>, str_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First message: %s\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second message: %s\n&quot;</span>, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@:~/network/ch13$ gcc readv.c -o rv</span><br><span class="line">shiqi@:~/network/ch13$ ./rv</span><br><span class="line">I want to fly~~~~~~~~~~~. gogogo!</span><br><span class="line">Read bytes: 34</span><br><span class="line">First message: I wan</span><br><span class="line">Second message: t to fly~~~~~~~~~~~. gogogo!</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第-14-章-多播与广播"><a href="#第-14-章-多播与广播" class="headerlink" title="第 14 章  多播与广播"></a>第 14 章  多播与广播</h1><h2 id="14-1-多播"><a href="#14-1-多播" class="headerlink" title="14.1  多播"></a>14.1  多播</h2><ul>
<li>c14p230:多播的数据传输特点是什么？<ul>
<li>1.多播服务器端针对特定多播组，只发送 1 次数据</li>
<li>2.即使只发送一次数据，但所有的客户端都会收到数据</li>
<li>3.多播组数可在 IP 范围内任意增加</li>
<li>4.加入特定组即可接收发往该多播组的数据</li>
<li>5.多播是基于 UDP 完成的，当其向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机</li>
</ul>
</li>
<li>c14p232：如何在代码中设置 TTL?<ul>
<li>协议层是 IPPROTO_IP，选项名为 IP_MULTICAST_TTL<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> send_sock;</span><br><span class="line"><span class="keyword">int</span> time_live = <span class="number">64</span>;</span><br><span class="line">...</span><br><span class="line">send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">setsockopt(send_sock, IPPROTO_IP, </span><br><span class="line">           IP_MULTICAST_TTL, (<span class="keyword">void</span> *)&amp;time_live,</span><br><span class="line">           <span class="keyword">sizeof</span>(time_live));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c14p232:加入多播组的代码是怎样？<ul>
<li>协议层是 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> send_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">...</span><br><span class="line">send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">join_adr.imr_multiaddr.s_addr = <span class="string">&quot;多播组地址信息&quot;</span>;</span><br><span class="line">join_adr.imr_imterface.s_addr = <span class="string">&quot;加入多播组的主机地址信息&quot;</span>;</span><br><span class="line">setsockopt(send_sock, IPPROTO_IP, </span><br><span class="line">           IP_ADD_MEMBERSHIP, (<span class="keyword">void</span> *)&amp;join_adr,</span><br><span class="line">           <span class="keyword">sizeof</span>(join_adr));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>其中 ip_mreq 的定义为<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> &#123;</span></span><br><span class="line">    <span class="comment">// 写入加入的组 IP 地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 加入该组的套接字所属主机的 IP 地址，也可用 INADDR_ANy</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c14p233:实现多播 Sender 和 Receiver 的程序示例 news_sender.c 和 news_receiver.c<ul>
<li>Sender：向AAA组广播( Broadcasting )文件中保存的新闻信息，news_sender.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTL 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> send_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mul_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> time_live = TTL;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;GroupIP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;mul_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">    mul_adr.sin_family = AF_INET;</span><br><span class="line">    mul_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    mul_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    setsockopt(send_sock, IPPROTO_IP,</span><br><span class="line">               IP_MULTICAST_TTL, (<span class="keyword">void</span> *)&amp;time_live,</span><br><span class="line">               <span class="keyword">sizeof</span>(time_live));</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, fp);</span><br><span class="line">        sendto(send_sock, buf, <span class="built_in">strlen</span>(buf),</span><br><span class="line">               <span class="number">0</span>, (struct sockaddr *)&amp;mul_adr, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(send_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Receiver：接收传递到AAA组的新闻信息，news_receiver.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> recv_sock;</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;GroupIP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(adr));</span><br><span class="line">    adr.sin_family = AF_INET;</span><br><span class="line">    adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(recv_sock, (struct sockaddr*)&amp;adr, <span class="keyword">sizeof</span>(adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join_adr.imr_multiaddr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    join_adr.imr_interface.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    setsockopt(recv_sock, IPPROTO_IP,</span><br><span class="line">               IP_ADD_MEMBERSHIP, (<span class="keyword">void</span> *)&amp;join_adr,</span><br><span class="line">               <span class="keyword">sizeof</span>(join_adr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        str_len = recvfrom(recv_sock, buf, BUF_SIZE<span class="number">-1</span> , <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch14$ cat news.txt</span><br><span class="line">111111111111</span><br><span class="line">222222222</span><br><span class="line">3333</span><br><span class="line">shiqi@pc:~/network/ch14$ gcc news_receiver.c -o receiver</span><br><span class="line">shiqi@pc:~/network/ch14$ ./receiver 224.1.1.2 9190</span><br><span class="line">111111111111</span><br><span class="line">222222222</span><br><span class="line">3333</span><br><span class="line">3333</span><br><span class="line">shiqi@pc:~/network/ch14$ gcc news_sender.c -o sender</span><br><span class="line">shiqi@pc:~/network/ch14$ ./sender 224.1.1.2 9190</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="14-2-广播"><a href="#14-2-广播" class="headerlink" title="14.2  广播"></a>14.2  广播</h2><ul>
<li>c14p237:如何代码设置进行数据广播？<ul>
<li>调用 setsockopt，将 SO_BROADCAST 设置为 bcast 变量中的 1<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> send_sock;</span><br><span class="line"><span class="keyword">int</span> bcast = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">setsockopt(send_sock, SOL_SOCKET, SO_BROADCAST,</span><br><span class="line">           (<span class="keyword">void</span>*)&amp;bcast, <span class="keyword">sizeof</span>(bcast));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c14p237:实现广播 Sender 和 Receiver 的程序示例 news_sender_brd.c 和 news_receiver_brd.c<ul>
<li>news_receiver_brd.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> recv_sock;</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recv_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(adr));</span><br><span class="line">    adr.sin_family = AF_INET;</span><br><span class="line">    adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(recv_sock, (struct sockaddr*)&amp;adr, <span class="keyword">sizeof</span>(adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        str_len = recvfrom(recv_sock, buf, BUF_SIZE<span class="number">-1</span> , <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>news_sender_brd.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> send_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mul_adr</span>;</span></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> so_brd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;Broadcast IP&gt; &lt;PORT&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;mul_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">    mul_adr.sin_family = AF_INET;</span><br><span class="line">    mul_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    mul_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    setsockopt(send_sock, SOL_SOCKET,</span><br><span class="line">               SO_BROADCAST, (<span class="keyword">void</span> *)&amp;so_brd,</span><br><span class="line">               <span class="keyword">sizeof</span>(so_brd));</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, fp);</span><br><span class="line">        sendto(send_sock, buf, <span class="built_in">strlen</span>(buf),</span><br><span class="line">               <span class="number">0</span>, (struct sockaddr *)&amp;mul_adr, <span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(send_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch14$ cat news.txt</span><br><span class="line">111111111111</span><br><span class="line">222222222</span><br><span class="line">3333</span><br><span class="line">shiqi@pc:~/network/ch14$ gcc news_receiver_brd.c -o receiver</span><br><span class="line">shiqi@pc:~/network/ch14$ ./receiver 9190</span><br><span class="line">111111111111</span><br><span class="line">222222222</span><br><span class="line">3333</span><br><span class="line">3333</span><br><span class="line">shiqi@pc:~/network/ch14$ gcc news_sender_brd.c -o sender</span><br><span class="line">shiqi@pc:~/network/ch14$ ./sender 9190</span><br><span class="line">Usage : ./sender &lt;Broadcast IP&gt; &lt;PORT&gt;</span><br><span class="line">shiqi@pc:~/network/ch14$ ./sender 255.255.255.255 9190</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第15-17章学习笔记</title>
    <url>/tcpip-network-programming-5/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-15-章-套接字和标准I-O"><a href="#第-15-章-套接字和标准I-O" class="headerlink" title="第 15 章  套接字和标准I/O"></a>第 15 章  套接字和标准I/O</h1><h2 id="15-1-标准I-O函数的优点"><a href="#15-1-标准I-O函数的优点" class="headerlink" title="15.1  标准I/O函数的优点"></a>15.1  标准I/O函数的优点</h2><ul>
<li>c15p247:标准 IO 函数和系统函数文件复制程序的性能对比<ul>
<li>标准 IO 函数stdcpy.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp1;</span><br><span class="line">    FILE * fp2;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    fp1 = fopen(<span class="string">&quot;news.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fp2 = fopen(<span class="string">&quot;cpy1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUF_SIZE, fp1) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, fp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>系统函数syscpy.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    fd1 = open(<span class="string">&quot;news.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    fd2 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((len = read(fd1, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd2, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行</li>
<li>比对的时候发现问题，标准 IO 复制后的文件和原文件不对<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch15$ ll -h</span><br><span class="line">-rw-r--r--  1 shiqi shiqi 330M Aug  8 20:04 news.txt</span><br><span class="line">shiqi@pc:~/network/ch15$ gcc syscpy.c -o syscpy</span><br><span class="line">shiqi@pc:~/Devel/network/ch15$ time ./syscpy</span><br><span class="line">real	3m2.397s</span><br><span class="line">user	0m55.517s</span><br><span class="line">sys	2m6.619s</span><br><span class="line">shiqi@pc:~/network/ch15$ gcc stdcpy.c -o stdcpy</span><br><span class="line">shiqi@pc:~/network/ch15$ time ./stdcpy</span><br><span class="line">real	0m6.822s</span><br><span class="line">user	0m5.014s</span><br><span class="line">sys	0m0.208s</span><br><span class="line">shiqi@pc:~/network/ch15$ ll -h</span><br><span class="line">total 986M</span><br><span class="line">-rw-rw-r--  1 shiqi shiqi 327M Aug  8 20:11 cpy1.txt</span><br><span class="line">-rwxrwxrwx  1 shiqi shiqi 330M Aug  8 20:08 cpy.txt*</span><br><span class="line">-rw-r--r--  1 shiqi shiqi 330M Aug  8 20:04 news.txt</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="15-2-使用标准I-O函数"><a href="#15-2-使用标准I-O函数" class="headerlink" title="15.2  使用标准I/O函数"></a>15.2  使用标准I/O函数</h2><ul>
<li>c15p249:将创建套接字返回的文件描述符转换为标准 IO 函数中使用的 FILE 结构体指针的 fdopen 函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE * <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line"><span class="comment">// fildes: 需要转换的文件描述符</span></span><br><span class="line"><span class="comment">// mode: 将要创建的 FILE 结构体指针的模式(mode)信息</span></span><br><span class="line"><span class="comment">// 成功时返回转换的 FILE 结构体指针，失败时返回 NULL</span></span><br></pre></td></tr></table></figure></li>
<li>c15p250:fdopen 的函数使用示例 desto.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;data.dat&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;file open error&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Network C programming\n&quot;</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch15$ gcc desto.c -o desto</span><br><span class="line">shiqi@pc:~/network/ch15$ ./desto</span><br><span class="line">shiqi@pc:~/network/ch15$ chmod 755 data.dat</span><br><span class="line">shiqi@pc:~/network/ch15$ cat data.dat</span><br><span class="line">Network C programming</span><br></pre></td></tr></table></figure></li>
<li>c15p250:将创建的标准 IO 函数中使用的 FILE 结构体指针转换为套接字返回的文件描述符的 fileno 函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回转换的 FILE 结构体指针，失败时返回 NULL</span></span><br></pre></td></tr></table></figure></li>
<li>c15p251:fileno 的程序示例 todes.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;data.dat&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;file open error&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First file descriptor: %d\n&quot;</span>, fd);</span><br><span class="line">    fp = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;TCP/IP SOCKET PROGRAMMING\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second file descriptor: %d\n&quot;</span>, fileno(fp));</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch15$ gcc todes.c -o todes</span><br><span class="line">shiqi@pc:~/network/ch15$ ./todes</span><br><span class="line">First file descriptor: 3</span><br><span class="line">Second file descriptor: 3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="15-3-基于套接字的标准-I-O函数使用"><a href="#15-3-基于套接字的标准-I-O函数使用" class="headerlink" title="15.3  基于套接字的标准 I/O函数使用"></a>15.3  基于套接字的标准 I/O函数使用</h2><ul>
<li>c15p256:基于标准 IO 函数分离流的目的？<ul>
<li>为了将 FILE 指针按读模式和写模式加以区分</li>
<li>可通过区分读写模式降低实现难度</li>
<li>通过区分 IO 缓冲提高缓冲性能</li>
</ul>
</li>
<li>c15p252:基于标准 IO 函数的回声服务端和客户端程序示例<ul>
<li>服务端 echo_stdserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    FILE * readfp;</span><br><span class="line">    FILE * writefp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readfp = fdopen(clnt_sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        writefp = fdopen(clnt_sock, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!feof(readfp)) &#123;</span><br><span class="line">            fgets(message, BUF_SIZE, readfp);</span><br><span class="line">            <span class="built_in">fputs</span>(message, writefp);</span><br><span class="line">            fflush(writefp);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(readfp);</span><br><span class="line">        fclose(writefp);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端 echo_client<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    FILE * readfp;</span><br><span class="line">    FILE * writefp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connceted........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readfp = fdopen(sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    writefp = fdopen(sock, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fputs</span>(message, writefp);</span><br><span class="line">        fflush(writefp);</span><br><span class="line">        fgets(message, BUF_SIZE, readfp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch15$ gcc echo_stdserv.c -o serv</span><br><span class="line">shiqi@pc:~/network/ch15$ ./serv 9190</span><br><span class="line">Connected client 1</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch15$ gcc echo_client.c -o clnt</span><br><span class="line">shiqi@pc:~/network/ch15$ ./clnt 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): uz</span><br><span class="line">Message from server: uz</span><br><span class="line">Input message(Q to quit): pdu</span><br><span class="line">Message from server: pdu</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第-16-章-关于I-O流分离的其他内容"><a href="#第-16-章-关于I-O流分离的其他内容" class="headerlink" title="第 16 章  关于I/O流分离的其他内容"></a>第 16 章  关于I/O流分离的其他内容</h1><h2 id="16-2-文件描述符的复制和半关闭"><a href="#16-2-文件描述符的复制和半关闭" class="headerlink" title="16.2  文件描述符的复制和半关闭"></a>16.2  文件描述符的复制和半关闭</h2><ul>
<li>c16p261:文件描述符的复制函数原型 dup 和 dup2<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">int</span> fildes2)</span></span>;</span><br><span class="line"><span class="comment">// fildes: 需要复制的文件描述符</span></span><br><span class="line"><span class="comment">// fildes2: 明确指定的文件描述符整数值</span></span><br><span class="line"><span class="comment">// 成功时返回复制的文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>c16p262:dup的程序示例 dup.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cfd1, cfd2;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;Hi~ \n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;It&#x27;s nice day~ \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cfd1 = dup(<span class="number">1</span>);</span><br><span class="line">    cfd2 = dup2(cfd1, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1=%d, fd2=%d\n&quot;</span>, cfd1, cfd2);</span><br><span class="line">    write(cfd1, str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">    write(cfd2, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">    close(cfd1);</span><br><span class="line">    close(cfd2);</span><br><span class="line">    write(<span class="number">1</span>, str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    write(<span class="number">1</span>, str1, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch16$ gcc dup.c -o dup</span><br><span class="line">shiqi@pc:~/network/ch16$ ./dup</span><br><span class="line">fd1=3, fd2=7</span><br><span class="line">Hi~</span><br><span class="line">It&#x27;s nice day~</span><br><span class="line">Hi~</span><br></pre></td></tr></table></figure></li>
<li>c16p263:复制文件描述符后「流」分离的服务端客户端程序示例 sep_serv.c 和 sep_clnt.c，可通过服务器端的半关闭状态接收客户端最后发送的字符串<ul>
<li>没做到流分离的服务端 sep_serv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    FILE * readfp;</span><br><span class="line">    FILE * writefp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    listen(serv_sock, <span class="number">5</span>);</span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line"></span><br><span class="line">    readfp = fdopen(clnt_sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    writefp = fdopen(clnt_sock, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;FROM SERVER: Hi~ client?\n&quot;</span>, writefp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;I love all of the world\n&quot;</span>, writefp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;You are awesome!\n&quot;</span>, writefp);</span><br><span class="line">    fflush(writefp);</span><br><span class="line"></span><br><span class="line">    fclose(writefp);</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), readfp);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    fclose(readfp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>流分离的服务端 sep_serv2.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    FILE * readfp;</span><br><span class="line">    FILE * writefp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    listen(serv_sock, <span class="number">5</span>);</span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line"></span><br><span class="line">    readfp = fdopen(clnt_sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 注意此处的 dup</span></span><br><span class="line">    writefp = fdopen(dup(clnt_sock), <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;FROM SERVER: Hi~ client?\n&quot;</span>, writefp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;I love all of the world\n&quot;</span>, writefp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;You are awesome!\n&quot;</span>, writefp);</span><br><span class="line">    fflush(writefp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端进入半关闭状态，并向客户端发送 EOF</span></span><br><span class="line">    shutdown(fileno(writefp), SHUT_WR);</span><br><span class="line">    fclose(writefp);</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), readfp);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    fclose(readfp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端 sep_clnt.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    FILE * readfp;</span><br><span class="line">    FILE * writefp;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    readfp = fdopen(sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    writefp = fdopen(sock, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), readfp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;FROM CLIENT: Thank you!\n&quot;</span>, writefp);</span><br><span class="line">    fflush(writefp);</span><br><span class="line">    fclose(writefp);</span><br><span class="line">    fclose(readfp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch16$ gcc sep_serv.c -o serv</span><br><span class="line">shiqi@pc:~/network/ch16$ ./serv 9190</span><br><span class="line"></span><br><span class="line">shiqi@pc:~/network/ch16$ gcc sep_clnt.c -o clnt</span><br><span class="line">shiqi@pc:~/network/ch16$ ./clnt 127.0.0.1 9190</span><br><span class="line">FROM SERVER: Hi~ client?</span><br><span class="line">I love all of the world</span><br><span class="line">You are awesome!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch16$ gcc sep_serv2.c -o serv</span><br><span class="line">shiqi@pc:~/network/ch16$ ./serv 9190</span><br><span class="line">FROM CLIENT: Thank you!</span><br><span class="line"></span><br><span class="line">shiqi@pc:~/network/ch16$ ./clnt 127.0.0.1 9190</span><br><span class="line">FROM SERVER: Hi~ client?</span><br><span class="line">I love all of the world</span><br><span class="line">You are awesome!</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="第-17-章-优于-select-的-epoll"><a href="#第-17-章-优于-select-的-epoll" class="headerlink" title="第 17 章 优于 select 的 epoll"></a>第 17 章 优于 select 的 epoll</h1><h2 id="17-1-epoll-理解及应用"><a href="#17-1-epoll-理解及应用" class="headerlink" title="17.1 epoll 理解及应用"></a>17.1 epoll 理解及应用</h2><ul>
<li>c17p265:基于 select 的 I/O 复用技术速度慢的原因<ul>
<li>调用 select 函数后常见的针对所有文件描述符的循环语句</li>
<li>每次调用 select 函数时都需要向该函数传递监视对象信息</li>
</ul>
</li>
<li>c17p266:epoll的优点<ul>
<li>无需编写以监视状态变化为目的的针对所有文件描述符的循环语句</li>
<li>调用对应于select函数的epoll_wait函数时无需每次传递监视对象信息</li>
</ul>
</li>
<li>c17p267:epoll的3个函数<ul>
<li>epoll_create: 创建保存epoll文件描述符的空间</li>
<li>epoll_ctl: 向空间注册并注销文件描述符</li>
<li>epoll_wait: 与select函数类似，等待文件描述符发生变化</li>
<li>epoll 由操作系统负责保存监视对象文件描述符，因此需要向操作系统请求创建保存文件描述符的空间，此时用的函数就是 epoll_create</li>
<li>为了添加和删除监视对象文件描述符，通过 epoll_ctl 函数请求操作系统完成</li>
<li>epoll调用epoll_wait函数等待文件描述符的变化</li>
</ul>
</li>
<li>c17p267:epoll中将发生变化的文件描述符单独集中到一起的epoll_event结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;</span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> * ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>声明epoll_event结构体数组后，传递给epoll_wait 函数时，发生变化的文件描述符信息将被填入数组</li>
</ul>
</li>
<li>c17p268:epoll_create 的函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// size: epoll实例的大小</span></span><br><span class="line"><span class="comment">// 成功时返回 epoll 的文件描述符，失败时返回 -1```</span></span><br><span class="line">    - 调用 epoll_create 函数时创建的文件描述符保存空间称为「epoll 例程」，通过参数 size 传递的值决定 epoll 例程的大小，但该值只是向操作系统提出的建议。换言之，size 并不用来决定 epoll 的大小，而仅供操作系统参考</span><br><span class="line">    - Linux <span class="number">2.6</span><span class="number">.8</span> 之后的内核将完全忽略传入 epoll_create 函数的 size 函数，因此内核会根据情况调整 epoll 例程大小</span><br><span class="line">    - epoll_create 函数创建的资源与套接字相同，也由操作系统管理。因此，该函数和创建套接字的情况相同，也会返回文件描述符，也就是说返回的文件描述符主要用于区分 epoll 例程。需要终止时，与其他文件描述符相同，也要调用 close 函数</span><br><span class="line">- c17p268:epoll_ctl 的函数原型</span><br><span class="line">    - 生成例程后，应在其内部注册监视对象文件描述符，此时使用 epoll_ctl 函数</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// epfd: 用于注册监视对象的epoll例程的文件描述符</span></span><br><span class="line"><span class="comment">// op: 用于指定监视对象的添加、删除或更改等操作</span></span><br><span class="line"><span class="comment">// fd: 需要注册的监视对象文件描述符</span></span><br><span class="line"><span class="comment">// event: 监视对象的事件类型</span></span><br><span class="line"><span class="comment">// 成功时返回 0 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用法举例：<ul>
<li><code>epoll_ctl(A,EPOLL_CTL_ADD,B,C);</code>：epoll 例程 A 中注册文件描述符 B ，主要目的是为了监视参数 C 中的事件</li>
<li><code>epoll_ctl(A,EPOLL_CTL_DEL,B,NULL);</code>：从 epoll 例程 A 中删除文件描述符 B</li>
</ul>
</li>
<li>第二个参数op:<ul>
<li>EPOLL_CTL_ADD：将文件描述符注册到epoll例程</li>
<li>EPOLL_CTL_DEL：从epoll例程中删除文件描述符</li>
<li>EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况</li>
</ul>
</li>
<li>epoll_event结构体在epoll_ctl函数中的应用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">...</span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line">epoll_ctl(opfd, EPOLL_CTL_ADD, sockfd, &amp;event);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>上述代码将sockfd注册到epoll例程epfd中，并在需要读取数据的情况下产生相应事件。</li>
</ul>
</li>
<li>Q:epoll_event成员events中可保存的常量和所指的事件类型<ul>
<li>EPOLLIN: 需要读取数据的情况</li>
<li>EPOLLOUT: 输出缓冲为空，可以立即发送数据的情况</li>
<li>EPOLLPRI: 收到OOB数据的情况</li>
<li>EPOLLRDHUP: 断开连接或半关闭的情况，在边缘触发方式下非常有用</li>
<li>EPOLLERR: 发生错误的情况</li>
<li>EPOLLET: 以边缘触发的方式得到事件通知</li>
<li>EPOLLONESHOT: 发生一次事件后，相应文件描述符不再收到事件通知。因此需向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD，再次设置事件</li>
<li>可通过位或运算同时传递多个上述参数</li>
</ul>
</li>
<li>c17p270:epoll_wait 的函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// epfd: 表示事件发生监视范围的epoll例程的文件描述符</span></span><br><span class="line"><span class="comment">// events: 保存发生事件的文件描述符集合的结构体地址值</span></span><br><span class="line"><span class="comment">// maxevents: 第二个参数中可以保存的最大事件数</span></span><br><span class="line"><span class="comment">// timeout: 以1/1000秒为单位的等待时间，传递-1时，</span></span><br><span class="line"><span class="comment">//          一直等待直到发生事件</span></span><br><span class="line"><span class="comment">// 成功时返回发生事件的文件描述符，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用方式：注意第二个参数所指缓冲需要动态分配<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> event_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">op_events</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// EPOLL_SIZE是宏常量</span></span><br><span class="line">ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line">...</span><br><span class="line">event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>调用函数后，返回发生事件的文件描述符数，同时第二个参数指向的缓冲中保存发生事件的文件描述符集合</li>
</ul>
</li>
<li>Q:epoll回声服务器端条件触发示例echo_epollserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = accept(serv_sock,</span><br><span class="line">                                   (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                                   &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL,</span><br><span class="line">                              ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(ep_events[i].data.fd, buf, str_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc echo_epollserv.c -o echo_epollserv</span><br><span class="line">shiqi@inspiron:~/network$ ./echo_epollserv 9190</span><br><span class="line">connected client: 5</span><br><span class="line">connected client: 6</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ ./eclient2 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): xp</span><br><span class="line">Message from server: xp</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="17-2-条件触发和边缘触发"><a href="#17-2-条件触发和边缘触发" class="headerlink" title="17.2 条件触发和边缘触发"></a>17.2 条件触发和边缘触发</h2><ul>
<li>c17p274:条件触发(Level Trigger)和边缘触发(Edge Trigger)的特性<ul>
<li>条件触发方式中，只要输入缓冲有数据就会一直通知该事件；只要输入缓冲中还剩有数据，就将以事件方式再次注册</li>
<li>边缘触发中输入缓冲收到数据时仅注册 1 次该事件。即使输入缓冲中还留有数据，也不会再进行注册</li>
</ul>
</li>
<li>c17p274:条件触发和边缘触发的程序示例比较 echo_EPLTserv.c<ul>
<li>条件触发每次收到客户端数据时，都会注册该事件，并因此多次调用 epoll_wait 函数，切换为边缘触发后，仅注册一次事件</li>
<li>服务端 echo_EPLTserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少缓冲大小以阻止服务器端一次性读取接收的数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = accept(serv_sock,</span><br><span class="line">                                   (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                                   &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                <span class="comment">//event.events = EPOLLIN | EPOLLET;</span></span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL,</span><br><span class="line">                              ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(ep_events[i].data.fd, buf, str_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译测试<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">47@pc:~/network/ch17$ gcc echo_EPLTserv.c -o serv</span><br><span class="line">47@pc:~/network/ch17$ ./serv 9190</span><br><span class="line">return epoll_wait</span><br><span class="line">connected client: 5</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line"></span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">closed client: 5</span><br><span class="line"></span><br><span class="line">47@pc:~/network/ch04$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): eeeeeeeee</span><br><span class="line">Message from server: eeeeeeeee</span><br><span class="line">Input message(Q to quit): 12345678</span><br><span class="line">Message from server: 12345678Input message(Q to quit): 1234</span><br><span class="line">Message from server:</span><br><span class="line">Input message(Q to quit): 1</span><br><span class="line">Message from server: 1234</span><br><span class="line">Input message(Q to quit): 222</span><br><span class="line">Message from server: 1</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>
<ul>
<li>把代码 70 行取消注释，注释 69 行后<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">47@pc:~/network/ch17$ gcc echo_EPTLserv.c -o serv</span><br><span class="line">47@pc:~/network/ch17$ ./serv 9190</span><br><span class="line">return epoll_wait</span><br><span class="line">connected client: 5</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line"></span><br><span class="line">47@pc:~/network/ch04$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): 12345678</span><br><span class="line">Message from server: 1234Input message(Q to quit): 999999</span><br><span class="line">Message from server: 5678Input message(Q to quit): 9999999999esh</span><br><span class="line">Message from server:</span><br><span class="line">999Input message(Q to quit): 67890</span><br><span class="line">Message from server: 999</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>c17p278:更改或读取文件属性的 fcntl 函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fieldes, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"><span class="comment">// filedes: 属性更改目标的文件描述符</span></span><br><span class="line"><span class="comment">// cmd: 表示函数调用的目的</span></span><br><span class="line"><span class="comment">// 成功时返回 cmd 参数相关值，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>fcntl 具有可变参数的形式，如果向第二个参数传递 F_GETFL，可以获得第一个参数所指的文件描述符属性(int 型)。反之，如果传递 F_SETTL，可以更改文件描述符属性</li>
</ul>
</li>
<li>c17p278:将文件(套接字)改为非阻塞模式的代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flag|O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过第一条语句获取之前设置的属性信息，通过第二条语句在此基础上添加非阻塞 O_ NONBLOCK 标志。调用 read &amp; write 函数时，无论是否存在数据，都会形成非阻塞文件(套接字)</li>
</ul>
</li>
<li>c17p279:实现边缘触发的回声服务器的程序示例 echo_EPETserv.c<ul>
<li>边缘触发接收数据仅注册 1 次事件，所以一旦发生输入相关事件就应该读取输入缓冲中的全部数据。其终止条件是验证输入缓冲是否为空：read 函数返回 -1，变量 errno 中的值为 EAGAIN时，说明没有数据可读</li>
<li>echo_EPETserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblockingmode</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(fd, F_SETFL, flag|O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;return epoll_wait&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = accept(serv_sock,</span><br><span class="line">                                   (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                                   &amp;adr_sz);</span><br><span class="line">                setnonblockingmode(clnt_sock);</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL,</span><br><span class="line">                                  ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(ep_events[i].data.fd);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        write(ep_events[i].data.fd, buf, str_len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">47@pc:~/Devel/network/ch17$ gcc echo_EPETserv.c -o serv</span><br><span class="line">47@pc:~/Devel/network/ch17$ ./serv 9190</span><br><span class="line">return epoll_wait</span><br><span class="line">connected client: 5</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">return epoll_wait</span><br><span class="line">closed client: 5</span><br><span class="line"></span><br><span class="line">47@pc:~/Devel/network/ch04$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): 123456789</span><br><span class="line">Message from server: 123456789</span><br><span class="line">Input message(Q to quit): 987ehem</span><br><span class="line">Message from server: 987ehem</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c17p282:边缘触发相比条件触发的优点是什么？<ul>
<li>可以分离接收数据和处理数据的时间点</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第18、24章学习笔记</title>
    <url>/tcpip-network-programming-6/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-18-章-多线程服务器端的实现"><a href="#第-18-章-多线程服务器端的实现" class="headerlink" title="第 18 章  多线程服务器端的实现"></a>第 18 章  多线程服务器端的实现</h1><h2 id="18-2-线程创建及运行"><a href="#18-2-线程创建及运行" class="headerlink" title="18.2  线程创建及运行"></a>18.2  线程创建及运行</h2><ul>
<li>c18p287:线程创建的 pthread_create 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> * <span class="keyword">restrict</span> thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * <span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *(* start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> * <span class="keyword">restrict</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// thread：保存新创建线程 ID 的变量地址值。</span></span><br><span class="line"><span class="comment">// attr：用于传递线程属性的参数，传递 NULL 时，创建默认属性的线程</span></span><br><span class="line"><span class="comment">// start_routine：相当于线程 main 函数的、</span></span><br><span class="line"><span class="comment">//                在单独执行流中执行的函数指针</span></span><br><span class="line"><span class="comment">// arg：通过第三个参数传递调用函数时包含传递参数信息的变量地址值</span></span><br><span class="line"><span class="comment">// 成功返回 0，失败返回其他值</span></span><br></pre></td></tr></table></figure></li>
<li>c18p187:线程创建的 pthread_create 函数的程序示例 thread1.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 arg 参数是 pthread_create 的第 4 个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_main</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> cnt = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;running thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line">    <span class="keyword">int</span> thread_param = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t_id,</span><br><span class="line">                       <span class="literal">NULL</span>,</span><br><span class="line">                       thread_main,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;thread_param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;thread_create() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了延迟进程的终止时间</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;end of main&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc thread1.c -o tr1 -lpthread</span><br><span class="line">shiqi@pc:~/network/ch18$ ./tr1</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">end of main</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c18p290:让调用线程的进程(或线程)等待的 pthread_join 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> ** status)</span></span>;</span><br><span class="line"><span class="comment">// thread：该参数值 ID 的线程终止后才会从该函数返回</span></span><br><span class="line"><span class="comment">// status：保存线程的 main 函数返回值的指针变量地址值</span></span><br><span class="line"><span class="comment">// 成功返回 0，失败返回其他值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用该函数的进程(或线程)将进入等待状态，直到第一个参数为 ID 的线程终止为止，并且可以得到线程的 main 函数返回值</li>
</ul>
</li>
<li>c18p290:线程创建的 pthread_create + pthread_join 函数的程序示例 thread2.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_main</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> cnt = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">char</span> * msg = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(msg, <span class="string">&quot;hello, I&#x27;m thread ~\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;running thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line">    <span class="keyword">int</span> thread_param = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">void</span> * thr_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t_id,</span><br><span class="line">                       <span class="literal">NULL</span>,</span><br><span class="line">                       thread_main,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;thread_param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;pthread_create() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意此处获取返回值的方法</span></span><br><span class="line">    <span class="comment">// 注意返回值是 thread_main 函数内部动态分配的内存空间地址值</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t_id, &amp;thr_ret) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;pthread_join() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread return message: %s\n&quot;</span>, (<span class="keyword">char</span> *)thr_ret);</span><br><span class="line">    <span class="built_in">free</span>(thr_ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc thread2.c -o tr2 -lpthread</span><br><span class="line">shiqi@pc:~/network/ch18$ ./tr2</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">running thread</span><br><span class="line">Thread return message: hello, I&#x27;m thread ~</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c18p292:如何通过加宏定义把平台定义的非线程安全函数改为线程安全函数？<ul>
<li>头文件<code>#define _REENTRANT</code> 或 <code>gcc -D_REENTRANT</code></li>
</ul>
</li>
<li>c18p293:工作线程模型示例程序 thread3.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_summation</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = ((<span class="keyword">int</span> *)arg)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end = ((<span class="keyword">int</span> *)arg)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        sum += start;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> id_t1, id_t2;</span><br><span class="line">    <span class="keyword">int</span> range1[] = &#123;<span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> range2[] = &#123;<span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;id_t1, <span class="literal">NULL</span>, thread_summation, (<span class="keyword">void</span> *)range1);</span><br><span class="line">    pthread_create(&amp;id_t2, <span class="literal">NULL</span>, thread_summation, (<span class="keyword">void</span> *)range2);</span><br><span class="line"></span><br><span class="line">    pthread_join(id_t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id_t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result: %d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc thread3.c -D_REENTRANT -lpthread -o tr3</span><br><span class="line">shiqi@pc:~/network/ch18$ ./tr3</span><br><span class="line">result: 55</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c18p293:工作线程模型示例程序 thread4.c，验证临界区错误<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREAD 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_inc</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; ++i) &#123;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_des</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; ++i) &#123;</span><br><span class="line">        --num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id[NUM_THREAD];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof long long: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREAD; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            pthread_create(&amp;(thread_id[i]), <span class="literal">NULL</span>, thread_inc, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_create(&amp;(thread_id[i]), <span class="literal">NULL</span>, thread_des, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREAD; ++i) &#123;</span><br><span class="line">        pthread_join(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result: %lld\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述示例中共创建了100个线程，其中一半执行thread_ inc函数中的代码，另一半则执行thread_des函数中的代码。全局变量num经过增减过程后应等于0，通过运行结果观察是否真能得到</li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc thread4.c -D_REENTRANT -lpthread -o tr4</span><br><span class="line">shiqi@pc:~/network/ch18$ ./tr4</span><br><span class="line">sizeof long long: 8</span><br><span class="line">result: 11790109</span><br><span class="line">shiqi@pc:~/network/ch18$ ./tr4</span><br><span class="line">sizeof long long: 8</span><br><span class="line">result: 804248</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="18-4-线程同步"><a href="#18-4-线程同步" class="headerlink" title="18.4  线程同步"></a>18.4  线程同步</h2><ul>
<li>c18p300:互斥量的创建和销毁函数原型 pthread_mutex_init 和 pthread_mutex_destroy<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="comment">// mutex：创建/销毁互斥量时传递互斥量的变量地址值</span></span><br><span class="line"><span class="comment">// attr：传递即将创建的互斥量属性，没有特别需要指定的属性时传递 NULL</span></span><br><span class="line"><span class="comment">// 成功时返回 0，失败时返回其他值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用前先声明：<code>pthread_mutex_t mutex;</code></li>
<li>如果不需要配置特殊的互斥量属性，则向第二个参数传递 NULL 时，可利用 PTHREAD_MUTEX_INITIALIZER 宏声明：</li>
<li><code>pthread_mutex_t mutex mutex = PTHREAD_MUTEX_INITIALIZER;</code></li>
</ul>
</li>
<li>c18p301:互斥量的锁住和释放函数原型 pthread_mutex_lock 和  pthread_mutex_unlock<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回 0，失败时返回其他值</span></span><br></pre></td></tr></table></figure></li>
<li>c18p302:互斥量使用的示例程序 mutex.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREAD 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_inc</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; ++i) &#123;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_des</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; ++i) &#123;</span><br><span class="line">        --num;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id[NUM_THREAD];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREAD; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            pthread_create(&amp;(thread_id[i]), <span class="literal">NULL</span>, thread_inc, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_create(&amp;(thread_id[i]), <span class="literal">NULL</span>, thread_des, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREAD; ++i) &#123;</span><br><span class="line">        pthread_join(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result: %lld\n&quot;</span>, num);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc mutex.c -D_REENTRANT -lpthread -o mutex</span><br><span class="line">shiqi@pc:~/network/ch18$ ./mutex</span><br><span class="line">result: 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>c18p304:信号量的创建和销毁函数原型 sem_init 和 sem_destroy<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> * sem, <span class="keyword">int</span> pshared, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> * sem)</span></span>;</span><br><span class="line"><span class="comment">// sem: 创建信号量时传递保存信号量的变量地址值，</span></span><br><span class="line"><span class="comment">//      销毁时传递需要销毁的信号量的变量地址值</span></span><br><span class="line"><span class="comment">// pshared: 传递其它值时，创建可由多个进程共享的信号量</span></span><br><span class="line"><span class="comment">//          传递 0 时，创建只允许 1 个进程内部使用的信号量</span></span><br><span class="line"><span class="comment">// value: 指定新创建的信号量初始值</span></span><br><span class="line"><span class="comment">// 成功时返回 0，失败时返回其他值</span></span><br></pre></td></tr></table></figure></li>
<li>c18p304:信号量使用的函数原型 sem_post 和 sem_wait<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> * sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> * sem)</span></span>;</span><br><span class="line"><span class="comment">// sem: 传递保存信号量读取值的变量地址值，</span></span><br><span class="line"><span class="comment">//      传递给 sem_post 时信号量增 1，</span></span><br><span class="line"><span class="comment">//      传递给 sem_wait 时信号量减 1</span></span><br><span class="line"><span class="comment">// 成功时返回 0，失败时返回其他值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>信号量的值不能小于 0，因此在信号量为 0 的情况下调用 sem_wait 函数时，调用函数的线程将进入阻塞状态。只有当有其它线程调用 sem_post 函数将信号量变为 1 时，原本阻塞的线程可以将该信号量重新减为 0 并跳出阻塞状态</li>
</ul>
</li>
<li>c18p305:信号量使用示例 semaphore.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> sem_one;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> sem_two;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">read</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input num: &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        sem_wait(&amp;sem_two);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        sem_post(&amp;sem_one);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">accu</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sem_wait(&amp;sem_one);</span><br><span class="line">        sum += num;</span><br><span class="line">        sem_post(&amp;sem_two);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d \n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> id_t1, id_t2;</span><br><span class="line">    sem_init(&amp;sem_one, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_two, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;id_t1, <span class="literal">NULL</span>, read, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id_t2, <span class="literal">NULL</span>, accu, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(id_t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id_t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sem_one);</span><br><span class="line">    sem_destroy(&amp;sem_two);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc semaphore.c -D_REENTRANT -lpthread -o sema</span><br><span class="line">shiqi@pc:~/network/ch18$ ./sema</span><br><span class="line">Input num: 1</span><br><span class="line">Input num: 2</span><br><span class="line">Input num: 3</span><br><span class="line">Input num: 4</span><br><span class="line">Input num: 5</span><br><span class="line">Result: 15</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="18-5-线程的销毁和多线程并发服务器端的实现"><a href="#18-5-线程的销毁和多线程并发服务器端的实现" class="headerlink" title="18.5  线程的销毁和多线程并发服务器端的实现"></a>18.5  线程的销毁和多线程并发服务器端的实现</h2><ul>
<li>c18p307:销毁线程的 3 种方法<ul>
<li>调用 pthread_join<ul>
<li>调用pthread_join函数时，不仅会等待线程终止，还会引导线程销毁。但该函数的问题是，线程终止前，调用该函数的线程将进人阻塞状态</li>
</ul>
</li>
<li>调用 pthread_detach<ul>
<li>pthread_detach 不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间</li>
</ul>
</li>
</ul>
</li>
<li>c18p307:pthread_detach 函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">// thread: 终止时需要销毁的线程 ID</span></span><br><span class="line"><span class="comment">// 成功时返回 0，失败时返回其他值</span></span><br></pre></td></tr></table></figure></li>
<li>c18p307:多线程并发聊天服务器的实现 chat_server.c，chat_clnt.c<ul>
<li>服务端 chat_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLNT 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clnt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> clnt_socks[MAX_CLNT];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">char</span> * msg, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pthread_mutex_lock(&amp;mutx);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clnt_cnt; ++i) &#123;</span><br><span class="line">        write(clnt_socks[i], msg, len);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> msg[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((str_len = read(clnt_sock, msg, <span class="keyword">sizeof</span>(msg))) != <span class="number">0</span>) &#123;</span><br><span class="line">        send_msg(msg, str_len);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mutx);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clnt_cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == clnt_socks[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; clnt_cnt - <span class="number">1</span>) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                clnt_socks[i] = clnt_socks[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --clnt_cnt;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutx);</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutx, <span class="literal">NULL</span>);</span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock,</span><br><span class="line">                           (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                           &amp;clnt_adr_sz);</span><br><span class="line">        pthread_mutex_lock(&amp;mutx);</span><br><span class="line">        clnt_socks[clnt_cnt++] = clnt_sock;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutx);</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;t_id, <span class="literal">NULL</span>, handle_clnt, (<span class="keyword">void</span> *)&amp;clnt_sock);</span><br><span class="line">        pthread_detach(t_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connceted client IP: %s\n&quot;</span>, inet_ntoa(clnt_adr.sin_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端 chat_clnt.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_SIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[NAME_SIZE] = <span class="string">&quot;[DEFAULT]&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> msg[BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">send_msg</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">char</span> name_msg[NAME_SIZE+BUF_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fgets(msg, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(msg, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(name_msg, <span class="string">&quot;%s %s&quot;</span>, name, msg);</span><br><span class="line">        write(sock, name_msg, <span class="built_in">strlen</span>(name_msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">recv_msg</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">char</span> name_msg[NAME_SIZE+BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        str_len = read(sock, name_msg, NAME_SIZE+BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        name_msg[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(name_msg, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> snd_thread, rcv_thread;</span><br><span class="line">    <span class="keyword">void</span> * thread_return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">&quot;[%s]&quot;</span>, argv[<span class="number">3</span>]);</span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock,</span><br><span class="line">                (struct sockaddr *)&amp;serv_addr,</span><br><span class="line">                <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;snd_thread, <span class="literal">NULL</span>, send_msg, (<span class="keyword">void</span> *)&amp;sock);</span><br><span class="line">    pthread_create(&amp;rcv_thread, <span class="literal">NULL</span>, recv_msg, (<span class="keyword">void</span> *)&amp;sock);</span><br><span class="line">    pthread_join(snd_thread, &amp;thread_return);</span><br><span class="line">    pthread_join(rcv_thread, &amp;thread_return);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch18$ gcc chat_server.c -D_REENTRANT -lpthread -o cserv</span><br><span class="line">shiqi@pc:~/network/ch18$ gcc chat_clnt.c -D_REENTRANT -lpthread -o cclnt</span><br><span class="line">shiqi@pc:~/network/ch18$ ./cserv 9190</span><br><span class="line">Connceted client IP: 127.0.0.1</span><br><span class="line">Connceted client IP: 127.0.0.1</span><br><span class="line">Connceted client IP: 127.0.0.1</span><br><span class="line"></span><br><span class="line">shiqi@pc:~/network/ch18$ ./cclnt 127.0.0.1 9190 zhangsan</span><br><span class="line">hi boys</span><br><span class="line">[zhangsan] hi boys</span><br><span class="line">[lisi] hi I&#x27;m lisi</span><br><span class="line">[wangwu] well, who am i?</span><br><span class="line"></span><br><span class="line">shiqi@pc:~/network/ch18$ ./cclnt 127.0.0.1 9190 lisi</span><br><span class="line">[zhangsan] hi boys</span><br><span class="line">hi I&#x27;m lisi</span><br><span class="line">[lisi] hi I&#x27;m lisi</span><br><span class="line">[wangwu] well, who am i?</span><br><span class="line"></span><br><span class="line">shiqi@pc:~/network/ch18$ ./cclnt 127.0.0.1 9190 wangwu</span><br><span class="line">[zhangsan] hi boys</span><br><span class="line">[lisi] hi I&#x27;m lisi</span><br><span class="line">well, who am i?</span><br><span class="line">[wangwu] well, who am i?</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="第-24-章-制作HTTP服务器端"><a href="#第-24-章-制作HTTP服务器端" class="headerlink" title="第 24 章  制作HTTP服务器端"></a>第 24 章  制作HTTP服务器端</h1><h2 id="24-2-实现简单的Web服务器端"><a href="#24-2-实现简单的Web服务器端" class="headerlink" title="24.2  实现简单的Web服务器端"></a>24.2  实现简单的Web服务器端</h2><ul>
<li>c24p298:实现基于 Linux 的多线程 Web 服务器端的程序示例 webserv_linux.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_BUF 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_error</span><span class="params">(FILE * fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> protocol[] = <span class="string">&quot;HTTP/1.0 400 Bad Request\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> server[] = <span class="string">&quot;Server:Linux Web Server \r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> cnt_len[] = <span class="string">&quot;Content-length:2048\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> cnt_type[] = <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> content[] = <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&lt;font size=+5&gt;&lt;br&gt; 发生错误！查看请求文件名和请求方式！&quot;</span></span><br><span class="line">        <span class="string">&quot;&lt;/font&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(protocol, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(server, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(cnt_len, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(cnt_type, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(content, fp);</span><br><span class="line">    fflush(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(FILE * fp, <span class="keyword">char</span> * ct, <span class="keyword">char</span> * file_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> protocol[] = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> server[] = <span class="string">&quot;Server:Linux Web Server \r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> cnt_len[] = <span class="string">&quot;Content-length:2048\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> cnt_type[SMALL_BUF];</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    FILE * send_file;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(cnt_type, <span class="string">&quot;Content-type:%s\r\n\r\n&quot;</span>, ct);</span><br><span class="line">    send_file = fopen(file_name, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (send_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        send_error(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输头信息</span></span><br><span class="line">    <span class="built_in">fputs</span>(protocol, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(server, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(cnt_len, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(cnt_type, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输请求数据</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUF_SIZE, send_file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(buf, fp);</span><br><span class="line">        fflush(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">content_type</span><span class="params">(<span class="keyword">char</span> * file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> extension[SMALL_BUF];</span><br><span class="line">    <span class="keyword">char</span> file_name[SMALL_BUF];</span><br><span class="line">    <span class="built_in">strcpy</span>(file_name, file);</span><br><span class="line">    strtok(file_name, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(extension, strtok(<span class="literal">NULL</span>, <span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(extension, <span class="string">&quot;html&quot;</span>) || !<span class="built_in">strcmp</span>(extension, <span class="string">&quot;htm&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">request_handler</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">char</span> req_line[SMALL_BUF];</span><br><span class="line">    FILE * clnt_read;</span><br><span class="line">    FILE * clnt_write;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> method[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> ct[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">char</span> file_name[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    clnt_read = fdopen(clnt_sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    clnt_write = fdopen(dup(clnt_sock), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fgets(req_line, SMALL_BUF, clnt_read);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(req_line, <span class="string">&quot;HTTP/&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        send_error(clnt_write);</span><br><span class="line">        fclose(clnt_read);</span><br><span class="line">        fclose(clnt_write);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(method, strtok(req_line, <span class="string">&quot; /&quot;</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(file_name, strtok(<span class="literal">NULL</span>, <span class="string">&quot; /&quot;</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(ct, content_type(file_name));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(method, <span class="string">&quot;GET&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        send_error(clnt_write);</span><br><span class="line">        fclose(clnt_read);</span><br><span class="line">        fclose(clnt_write);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(clnt_read);</span><br><span class="line">    send_data(clnt_write, ct, file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clnt_adr_size;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">20</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clnt_adr_size = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock,</span><br><span class="line">                           (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                           &amp;clnt_adr_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection Request: %s:%d\n&quot;</span>,</span><br><span class="line">               inet_ntoa(clnt_adr.sin_addr), ntohs(clnt_adr.sin_port));</span><br><span class="line">        pthread_create(&amp;t_id, <span class="literal">NULL</span>, request_handler, &amp;clnt_sock);</span><br><span class="line">        pthread_detach(t_id);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写完才知道写一个完备的 http 服务器其实不容易</li>
<li>编译运行，同时要在这建一个 index.html 文件，假设里面都是「hhhhhhhhhhhhhhh」<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch24$ gcc webserv_linux.c -D_REENTRANT -lpthread -o webs</span><br><span class="line">shiqi@pc:~/network/ch24$ ./webs 9190</span><br><span class="line">Connection Request: 127.0.0.1:53270</span><br><span class="line">Connection Request: 127.0.0.1:53272</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch24$ curl localhost:9190/index.html</span><br><span class="line">hhhhhhhhhhhhhhhhhhhh</span><br><span class="line">curl: (18) transfer closed with 2027 bytes remaining to read</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《分布式技术原理与算法解析》分布式协调与同步 学习笔记</title>
    <url>/distrib-principal-algo-2/</url>
    <content><![CDATA[<h1 id="03丨分布式互斥：有你没我，有我没你"><a href="#03丨分布式互斥：有你没我，有我没你" class="headerlink" title="03丨分布式互斥：有你没我，有我没你"></a>03丨分布式互斥：有你没我，有我没你</h1><ul>
<li>Q:分布式互斥（Distributed Mutual Exclusion）是什么？临界资源(Critical Resource)是什么？<ul>
<li>在分布式系统里要求同一时刻只能有一个程序能够访问一个共享资源，这种排他式的资源访问方式叫分布式互斥，这种被互斥访问的共享资源叫临界资源</li>
</ul>
</li>
<li>Q:有哪3种分布式互斥方法？<ul>
<li>1.集中式方法</li>
<li>2.分布式方法</li>
<li>3.令牌环方法</li>
</ul>
</li>
<li>Q:中央服务器算法或集中式算法是什么？<ul>
<li>每个程序在需要访问临界资源时，先给协调者发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问；否则，按照先来后到的顺序为请求程序排一个号。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权信息。拿到授权消息的程序，可以直接去访问临界资源</li>
<li><img src="https://img.shiqi-lu.tech/20200905201509.png"></li>
</ul>
</li>
<li>Q:集中式算法中每个程序完成一次临界资源访问需要进行哪3次消息交互？<ul>
<li>1.向协调者发送请求授权</li>
<li>2.协调者向程序发放授权信息</li>
<li>3.程序使用完临界资源后，向协调者发送授权</li>
</ul>
</li>
<li>Q:集中式算法的优缺点和适用场景是什么？<ul>
<li>优点：直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信</li>
<li>缺点：</li>
<li>1.协调者会成为系统的性能瓶颈。即协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加</li>
<li>2.容易引发单点故障。若协调者故障会导致所有的程序均无法访问临界资源，导致整个系统不可用</li>
<li>适用场景：</li>
<li>在可靠性和性能有一定的保障时，如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备备份，主故障后背可以立马升为主，且数据可恢复的情况下可用集中式算法</li>
</ul>
</li>
<li>Q:分布式算法或使用组播和逻辑时钟的算法是什么？<ul>
<li>当一个程序要访问临界资源时，先向系统中的其它程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者ID，以及发起请求的时间</li>
<li>即根据“先到先得”和“投票全票通过”机制，让每个程序按时间顺序公平地访问资源</li>
<li>适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合P2P结构的系统</li>
<li><img src="https://img.shiqi-lu.tech/20200905201602.png"></li>
</ul>
</li>
<li>Q:分布式算法中，一个程序完成一次临界资源访问需要的消息交互：<ul>
<li>1.向其它n-1个程序发送临界资源的请求</li>
<li>2.需要接收到其它n-1个程序回复的同意消息</li>
<li>总共2*(n-1)，在大型系统中使用分布式算法，消息数量会随着需要访问临界资源数量呈指数级增加</li>
</ul>
</li>
<li>Q:分布式算法的可用性很低的两个原因是什么？有没有改进办法？<ul>
<li>1.当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，即程序收到的请求完全超过了自己的处理能力，而导致自己的正常业务无法开展</li>
<li>2.一旦某一程序发生故障，无法发送同意消息，那么其它程序均处于等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用</li>
<li>改进方法：检测到一个程序故障，直接忽略这个程序，无需等待它的同意消息。但缺点是每个程序需要对其它程序进行故障检测会带来更大的复杂性</li>
</ul>
</li>
<li>Q:HDFS的文件修改过程是怎样的？<ul>
<li>1.计算机1向计算机2、3发送文件修改请求</li>
<li>2.计算机2、3发现自己不需要使用资源，因此同意计算机1的请求</li>
<li>3.计算机1收到其它所有计算机的同意消息后，开始修改该文件</li>
<li>4.计算机1修改完成后，向计算机2、3发送文件修改完成的消息，并发送修改后的文件数据</li>
<li>5.计算机2和3收到计算机1的新文件数据后，更新本地的备份文件</li>
<li><img src="https://img.shiqi-lu.tech/20200905201526.png"></li>
</ul>
</li>
<li>Q:令牌环算法或基于环的算法是怎样的？<ul>
<li>所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序</li>
<li><img src="https://img.shiqi-lu.tech/20200905201547.png"></li>
</ul>
</li>
<li>Q:令牌环方法的优缺点和适用场景是什么？<ul>
<li>优点：</li>
<li>1.单个参与者通信效率较高</li>
<li>2.可用性较高</li>
<li>缺点：</li>
<li>当参与者对临界资源适用频率较低时，会带来较多无用通信</li>
<li>适用场景：系统规模较小，并且系统中每个程序使用共享资源频度较高且使用时间较短的场景</li>
</ul>
</li>
</ul>
<h1 id="04-分布式选举：国不可一日无君"><a href="#04-分布式选举：国不可一日无君" class="headerlink" title="04 | 分布式选举：国不可一日无君"></a>04 | 分布式选举：国不可一日无君</h1><ul>
<li>Q:为什么要有分布式选举？<ul>
<li>主节点在一个分布式集群中负责对其它节点的协调和管理，它的存在可以保证其它节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。（一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况）</li>
</ul>
</li>
<li>Q:Bully算法的选举原则和假设条件是什么？<ul>
<li>选举原则：“长者为大”，在所有活着的节点中，选取ID最大的节点作为主节点</li>
<li>假设条件：集群中每个节点均知道其它节点的ID</li>
</ul>
</li>
<li>Q:Bully算法中节点有哪两种角色？初始角色和变化过程是怎样的？<ul>
<li>普通节点和主节点</li>
<li>初始化时，所有节点都是平等的，都是普通节点，并且都有成为主节点的权利</li>
<li>当选主成功后，有且仅有一个节点成为主节点，其它节点都是普通节点。当且仅当主节点故障或与其它节点失去联系后，才会重新选主</li>
</ul>
</li>
<li>Q:Bully算法选举过程中用到的3种消息是哪些？<ul>
<li>Election消息：用于发起选举</li>
<li>Alive消息：对Election消息的应答</li>
<li>Victory消息：竞选成功的主节点向其它节点发送的宣誓主权的消息</li>
</ul>
</li>
<li>Q:Bully算法的选举过程是怎样？<ul>
<li>1.集群中每个节点判断自己的ID是否为当前活着的节点中ID最大的，如果是，则直接向其它节点发送Victory消息，宣誓自己的主权</li>
<li>2.如果自己不是当前活着的节点中ID最大的，则向比自己大的所有节点发送Election消息，并等待其它节点的回复</li>
<li>3.若在给定的时间范围内，本节点没有收到其它节点回复的Alive消息，则认为自己成为主节点，并向其它节点发送Victory消息，宣誓自己成为主节点；若接收到来自比自己ID打的节点的Alive消息，则等待其它节点发送Victory消息</li>
<li>4.若本节点收到比自己ID小的节点发送的Election消息，则回复一个Alive消息，告知其它节点，我比你大，重新选举</li>
<li><img src="https://img.shiqi-lu.tech/20200905201614.png"></li>
</ul>
</li>
<li>Q:Bully算法的优缺点是什么？<ul>
<li>优点：选举速度快、算法复杂度低、简单易实现</li>
<li>缺点：</li>
<li>1.需要每个节点有全局的节点信息，因此额外信息存储较多</li>
<li>2.任意一个比当前主节点ID大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主</li>
</ul>
</li>
<li>Q:Bully算法的应用例子？<ul>
<li>MongoDB的副本集故障转移功能：采用最后操作时间戳来表示ID，时间戳最新的节点其ID，时间戳最新的节点ID最大，即时间戳最新的、活着的节点是主节点</li>
</ul>
</li>
<li>Q:Raft算法选举时，集群节点的角色有哪3种？<ul>
<li>Leader：主节点，同一时刻只有一个Leader，负责协调和管理其它节点</li>
<li>Candidate：候选者，每一个节点都可以成为Candidate，节点在该角色下才可以被选为新的Leader</li>
<li>Follower：Leader的跟随者，不可以发起选举</li>
</ul>
</li>
<li>Q:Raft选举的流程是怎样？<ul>
<li>1.初始化时，所有节点均为Follower状态</li>
<li>2.开始选主时，所有节点的状态由Follower转化为Candidate，并向其它节点发送选举请求</li>
<li>3.其它节点根据接收到的选举请求的先后顺序，回复是否同意成为主。注意这里的每一轮选举中，一个节点只能投出一张票</li>
<li>4.若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为Leader，其它节点的状态则由Candidate降为Follower。Leader节点与Follower节点之间会定期发送心跳包，以检测主节点是否活着</li>
<li>5.当Leader节点的任期到了，即发现其它服务器开始下一轮选主周期时，Leader节点的状态由Leader降级为Follower，进入新一轮选主</li>
<li><img src="https://img.shiqi-lu.tech/20200905201819.png"></li>
</ul>
</li>
<li>Q:Raft算法的应用例子？<ul>
<li>Google 开源的 Kubernetes，擅长容器管理与调度，为了保证可靠性，通常会部署 3 个节点用于数据备份。这 3 个节点中，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件。而，etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的</li>
</ul>
</li>
<li>Q:Raft算法的优缺点是什么？<ul>
<li>优点：<ul>
<li>1.选举速度快、算法复杂度低、易于实现</li>
<li>2.选举稳定性比Bully算法好，因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主</li>
</ul>
</li>
<li>缺点：要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大</li>
</ul>
</li>
<li>Q:ZAB算法选举时，集群有哪3种角色？<ul>
<li>Leader: 主节点</li>
<li>Follower: 跟随者节点</li>
<li>Observer: 观察者，无投票权</li>
</ul>
</li>
<li>Q:ZAB算法选举过程中，集群中的节点拥有哪4个状态？<ul>
<li>Looking（选举）状态：当节点处于该状态时，它会认为当前集群中没有Leader，因此自己进入选举状态</li>
<li>Leading（领导者）状态：表示已经选出主，且当前节点为Leader</li>
<li>Following（跟随者）状态：集群中已经选出主后，其它非主节点状态更新为Following，表示对Leader的追随</li>
<li>Observing（观察者）状态：表示当前节点为Observer，持观望态度，没有投票权和选举权</li>
</ul>
</li>
<li>Q:ZAB算法的节点的数据结构三元组(server_id, server_zxID, epoch)分别是什么意思？<ul>
<li>server_id: 本节点的唯一ID</li>
<li>server_zxID: 本节点存放的数据ID，数据ID越大表示数据越新，选举权重越大</li>
<li>epoch: 当前选取轮数，一般用逻辑时钟表示</li>
</ul>
</li>
<li>Q:ZAB算法的选举过程的数据结构（vote_id, vote_zxID）分别是什么意思？<ul>
<li>vote_id: 被投票节点的ID</li>
<li>vote_zxID: 被投票节点的服务器zxID</li>
</ul>
</li>
<li>Q:ZAB算法的核心和选主原则是什么？<ul>
<li>核心：少数服从多数，ID大的节点优先成为主</li>
<li>选主原则：server_zxID最大者成为Leader, 若server_zxID相同，则server_id最大者成为Leader</li>
</ul>
</li>
<li>Q:ZAB算法的选举过程是怎样？<ul>
<li>1.当系统刚启动时，3个服务器当前投票均为第一轮投票，即epoch=1, 且zxID均为0。此时每个服务器都推选自己，并将选票信息&lt;epoch, vote_id, vote_zxID&gt;广播出去</li>
<li><img src="https://img.shiqi-lu.tech/20200905201623.png"></li>
<li>2.根据判断规则，由于3个Server的epoch、zxID都相同，因此比较server_id，较大者即为推选对象，因此Server1和Server2将vote_id改为3，更新自己的投票箱并重新广播自己的投票</li>
<li><img src="https://img.shiqi-lu.tech/20200905201632.png"></li>
<li>3.此时系统内所有服务器都推选了Server3，因此Server3当选Leader，处于Leading状态，向其它服务器发送心跳包并维护连接；Server1和2处于Following状态</li>
<li><img src="https://img.shiqi-lu.tech/20200905201638.png"></li>
</ul>
</li>
<li>Q:ZAB算法的优缺点是什么？<ul>
<li>优点：<ul>
<li>1.性能高，对系统无特殊要求</li>
<li>2.选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点 ID 最大，且获得投票数过半，才会导致切主</li>
</ul>
</li>
<li>缺点：<ul>
<li>1.采用广播方式发送信息，若节点中有n个节点，每个节点同时广播，则集群中信息量为n*(n-1)个消息，容易出现广播风暴</li>
<li>2.除了投票，还增加了对比节点ID和数据ID，这就意味着还需要知道所有节点ID和数据ID，所以选举时间相对较长</li>
</ul>
</li>
</ul>
</li>
<li>Q:Bully、Raft、ZAB算法对比图？<ul>
<li><img src="https://img.shiqi-lu.tech/20200905201805.png"></li>
</ul>
</li>
</ul>
<h1 id="05-分布式共识：存异求同"><a href="#05-分布式共识：存异求同" class="headerlink" title="05 | 分布式共识：存异求同"></a>05 | 分布式共识：存异求同</h1><ul>
<li>Q:分布式选举问题的本质是什么？<ul>
<li>传统的分布式共识方法，主要是基于多数投票策略实现的</li>
</ul>
</li>
<li>Q:什么是分布式共识？<ul>
<li>在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程</li>
<li>本质是“求同存异”</li>
</ul>
</li>
<li>Q:分布式共识的两个关键点是什么？<ul>
<li>1.获得记账权</li>
<li>2.所有节点或服务器达成一致</li>
</ul>
</li>
<li>Q:区块链是什么？<ul>
<li>由包含交易信息的区块从后向前有序链接起来的数据结构</li>
<li>其中区块是指很多交易数据的集合，每个区块包括区块头和区块体<ul>
<li>区块体包括前一区块的哈希值、本区块的哈希值和时间戳</li>
<li>区块体用来存储交易数据</li>
</ul>
</li>
</ul>
</li>
<li>Q:有哪3种解决分布式在线记账一致性问题的共识技术？<ul>
<li>PoW: Proof-of-Work, 工作量证明</li>
<li>PoS: Proof-of-Stake, 权益证明</li>
<li>DPoS: Delegated Proof of Stake, 委托权益证明</li>
</ul>
</li>
<li>Q:PoW算法是什么？<ul>
<li>以每个节点或服务器的计算能力来竞争记账权的机制，即使用工作量证明机制的共识算法</li>
</ul>
</li>
<li>Q:假设每个节点会划分多个区块用于记录用户交易，PoW算法获取记账权的原理是什么？<ul>
<li>利用区块的index、前一区块的哈希值、交易的时间戳、区块数据和nonce值，通过SHA256计算出一个哈希值</li>
<li>判断前k个值是否都为0<ul>
<li>如果不是，递增nonce值，重新按照上述方法计算</li>
<li>如果是，本次计算的哈希值为要解决的题目的正确答案</li>
</ul>
</li>
<li>谁最先计算出正确答案，谁就获得这个区块的记账权</li>
<li>注：nonce值是用来找到一个满足哈希值的数字；k 为哈希值前导零的个数，标记了 计算的难度，0 越多计算难度越大</li>
</ul>
</li>
<li>Q:达成共识的过程，其本质是？<ul>
<li>即获得记账权的节点将该区块信息广播给其它节点，其它节点判断该结点找到的区块中的所有交易都是有效且之前未存在过的，则认为该区块有效，并接受该区块</li>
</ul>
</li>
<li>Q:基于PoW的共识记账过程是怎样的？(以分散在世界各地的 5 台服务器为例，假设客户端A产生一个新的交易)<ul>
<li><img src="https://img.shiqi-lu.tech/20210209112307.png"></li>
<li>1.客户端A产生新的交易，向全网进行广播，要求对交易进行记账</li>
<li>2.每个记账节点接收到这个请求后，将受到的交易信息放入一个区块中</li>
<li>3.每个节点通过PoW算法，计算本节点的区块的哈希值，尝试找到一个具有足够工作量难度的工作量证明</li>
<li>4.若节点D找到了一个工作量证明向全网广播。当且仅当包含在该区块中的交易都是有效且之前未存在过的，其它节点才会认同该区块的有效性</li>
<li>5.其它节点接收到广播信息后，若该区块有效，接受该区块，并跟随在该区块的末尾，制造新区块延长该链条，将被接受的区块的随机哈希值视为新区块的随机哈希值</li>
<li>核心：谁的计算能力强，获得记账权的可能性就越大。但必须保证其记 账的区块是有效的，并在之前未存在过，才能获得其他节点的认可</li>
</ul>
</li>
<li>Q:PoW机制的优缺点？<ul>
<li>优点：实现了相对的公平。PoW 的容错机制允许全网 50% 的节点出错，如果要破坏系统，则需要投入极大成本（若你有全球 51% 的算力，则可尝试攻击比特币）</li>
<li>缺点：共识达成的周期长、效率低，资源消耗大。每次达成共识需要全网共同参与运算，增加了每个节点的计算量。如果题目过难，会导致计算时间长、资源消耗多；而如果题目过于简单，会导致大量节点同时获得记账权，冲突多。这些问题，都会增加达成共识的时间</li>
</ul>
</li>
<li>Q:PoS算法的核心原理？<ul>
<li>由系统权益代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大</li>
<li>权益，即每个节点占有货币的数量和时间，而货币就是节点所获得的奖励</li>
</ul>
</li>
<li>Q:基于 PoS 算法获得区块记账权的方法相比基于 PoW 的方法的不同之处是？<ul>
<li>PoS是根据结点拥有的股权或权益进行计算的</li>
</ul>
</li>
<li>Q:通过 PoS 算法决定区块记账权的流程和 PoW 算法的唯一不同的是？<ul>
<li>每个节点在计算自己记账权的时候，通过计算自己的股权或权益来评估，如果发现自己权益最大，则将自己的区块广播给其它节点，当然必须保证该区块的有效性</li>
<li><img src="https://img.shiqi-lu.tech/20210209114030.png"></li>
</ul>
</li>
<li>Q:PoS算法的优缺点？<ul>
<li>优点<ul>
<li>1.将算力竞争转变成权益竞争。与 PoW 相比，PoS 不需要消耗大量的电力就能够保证区块链网络的安全性</li>
<li>2.不需要在每个区块中创建新的货币来激励记账者参与当前网络的运行，这也就在一定程度上缩短了达成共识所需要的时间</li>
</ul>
</li>
<li>缺点<ul>
<li>PoS 算法中持币越多或持币越久，币龄就会越高，持币人就越容易挖到区块并得到激 励，而持币少的人基本没有机会</li>
<li>整个系统的安全性实际上会被持币数量较大的一部分 人掌握，容易出现垄断现象</li>
</ul>
</li>
</ul>
</li>
<li>Q:DPoS(委托权益证明法)是什么？<ul>
<li>由被社区选举的可信账户（受托人，比如得票数排行前 101 位）来拥有记账权</li>
<li>为了成为正式受托人，用户要去社区拉票，获得足够多的信任。用户根据自己持有的货币数量占总量的百分比来投票</li>
<li>根据自己拥有的权益，投票选出可代表自己的受托节点，受托节点之间竞争记账权</li>
<li><img src="https://img.shiqi-lu.tech/20210209114943.png"></li>
<li>通常会选出k(如101)个受托结点，它们的权利是完全相等的。受托节点之间争取记账权也是根据算力进行竞争的。只要受托节点提供的算力不稳定，计算机宕机或者利用手中的权力作恶，随时可以被握着货币的普通节点投票踢出整个系统，而后备的受托节点可以随时顶上去</li>
</ul>
</li>
<li>Q:DPos的优缺点是什么？<ul>
<li>优点<ul>
<li>1.由投票选举出的若干信誉度更高的受托人记账，解决了所有节点均参与竞争导致消息量大、达成一致的周期长的问题。DPoS 能耗更低，具有更快的交易速度</li>
<li>2.每隔一定周期会调整受托人，避免受托人造假和独权</li>
</ul>
</li>
<li>缺点<ul>
<li>1.由于大多数持币人通过受托人参与投票，投票的积极性并不高</li>
<li>2.一旦出现故障节点，DPoS 无法及时做出应对，导致安全隐患</li>
</ul>
</li>
</ul>
</li>
<li>Q:PoW、PoS和DPoS三种共识算法的对比图<ul>
<li><img src="https://img.shiqi-lu.tech/20210209114542.png"></li>
</ul>
</li>
<li>Q:一致性和共识的区别是什么？<ul>
<li>一致性：分布式系统中的多个节点之间，给定一系列的操作，在约定协议的保障下，对外界呈现的数据或状态时一致的</li>
<li>共识：分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程</li>
<li>一致性强调结果，共识强调达成一致的过程，共识算法是保障系统满足不同程度一致性的核心技术</li>
</ul>
</li>
</ul>
<h1 id="06-分布式事务：All-or-nothing"><a href="#06-分布式事务：All-or-nothing" class="headerlink" title="06 | 分布式事务：All or nothing"></a>06 | 分布式事务：All or nothing</h1><ul>
<li>Q:事务和分布式事务是什么？<ul>
<li>事务：包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，通常指本地（或单机）事务</li>
<li>分布式事务：在分布式系统中运行的事务，由多个本地事务组合而成</li>
</ul>
</li>
<li>Q:分布式事务基本特征ACID是什么？<ul>
<li>原子性（Atomicity）：事务的最终状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（回滚）</li>
<li>一致性（Consistency）：事务操作前和操作后，数据的完整性保持一致或满足完整性约束</li>
<li>隔离性（Isolation）：当系统内多个事务并发执行时，多个事务不会相互干扰，即一个事务内部的操作及使用的数据，对其它并发事务是隔离的</li>
<li>持久性（Durability）：一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够被重新访问，那么一定能够将其恢复到事务完成时的状态</li>
</ul>
</li>
<li>Q:刚性事务和柔性事务是什么？<ul>
<li>刚性事务：遵循ACID原则，具有强一致性。如数据库事务</li>
<li>柔性事务：根据不同的业务场景使用不同的方法实现最终一致性。即可根据业务的特性做部分取舍，容忍一定时间内的数据不一致，遵循BASE理论</li>
</ul>
</li>
<li>Q:BASE理论是什么？<ul>
<li>基本可用（Basically Available）：分布式系统出现故障的时候，允许损失一部分功能的可用性</li>
<li>柔性状态（Soft State）：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。如数据库读写分离，写库（主库）同步到读库（从库）会有一个延时，就是柔性状态</li>
<li>最终一致性（Eventual Consistency）：事务在操作过程中可能由于同步延迟导致不一致，但最终状态下，数据都是一致的</li>
<li>BASE理论为了支持大型分布式系统，通过牺牲强一致性，保证最终一致性，来获得高可用性</li>
</ul>
</li>
<li>Q:分布式事务主要解决的问题，以及实现方法有哪3种？<ul>
<li>主要解决：在分布式环境下，组合事务的一致性问题</li>
<li>方法：</li>
<li>1.基于XA协议的二阶段提交协议方法（强一致性，遵从ACID）</li>
<li>2.三阶段提交协议方法（强一致性，遵从ACID）</li>
<li>3.基于消息的最终一致性方法（最终一致性，遵从BASE理论）</li>
</ul>
</li>
<li>Q:XA组成有什么？<ul>
<li>事务管理器（协调者）：负责各个本地资源的提交和回滚</li>
<li>资源管理器（参与者）：通常由数据库实现</li>
</ul>
</li>
<li>Q:两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢?<ul>
<li>引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务</li>
</ul>
</li>
<li>Q:两阶段提交协议的执行过程<ul>
<li>第一阶段：投票(voting)<ul>
<li>协调者(Coordinator，即事务管理器)会向事务的参与者(Cohort，即本地资源管理器)发起执行操作的CanCommit请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送「Yes」消息，表示同意操作；若不成功，则发送「No」消息，表示终止操作</li>
</ul>
</li>
<li>第二阶段：提交(commit)<ul>
<li>当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令：<ul>
<li>若协调者收到的都是「Yes」消息，则向参与者发送「DoCommit」消息，参与者会完成剩余的操作并释放资源，然后向协调者返回「HaveCommitted」消息</li>
<li>如果协调者收到的消息中包含「No」消息，则向所有参与者发送「DoAbort」消息，此时发送「Yes」的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送「HaveCommitted」消息</li>
<li>协调者接收到「HaveCommitted」消息，就意味着整个事务结束了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Q:二阶段提交的算法思路概要<ul>
<li>协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还 是撤销操作</li>
</ul>
</li>
<li>Q:基于 XA 的二阶段提交算法的不足<ul>
<li>同步阻塞问题：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态</li>
<li>单点故障问题：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞</li>
<li>数据不一致问题：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题</li>
</ul>
</li>
<li>Q:三阶段提交协议（Three-phase commit protocol，3PC）相对二阶段提交(2PC)的改进是什么<ul>
<li>为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段</li>
<li>同时在协调者和参与者中引入超时机制。如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务</li>
<li>在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的</li>
</ul>
</li>
<li>Q:三阶段提交协议的详细过程<ul>
<li>1.CanCommit阶段<ul>
<li>协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到 CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No</li>
<li>CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如图</li>
<li><img src="https://img.shiqi-lu.tech/20210225155731.png"></li>
</ul>
</li>
<li>2.PreCommit阶段<ul>
<li>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作<ul>
<li>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：<ul>
<li>发送预提交请求：协调者向参与者发送 PreCommit 请求，进入预提交阶段</li>
<li>事务预提交：参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中</li>
<li>响应反馈：如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令</li>
</ul>
</li>
<li>假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作： <ul>
<li>发送中断请求：协调者向所有参与者发送“Abort”消息</li>
<li>终断事务：参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作</li>
</ul>
</li>
</ul>
</li>
<li>预执行阶段，不同节点上事务执行成功和失败的流程，如图</li>
<li><img src="https://img.shiqi-lu.tech/20210225155951.png"></li>
</ul>
</li>
<li>3.DoCommit阶段<ul>
<li>DoCmmit 阶段进行真正的事务提交，根据 PreCommit 阶段协调者发送的消息，进入执行提交阶段或事务中断阶段</li>
<li>执行提交阶段：<ul>
<li>发送提交请求：协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息</li>
<li>事务提交：参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li>
<li>响应反馈：参与者提交完事务之后，向协调者发送 Ack 响应</li>
<li>完成事务：协调者接收到所有参与者的 Ack 响应之后，完成事务</li>
</ul>
</li>
<li>事务中断阶段：<ul>
<li>发送中断请求：协调者向所有参与者发送 Abort 请求</li>
<li>事务回滚：参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，并释放所有锁住的资源</li>
<li>反馈结果：参与者完成事务回滚之后，向协调者发送 Ack 消息</li>
<li>终断事务：协调者接收到参与者反馈的 Ack 消息之后，执行事务的终断，并结束事务</li>
</ul>
</li>
<li>执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如图</li>
<li><img src="https://img.shiqi-lu.tech/20210225160141.png"></li>
</ul>
</li>
</ul>
</li>
<li>Q:2PC 和 3PC 这两种方法的两个共同的缺点是什么<ul>
<li>1.都需要锁定资源，降低系统性能</li>
<li>2.没有解决数据不一致的问题</li>
</ul>
</li>
<li>Q:基于分布式消息的最终一致性方案的核心思想是什么<ul>
<li>将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试</li>
<li>基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（Message Queue，MQ），用于在多个应用之间进行消息传递</li>
<li><img src="https://img.shiqi-lu.tech/20210225160602.png"></li>
</ul>
</li>
<li>Q:以网上购物为例，阐述分布式消息的最终一致性方案的事务处理<ul>
<li>假设用户 A 在某电商平台下了一个订单，需要支付 50 元，发现自己的账户余额共 150 元，就使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货</li>
<li>在该事件中，涉及到了订单系统、支付系统、仓库系统，这三个系统是相互独立的应用，通过远程服务进行调用</li>
<li><img src="https://img.shiqi-lu.tech/20210225161139.png"></li>
<li>整个购物流程如下</li>
<li><img src="https://img.shiqi-lu.tech/20210225161206.png"></li>
<li><ol>
<li>订单系统把订单消息发给消息中间件，消息状态标记为“待确认”</li>
</ol>
</li>
<li><ol start="2">
<li>消息中间件收到消息后，进行消息持久化操作，即在消息存储系统中新增一条状态为“待发送”的消息</li>
</ol>
</li>
<li><ol start="3">
<li>消息中间件返回消息持久化结果（成功 / 失败），订单系统根据返回结果判断如何进行业务操作。失败，放弃订单，结束（必要时向上层返回失败结果）；成功，则创建订单</li>
</ol>
</li>
<li><ol start="4">
<li>订单操作完成后，把操作结果（成功 / 失败）发送给消息中间件</li>
</ol>
</li>
<li><ol start="5">
<li>消息中间件收到业务操作结果后，根据结果进行处理：失败，删除消息存储中的消息，结束；成功，则更新消息存储中的消息状态为“待发送（可发送）”，并执行消息投递</li>
</ol>
</li>
<li><ol start="6">
<li>如果消息状态为“可发送”，则 MQ 会将消息发送给支付系统，表示已经创建好订单，需要对订单进行支付。支付系统也按照上述方式进行订单支付操作</li>
</ol>
</li>
<li><ol start="7">
<li>订单系统支付完成后，会将支付消息返回给消息中间件，中间件将消息传送给订单系统。订单系统再调用库存系统，进行出货操作</li>
</ol>
</li>
</ul>
</li>
<li>Q:三种分布式事务的实现方式对比图<ul>
<li><img src="https://img.shiqi-lu.tech/20210225160719.png"></li>
</ul>
</li>
<li>Q:刚性事务和柔性事务是什么？<ul>
<li>刚性事务，遵循 ACID 原则，具有强一致性。比如，数据库事务</li>
<li>柔性事务，其实就是根据不同的业务场景使用不同的方法实现最终一致性，即可根据业务的特性做部分取舍，容忍一定时间内的数据不一致</li>
</ul>
</li>
<li>Q:BASE理论是什么？<ul>
<li>基本可用（Basically Available）：分布式系统出现故障的时候，允许损失一部分功能的可用性</li>
<li>柔性状态（Soft State）：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态</li>
<li>最终一致性 （Eventual Consistency）：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的</li>
<li>BASE 理论为了支持大型分布式系统，通过牺牲强一致性，保证最终一致性，来获得高可用性，是对 ACID 原则的弱化</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸语法1-3课</title>
    <url>/gramma1-3/</url>
    <content><![CDATA[<h1 id="1-英语简单句的造句规则和基本语法概念"><a href="#1-英语简单句的造句规则和基本语法概念" class="headerlink" title="1.英语简单句的造句规则和基本语法概念"></a>1.英语简单句的造句规则和基本语法概念</h1><h2 id="一些基本的语法概念"><a href="#一些基本的语法概念" class="headerlink" title="一些基本的语法概念"></a>一些基本的语法概念</h2><ul>
<li>英语单词分为虚词和实词<ul>
<li>虚词：介词，连词</li>
<li>实词：名词，动词，形容词，副词</li>
</ul>
</li>
<li>句子成分：主谓宾</li>
</ul>
<h2 id="英语句子的本质和灵魂：五大动词——五大句型"><a href="#英语句子的本质和灵魂：五大动词——五大句型" class="headerlink" title="英语句子的本质和灵魂：五大动词——五大句型"></a>英语句子的本质和灵魂：五大动词——五大句型</h2><h3 id="系动词-gt-主语-系动词-表语（主系表句型）"><a href="#系动词-gt-主语-系动词-表语（主系表句型）" class="headerlink" title="系动词-&gt;主语+系动词+表语（主系表句型）"></a>系动词-&gt;主语+系动词+表语（主系表句型）</h3><ul>
<li>什么是系动词<ul>
<li>所谓的系动词，也属于动词的一种在句子里做谓语，没有实际意思比如汉语里的”是”、”为”英语里的am、is、 are就是联系，在句子中起一个联系作用，叫做系动词。</li>
</ul>
</li>
<li>什么是表语<ul>
<li>而在联系动词之后的补充说明主语性质的部分，就叫做表语</li>
</ul>
</li>
<li>如何判断主系表结构<ul>
<li>用中文判断这个句子里的谓语，可否用“是”或者“为”来翻译</li>
<li>I am a good person</li>
<li>I become a good person</li>
</ul>
</li>
<li>4大类系动词<ul>
<li>1.be动词：am is are和它们对应的过去将来时态，在be动词之后，有3大类表语：名词、形容词、地点副词<ul>
<li>名词作表语：这种句子和汉语可以完全对应，be动词翻译成汉语“是”<ul>
<li>Tim is an engineer.蒂姆是个工程师</li>
<li>The price is £2,000! 价格是2,000英镑!</li>
</ul>
</li>
<li>形容词作表语：和汉语不一样，be动词不会被翻译，直接被省略，介词短语也相当于形容词<ul>
<li>The play was very interesting. 戏很有意思</li>
<li>The milk is in the refrigerator. 牛奶在冰箱里</li>
</ul>
</li>
<li>地点副词作表语：只能是地点副词，别的副词不行<ul>
<li>Your sister is here these days. 你姐姐这几天在这</li>
<li>My bedroom is downstairs. 我的卧室在楼下</li>
</ul>
</li>
</ul>
</li>
<li>2.状态保持动词（keep, remain, stay）后只能加形容词作表语，可以和be无缝切换<ul>
<li>You should keep quiet! 你应该保持安静!</li>
<li>No one can remain youthful forever. 没有人能永保青春。</li>
<li>The weather stayed fine for a week. 这个星期天气一直很好。</li>
</ul>
</li>
<li>3.状态转变类动词(become, get, go, come, grow, turn)<ul>
<li>become:万能词，表示“变成”的时候后面只能接名词，表示“变得”后面一般接形容词<ul>
<li>He became a teacher.他成为了一名教师</li>
<li>He became very nervous. 他变得很紧张</li>
</ul>
</li>
<li>get:表示“变得怎样”，后面只能加形容词<ul>
<li>He got very angry. 他非常生气</li>
</ul>
</li>
<li>come:本意是来，通常是好的东西会来，所以come含有“变好”的意思<ul>
<li>Thing will come right.事情会变好</li>
</ul>
</li>
<li>go:意思是走，去，通常是坏的东西离你而去，所以可表达“变坏”<ul>
<li>The meat always goes bad in summer. 肉在夏天经常会坏掉</li>
</ul>
</li>
<li>grow:本意“生长”，可表达“慢慢变”<ul>
<li>The weather grew cold in the night.晚上天气慢慢变冷</li>
</ul>
</li>
<li>turn:本意转身，可表达“快速变”<ul>
<li>His face turned pale.他脸色变得苍白</li>
</ul>
</li>
</ul>
</li>
<li>4.感官动词(look, sound, smell, taset, feel)：一律翻译为“。。。起来”，即看起来，听起来。。后面只能接形容词（或相当于形容词的分词）作表语<ul>
<li>I felt very nervous when I went into his office.我走进他的办公室，感到非常紧张。</li>
<li>He looked very angry.他看上去非常气愤。</li>
<li>They were all hungry and the food smelled good.他们全都饿了，饭菜散发出阵阵香味。</li>
<li>感官动词后，决不能直接加名词作表语，如要加名词，必须用：感官动词+介词like+名词，此时翻译为”像…..”<ul>
<li>The sun looks like an orange globe.太阳看上去像只橙色的球体。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>每件事都很有序。( in good order )<ul>
<li>Everything is in good order.</li>
</ul>
</li>
<li>我的房子就在这里。<ul>
<li>My house is here.</li>
</ul>
</li>
<li>这辆轿车看起来很棒。<ul>
<li>This car looks very good.</li>
</ul>
</li>
<li>鳄鱼肉尝起来就像鸡肉。<ul>
<li>Alligator meat tastes like chicken.</li>
</ul>
</li>
<li>地震期间你应该保持冷静。<ul>
<li>You should keep calm during an earthquake.</li>
</ul>
</li>
<li>迈克去年成为一名职业篮球运动员。<ul>
<li>Mike became a professional basketball player last year.</li>
</ul>
</li>
<li>天气变得寒冷而多风( cold and windy )<ul>
<li>The weather has turned cold and windy.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="不及物动词-gt-主谓句型"><a href="#不及物动词-gt-主谓句型" class="headerlink" title="不及物动词-&gt;主谓句型"></a>不及物动词-&gt;主谓句型</h3><ul>
<li>不及物动词是什么<ul>
<li>intransitive verb，简称vi. 就是本身意就很完全，没有作用对象，不需要加宾语就能构成完整的句子，例如：游泳，出生，笑，做梦.</li>
<li>判断这类动词，有个方法很简单，把这个动词前面加上”被”字，看正常不正常。如果正常，就是及物动词，不正常，就是不及物动词。例如：被打，被处罚，被喜欢.</li>
<li>但如果说：被跳舞，被做梦，被游泳…..，肯定自己会觉得不通顺</li>
</ul>
</li>
<li>注意事项<ul>
<li>1.这个句型，一般来说都带有状语，来进一步说明这个动作发生的时间，地点，目的….<ul>
<li>Detectives(主语) were waiting(谓语) at the airport(地点状语) all morning(时间状语</li>
<li>They(主语) were talking(谓语) loudly(方式状语)</li>
</ul>
</li>
<li>2.很多动词，本身既可作不及物动词，也可作及物动词，得在具体语境中判断</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.鸟儿快乐地唱着歌。<ul>
<li>1.The birds sing happily.</li>
</ul>
</li>
<li>2.这场雨下午会停。<ul>
<li>2.The rain will stop in the afternoon.</li>
</ul>
</li>
<li>3.孩子们正在公园里玩耍。<ul>
<li>3.The children are playing in the park.</li>
</ul>
</li>
<li>4.我的老师昨天在医院去世了。(pass away)<ul>
<li>4.My teacher passed away in the hospital yesterday.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="及物动词-gt-主谓宾"><a href="#及物动词-gt-主谓宾" class="headerlink" title="及物动词-&gt;主谓宾"></a>及物动词-&gt;主谓宾</h3><ul>
<li>举例<ul>
<li>Yesterday(时间状语), a pigeon(主语) carried(谓语) the first(定语) message(宾语) from Pinhurst to Silbury(地点状语). 昨天，一只鸽子把第一封信从平赫特带到锡尔伯里。</li>
<li>The bird(主语) covered(谓语) the distance(宾语) in three minutes.(时间状语) 这只鸟只用了3分钟就飞完了全程。</li>
<li>The bride and the groom cut the wedding cake together.新郎和新娘一起切下结婚蛋糕。</li>
<li>I had an amusing experience last year.去年我有过一次有趣的经历。</li>
<li>This wonderful plane can carry seven passengers.这架奇妙的飞机可以载7名乘客。</li>
</ul>
</li>
<li>及物动词是什么？<ul>
<li>transitive verb，简称vt. 就是加了宾语以后意思很完全的动词，有主动和被动两种语态</li>
<li>有些短语相当于及物动词，称为及物动词短语</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.老师在教室的墙上贴了一些照片。<ul>
<li>1.The teacher put up some pictures on the wall in the classroom.</li>
</ul>
</li>
<li>2.在公共场合你应该尊敬老人。<ul>
<li>2.You should respect the old in public places.</li>
</ul>
</li>
<li>3.他一周前开始节食。<ul>
<li>3.He began his diet a week ago.</li>
</ul>
</li>
<li>4.他于1935年9月创造了一项新的世界纪录。<ul>
<li>4.He set up a new world record in September 1935.</li>
</ul>
</li>
<li>5.只有极少数人能实现他们的梦想。<ul>
<li>5.Only very few people can realize their dreams.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="不完全及物动词-gt-主语-谓语-宾语-宾语补语"><a href="#不完全及物动词-gt-主语-谓语-宾语-宾语补语" class="headerlink" title="不完全及物动词-&gt;主语+谓语+宾语+宾语补语"></a>不完全及物动词-&gt;主语+谓语+宾语+宾语补语</h3><ul>
<li>概述<ul>
<li>她使我爱上生活。</li>
<li>这个”使”就是不完全及物动词，如果只说“她使我”意思当然不完整, 得加上补语”爱上生活”，才是完整的句子</li>
<li>他的表演让我失望。</li>
<li>这个“让”如果说”他的表演让我”，当然也不完全得加上补语”失望”</li>
</ul>
</li>
<li>不完全及物动词是什么？<ul>
<li>incomplete transitive verb, 简称i.vt 这种动词加了宾语以后，意思仍</li>
<li>然不完全, 需要加上补语( complement )才能使句子完整</li>
<li>补语是补充说明宾语的特征，或者宾语的动作。</li>
</ul>
</li>
<li>如何区分完全及物动词和不完全及物动词<ul>
<li>最常见的不完全及物动词：使役动词：使…..做…. (make, have, let, get)</li>
<li>make / have /let +宾语+动词原形(补语)</li>
<li>get +宾语+动词不定式(补语)<ul>
<li>I made him wash the car. 我叫他洗车。</li>
<li>I got him to wash the car.我叫他洗车。</li>
</ul>
</li>
</ul>
</li>
<li>综上所述，只要是宾语发出的动作，或宾语的状态，均可构成此类句型。知道了这一道理，遇到类似句子，都能做出准确判断。</li>
<li>造句练习<ul>
<li>炎热的天气使我感到昏昏欲睡(feel lethargic)。<ul>
<li>The hot weather made me feel lethargic.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="授予动词-gt-主语-谓语-间接宾语-直接宾语"><a href="#授予动词-gt-主语-谓语-间接宾语-直接宾语" class="headerlink" title="授予动词-&gt;主语+谓语+间接宾语+直接宾语"></a>授予动词-&gt;主语+谓语+间接宾语+直接宾语</h3><ul>
<li>概述<ul>
<li>我给了他一本书”</li>
<li>动作“给”需要两个步骤,先拿起书,再给他</li>
<li>有两个宾语“他”和“书”，因为先拿书,再给他，所以“书”是直接宾语，“他”是间接宾语</li>
</ul>
</li>
<li>授予动词是什么？<ul>
<li>及物动词中的一种，但需要接两个宾语，第一个是间接宾语(indirect object， i.o.)，表示授予的对象，第二个宾语是直接宾语(direct object, d.o.)，表示授予的东西</li>
<li>要注意的是，直接宾语和间接宾语，都是谓语动作的作用对象，这是与第四大句型的区别。在第四大句型中，补语是说明宾语的性质，或者是宾语发出的动作</li>
</ul>
</li>
<li>最常用的授予动词：give, send, tell, teach, pay, show, offer<ul>
<li>Richard Mattes gave the testers six different kinds of things. Richard Mattes给了这些测试者6种不同类型的东西。</li>
<li>I send him a book in reward for his help.我送给他一本书来答谢他的帮助。</li>
<li>The scientist told us many stories about birds.博物学家给我们讲述了许多有关鸟儿的故事。</li>
<li>A friendly waiter taught me a few words of Italian. Then he lent me a book.一位好客的服务员教了我几句意大利语，之后还借给我一本书。</li>
<li>Yesterday I paid him a visit.昨天我去看望 了他。</li>
<li>Then he showed me the contents of the parcel.接着他给我看了包里的东西。</li>
<li>He offered me a lot of money.他给了我很多钱。</li>
</ul>
</li>
<li>第4大句型和第5大句型的区分<ul>
<li>只要是谓语的动作，作用于两个不同的名词，也就是两个宾语,就是第5大句型。而在第4大类句型中，补语是宾语的动作或状态。</li>
<li>举例:</li>
<li>1.他让我学习。”学习”是“我”发出的动作</li>
<li>2.他给了我一本书。 “书”和“我”都是谓语“给”的作用对象</li>
<li>所以，第1句是第4大句型，第2句是第5大句型。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.情人节他送给女友一束花。<ul>
<li>1.He gave a bunch of flowers to his girlfriend on Valentine’s Day.</li>
</ul>
</li>
<li>2.请寄给我一张收到此款的收据。<ul>
<li>2.Please send me a receipt for the money.</li>
</ul>
</li>
<li>3.他告诉我几个关于英语老师的神奇故事。<ul>
<li>3.He told me some magical stories about our English teacher.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="首相的英语学习方法"><a href="#首相的英语学习方法" class="headerlink" title="首相的英语学习方法"></a>首相的英语学习方法</h2><ul>
<li>1.了解句子成分的具体含义识别出句子的不同成分</li>
<li>2.学习时态、语态等基础知识</li>
<li>3.学习从句的构句方法把一个长句子变成一个句子成分把不同句子成分组合</li>
<li>4.用彩色笔标注不同句子成分，从句子相关成分中，积累相关用法</li>
<li>5.把复杂句拆成若干个简单句子，设定好主语宾语，采用学习的规则，拼成长句子</li>
<li>或，读完句子英汉互译，先翻译成中文再翻译成英文再对照原句</li>
</ul>
<h2 id="7大英语句子成分概述"><a href="#7大英语句子成分概述" class="headerlink" title="7大英语句子成分概述"></a>7大英语句子成分概述</h2><ul>
<li>主语：句子的主人</li>
<li>谓语：表达主语动作状态</li>
<li>宾语：客体、受体</li>
<li>表语：表达主语具体情况</li>
<li>补语：补充说明</li>
<li>定语：一个句子里用来界定、限定名词的部分<ul>
<li>能作定语的语法成分：形容词以及相当于形容词性质的语法成分</li>
<li>英语95%的定语遵循“前小后大”法则<ul>
<li>1个单词组成的定语(限定词，形容词，名词及名词所有格)， 放在所修饰名词的前面。</li>
<li>2个以上单词组成的定语( of属格，形容词短语，介词短语，分词短语，不定式短语等)， 放在所修饰词后面。 <ul>
<li>1.They were expecting a(限定词) valuable(形容词) parcel of diamonds(of属格) from South Africa.(介词短语)他们正期待从南非来的一个装着钻石的贵重包裹。(上面四个定语,均修饰parcel)</li>
<li>2.Mrs. Rumbold was a(限定词) large(形容词), unsmiling(形容词) lady in a tight black dress.(介词短语) 兰伯尔德夫人是一位身材高大、表情严肃的女人，穿一件紧身的黑衣服。</li>
<li>3.First of all, he wrote out a(限定词) long(形容词) list of all the foods.(of属格)首先，他开列了一张长长列了所有食物的目录。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我喜欢课桌上那本英语书。<ul>
<li>I like the English book on the table.</li>
</ul>
</li>
<li>2.他们正在研究一个关于贸易标准(trading standard)的复杂问题。<ul>
<li>They are studying a complicated problem about trading Standard.</li>
</ul>
</li>
<li>3.我将告诉你们昨天老师给我讲的那个非常有趣的关于月亮的中国古代故事<ul>
<li>I will tell you a very interesting old Chinese story about the moon that my teacher told me yesterday</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>状语：用来描述一个动作的细节特征的成分，除了修饰动词外，状语也可以修饰除了名词之外的任何词(如形容词，介词，连词，还可以修饰副词本身!)<ul>
<li>能作状语的语法成分：副词以及相当于副词的语法成分</li>
<li>小状语(单独的副词)，放在其所修饰的词语之前：修饰动词时，放在动词之前。修饰其它成分(形容词、介词、连词、副词)时，放在其它成分之前。注：如有需要，小状语可以放在句中任何位置!<ul>
<li>We are now living in a beautiful new house in the country.我们现在住在乡间的一栋漂亮的新住宅里。</li>
<li>Letters will cost a little more, but they will certainly travel faster.这样会稍微多花点钱，但肯定是快得多了。</li>
</ul>
</li>
<li>大状语(2个及以上单词构成的状语，如介词短语、不定式短语、状语从句)，放在整句的两头。放在开头时，一般要加上逗号。<ul>
<li>On Wednesday evening, we went to the Town Hall. 星期三的晚上，我们去了市政厅。</li>
<li>I was having dinner at a restaurant when Tony Steele came in.我正在一家饭馆吃饭，托尼斯蒂尔走进来。</li>
</ul>
</li>
<li>1.句子同时出现几个时间或者地点状语时，从小到大<ul>
<li>We landed in America at 8 o’ clock on June 15th，2012.我们2012年6月15日上午8点在美国着陆。</li>
<li>We live at number 35, South Renmin Road, Chengdu.我们住在成都市人民南路35号。</li>
</ul>
</li>
<li>2.句子后面有多种状语时，顺序是方式-地点-时间<ul>
<li>He put his milk bottles carefully on the doorstep every morning. 他每天早上小心地把牛奶瓶放在门口台阶上。</li>
</ul>
</li>
</ul>
</li>
<li>同位语：句子中指代同一事物的两个词、短语或从句，称为同位关系<ul>
<li>英语里边的同位语， 不属于单独的7大句子成分，而是和英语里边的名词成分(主语，宾语，表语)是并列关系，相当于对该名词的进一步解释说明。名词或任何相当于名词的成分，均可作同位语。</li>
<li>造句练习<ul>
<li>1.我的英语老师Brent Peter先生是加拿大人。<ul>
<li>My English teacher, Mr. Brent Peter, is a Canadian.</li>
</ul>
</li>
<li>2.昨天我遇到了我弟弟的朋友汤姆。<ul>
<li>Yesterday I met Tom, a friend of my brother’ s.</li>
</ul>
</li>
<li>3.我们中国人民是勤劳勇敢的。<ul>
<li>We Chinese people are brave and hardworking.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2-如何避免犯时态错误"><a href="#2-如何避免犯时态错误" class="headerlink" title="2.如何避免犯时态错误"></a>2.如何避免犯时态错误</h1><h2 id="时态的本质"><a href="#时态的本质" class="headerlink" title="时态的本质"></a>时态的本质</h2><ul>
<li>时态=”时间”和”状态”=tense and aspect</li>
<li><img src="https://img.shiqi-lu.tech/20201104130711.png?imageView2/2/h/200"></li>
</ul>
<h2 id="谓语动词的四种状态"><a href="#谓语动词的四种状态" class="headerlink" title="谓语动词的四种状态"></a>谓语动词的四种状态</h2><ul>
<li>1.一般（simple）:强调动作发生的时间，而非状态<ul>
<li>I play basketball. 我打篮球</li>
</ul>
</li>
<li>2.进行（continuous）：强调动作的过程（描绘，生动性）<ul>
<li>I am playing basketball. 我正在打篮球</li>
</ul>
</li>
<li>3.完成（perfect）:强调动作的结果（逻辑推导性）<ul>
<li>I have played basketball. 我打完篮球了</li>
</ul>
</li>
<li>4.完成进行（perfect continuous）：强调动作的结果和过程<ul>
<li>I have been playing basket ball. 我一直都有打篮球</li>
</ul>
</li>
</ul>
<h2 id="动词在不同时态下词形的变化"><a href="#动词在不同时态下词形的变化" class="headerlink" title="动词在不同时态下词形的变化"></a>动词在不同时态下词形的变化</h2><ul>
<li>进行：be+现在分词(be按照3时及主语人称变化)</li>
<li>完成：have+过去分词(have按照3时及主语人称变化)</li>
<li>完成进行：have been+现在分词(have按照3时及主语人称变化)</li>
<li>以动词do为例：<ul>
<li>现在 进行: am/is/are doing</li>
<li>过去 进行: was/were doing</li>
<li>将来 进行: will be doing</li>
<li>现在 完成: have/has done</li>
<li>过去 完成: had done</li>
<li>将来 完成: will have done</li>
<li>现在 完成进行: have/has been doing</li>
<li>过去 完成进行: had been doing</li>
<li>将来 完成进行: will have been doing</li>
</ul>
</li>
</ul>
<h2 id="一般态：强调动作本身"><a href="#一般态：强调动作本身" class="headerlink" title="一般态：强调动作本身"></a>一般态：强调动作本身</h2><ul>
<li>定义<ul>
<li>只强调动作发生的时间，不强调动作的状态，就是说它只关心这个动作是发生在过去，现在，还是将来，不关心这件事情有没有做好</li>
</ul>
</li>
<li>一般态和进行态的主要区别<ul>
<li>I walk to school.我走路去学校， 这个句子只强调一般情况，不强调动作的状态是怎么样。</li>
<li>I’m walking to school.这个强调的就是动作本身，我正在路上</li>
</ul>
</li>
<li>一般现在时<ul>
<li>1.表示事物现在的情况或状态（主系表句型）<ul>
<li>I <code>am</code> a doctor. 我是一个医生。</li>
<li>You <code>are</code> an unrepeatable miracle. 你是一个无法重复的奇迹。</li>
</ul>
</li>
<li>2.表示经常性、习惯性动作（常有时间副词修饰）<ul>
<li>I <strong>never</strong> <code>get up</code> early on Sundays. I sometimes <strong>stay</strong> in bed until lunch time. 星期天我是从来不早起的，有时我要直躺到吃 午饭的时候。</li>
<li>Winners <strong>often</strong> <code>seek</code> opportunity when losers <strong>want</strong> security. 失败者寻求安全的时候，成功者寻求机遇。</li>
<li>Do you <strong>always</strong> <code>get up</code> so late? It’s one o’clock! 你总是起得这么晚吗?现在已经1点钟了!</li>
<li>注：一般现在时常使用表示频率的副词，如never, often, always</li>
</ul>
</li>
<li>3.表示客观真理、格言<ul>
<li>Time <code>flies</code>. 时光飞逝。</li>
<li>The early bird <code>catches</code> the worm. 早起的鸟儿有虫吃。</li>
<li>Failure <code>is</code> the mother of success. 失败是成功之母。</li>
</ul>
</li>
</ul>
</li>
<li>一般过去式：表示过去的动作、习惯、事实<ul>
<li>Last Sunday I <code>got up</code> very late. I <code>looked</code> out of the window. It <code>was</code> dark outside. 在上个星期天，我起得很晚。我望望窗外，外面一片昏暗。</li>
<li>Last summer, I <code>went</code> to Italy. 去年夏天，我去了意大利。</li>
<li>Colubus discovered America in 1742. 哥伦布于1492年发现了美洲。</li>
<li>注：一般过去时常使用过去具体时间的副词，如yesterday, last week, two years ago, in 1998……</li>
</ul>
</li>
<li>一般将来时<ul>
<li>1.表示将来发生的动作或状态，或倾向(will译为“将要”)<ul>
<li>He <code>will</code> soon <code>visit</code> Darwin. From there, he <code>will fly</code> to Perth. 他不久还将到达达尔文去，从那里，他再飞往珀斯。</li>
<li>People <code>will</code> run into problems in their lives. 人们在生活中总会遇到问题。</li>
<li>A small leak <code>will</code> sink a great ship. 小裂缝可以沉大船。(千里之堤，溃于蚁穴)</li>
</ul>
</li>
<li>be going to+动词原形：表示将来时，但多表示“计划”，主语多为“人”。will表示“意愿”时，主语是“人”。但也可以表示“预测”，主语是“物”<ul>
<li>Debbie Hart is going to swim across the English Channel tomorrow. 黛比.哈特准备明天横渡英吉利海峡。</li>
<li>She is going to set out from the French coast at five o’clock in the morning. 她打算早上5点钟从法国海岸出发。</li>
<li>Mr. Thompson is going to sell it because it is haunted. 汤普森先生之所以想卖它，是因为那里常闹鬼。</li>
</ul>
</li>
<li>be about to + 动词原形：即将。。<ul>
<li>He is about to leave for Shenyang. 他将要离开去沈阳。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.这家便利店全天24小时营业。<ul>
<li>1.This convenience store is open 24 hours a day.</li>
</ul>
</li>
<li>2.我爷爷每天早上都在公园里散步。<ul>
<li>2.My grandfather takes a walk in the park every morning.</li>
</ul>
</li>
<li>3.昨天我很无聊，便跟着几个朋友看电影去了。<ul>
<li>3.I felt bored yesterday, So I went to the movies with several friends.</li>
</ul>
</li>
<li>4.他明天将要去纽约。<ul>
<li>4.He will go to New York tomorrow.</li>
</ul>
</li>
<li>5.看！那艘船快要沉没了。(be about to)<ul>
<li>5.Look! The boat is about to sink.</li>
</ul>
</li>
<li>6.我们马上就要吃午餐了。<ul>
<li>6.We are going to have lunch soon.</li>
</ul>
</li>
<li>7.太阳东升西落。<ul>
<li>7.The sun rises in the east and sets in the west.</li>
</ul>
</li>
<li>8.我每周去两次健身房。<ul>
<li>8.I go to the gym twice a week.</li>
</ul>
</li>
<li>9.我昨天早上在图书馆看到他。<ul>
<li>9.I saw him in the library yesterday morning.</li>
</ul>
</li>
<li>10.我准备学习计算机科学。<ul>
<li>10.I am going to learn the computer science.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进行态：强调动作的过程"><a href="#进行态：强调动作的过程" class="headerlink" title="进行态：强调动作的过程"></a>进行态：强调动作的过程</h2><ul>
<li>延续性动词和瞬间动词<ul>
<li>在英语中，按照动作发生的时间长短，动词分成了延续性动词和瞬间动词</li>
<li>如结婚是一个瞬间动词，交换仪式之后，就是结婚了。所以不能说They were marrying last week. 只能说They married last week. 若要表达正在举行婚礼，可以说They are having a wedding ceremony</li>
</ul>
</li>
<li>现在进行时<ul>
<li>1.表示现在正在做的动作，此时be动词译为“正在”<ul>
<li>He <code>is playing</code> basketball. 他正在打篮球。</li>
<li><code>It&#39;s raining</code> heavily now. 现在正在下大雨。</li>
<li>注意：主系表句型在口语中通常用一般现在时，但如果要强调此时的状态，可以用现在进行时</li>
<li>You are very rude! ——&gt; You are <code>being</code> very rude! 你太粗鲁了！（你现在的行为粗鲁，而不是你这个人粗鲁）</li>
</ul>
</li>
<li>2.表示即将发生的动作（通常是表示“位移”短暂动词come, go, arrive, leave, start, begin, return, die, take），此时be动词译为“即将”<ul>
<li>“A new play <code>is coming</code> to’The Globe’ soon,” I said.“Will you be seeing it?” “一出新剧要来’环球剧场’上演了，”我说，“您去看吗?”</li>
<li>‘We <code>are going back</code> now,’ said the conductor. “我们现在要返回去，”售票员说。</li>
</ul>
</li>
</ul>
</li>
<li>过去进行时<ul>
<li>表示过去某时正在做的事情<ul>
<li>A man <code>was lying</code> in the box during the flight. 那个航班上，有一个人正躺在箱子里。</li>
<li>I <code>was having</code> dinner at a restaurant when Tony Steele came in. 我正在一家饭馆吃饭，托尼.斯蒂尔走了进来。</li>
</ul>
</li>
</ul>
</li>
<li>将来进行时<ul>
<li>表示将来某时将进行的动作<ul>
<li>They <code>will be arriving</code> here tomorrow. 他们明天就要到达此地。</li>
<li>Tomorrow evening they <code>will be singing</code> at the Workers’ Club. 明晚他们将在工人俱乐部演出。</li>
<li>The Greenwood Boys <code>will be staying</code> for five days. “绿林少年”准备在此逗留5天。</li>
<li>They <code>will be trying</code> to keep order. 他们将设法维持秩序。</li>
<li>The shuttle Endeavour <code>will be taking</code> the astronauts to the Hubble. “奋进”号航天飞机将把宇航员送上哈勃。</li>
</ul>
</li>
</ul>
</li>
<li>注意事项<ul>
<li>进行态，其实就是一般态的生动模式。任何一个进行态的句子，都可以改成一般态。一般态却不一定能改成进行态，比如动词是延续动词才能改。<ul>
<li>I <code>looked</code> out of the window. 可以改成 I <code>was looking</code> out of the window. (look是延续的)</li>
<li>I never get up early on Sundays. 不能改成 I was never getting up early on Sundays. 因为get up是短暂的。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.你在桌子下面做什么? <ul>
<li>1.What are you doing under the table?</li>
</ul>
</li>
<li>2.我正梦见你时，电话铃响了。(dream about)<ul>
<li>2.I was dreaming about you when the telephone rang.</li>
</ul>
</li>
<li>3.明天早上这个时候，我爸爸将正在修剪草坪。(mow the lawn)<ul>
<li>3.My dad will be mowing the lawn at this time tomorrow morning.</li>
</ul>
</li>
<li>4.我女儿正在学习，所以你最好别去烦她。<ul>
<li>4.My daughter is studying, so you’d better not bother her.</li>
</ul>
</li>
<li>5.明年这个时候我将正在美国念书。<ul>
<li>5.l’ll be studying in the United States at this time next year.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="完成态：强调动作的结果"><a href="#完成态：强调动作的结果" class="headerlink" title="完成态：强调动作的结果"></a>完成态：强调动作的结果</h2><ul>
<li>现在完成时<ul>
<li>1.表示到现在为止已经完成的动作（发生时间不明）<ul>
<li>I <code>have</code> just <code>received</code> a letter from my brother, Tim. 我刚刚收到弟弟蒂姆的来信。</li>
<li>He <code>has</code> just <code>bought</code> an Australian car and <code>has gone</code> to Alice Springs, a small town in the centre of Australia. 他刚买了一辆澳大利亚小汽车，现在去了澳大利亚中部的小镇艾利斯斯普林斯。</li>
<li>Since then, he <code>has developed</code> another bad habit. 从那以后，它养成了另外一种坏习惯。</li>
<li>He <code>has gone</code> to Shanghai. 他去了上海(言外之意:他不在说话现场)</li>
</ul>
</li>
<li>2.如果是延续性动词，表示持续到现在的动作（或状态）。（注意：be动词是可延续的）<ul>
<li>She <code>has lived</code> here for 10 years. 她住在这里10年了。</li>
<li>He <code>has been</code> there for six months. 他在那儿已经住了6个月了。</li>
<li>I <code>have been</code> to the Great Wall. 我去过长城。</li>
</ul>
</li>
</ul>
</li>
<li>现在完成时常用时间副词<ul>
<li>1.自从：since+时间点<ul>
<li>Since then, Captain Fawcett <code>has flown</code> passengers to many unusual places. 从那时开始，弗西特机长已经载送乘客到过许多不寻常的地方。</li>
</ul>
</li>
<li>2.有若干时间之久：for+时间段<ul>
<li>Mr. Hart <code>has trained</code> his daughter for years. 哈特先生训练她的女儿已经多年了。</li>
</ul>
</li>
<li>3.到目前为止：so far/up to now<ul>
<li>But so far, the public <code>has expressed</code> its gratitude to the students in letters to the Press. 但到目前为止，公众已经向新闻界写信表达他们对学生们的感激之情了。</li>
<li>Up to now, Mr. Scott <code>has sent</code> a great many requests for spare parts and other urgent messages from one garage to the other. 到目前为止，斯科特先生从一个汽车修理部向另一个发送了大量索取备件的信件和其他紧急函件。</li>
</ul>
</li>
<li>4.最近：recently/lately<ul>
<li><code>Have</code> you <code>talked</code> to Jane lately? 你最近有没有和Jane说过话?</li>
</ul>
</li>
<li>5.一次/两次/几次/多次：once/twice/a few times/many times<ul>
<li>Jack <code>has read</code> the novel three times. (这里的read是过去分词) 这本小说杰克已经看过三遍了。</li>
</ul>
</li>
<li>6.过去若干年/月/日以来：over/during/for + the last/past+数字+years/months/days<ul>
<li>Over the last three months, oil prices <code>have reached</code> a record high. 过去三个月以来，油价创了历史新高。</li>
</ul>
</li>
</ul>
</li>
<li>中国人最容易用错的3个短暂动词<ul>
<li>请翻译一下:<ul>
<li>1:他去北京3天了。</li>
<li>2:他结婚已经3年了。</li>
<li>3:他已经死了3年了</li>
</ul>
</li>
<li>答案：<ul>
<li>常见错误翻译</li>
<li>1: He has go to Beijing for 3 days. (X)</li>
<li>2: He has married for 3 years. (X)</li>
<li>3: He has died for 3 years. (X)</li>
<li>go, marry, die在英语中均为短暂动词，都是一瞬间完成的，后面不可以接时间副词，这里可以说:</li>
<li>1: He has gone to Beijing. </li>
<li>2: He has married. </li>
<li>3: He has died. </li>
<li>他不可能不停地做“去”这个动作3天，也不可能不停“结婚”这个动作3年，更不可能“死”3年才死透。要正确表达，必须使用对应的主系表句型，因为系动词是可以延续的，用主系表句型表示状态，才能加表示一段时间的状语。所以正确的说法是:</li>
<li>1: He has <code>been to Beijing</code> for 3 days.</li>
<li>2: He has <code>been married</code> for 3 years.</li>
<li>3: He has <code>been dead</code> for 3 years.</li>
<li>此时，句子的动词是be动词，后面的to Beijing (介词短语)，married, dead (形容词)为表语。</li>
</ul>
</li>
</ul>
</li>
<li>过去完成时<ul>
<li>表示截止过去某时为止所完成的动作或经验。（过去完成时不能单独存在，要与另一使用一般过去时的句子或者表示过去的副词短语连用）。(had译为“已经”或“曾经”)<ul>
<li>My old friend, Harrison, <code>had lived</code> in the Mediterranean for many years before he returned to England. 我的老朋友哈里森在回到英国以前曾多年居住在地中海地区。</li>
<li>A short time before, great trees <code>had covered</code> the countryside for miles around. 就在不久之前，参天大树还覆盖着方圆数英里的土地。</li>
<li>By then, however, in many places the grass <code>had</code> already <code>taken root</code>. 然而到那时，很多地方的草已经生了根。</li>
</ul>
</li>
</ul>
</li>
<li>将来完成时<ul>
<li>表示到将来某时为止所完成或仍然继续的动作或经验等。（常与介词by构成的时间状语连用，表示“到…的时候”）<ul>
<li>Workers <code>will have completed</code> the new roads by the end of this year. 工人们将在今年年底前把新路铺好。</li>
<li>By the end of next year, they <code>will have finished</code> work on the new stadium. 到明年年底，他们将把新体育场建成。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.彼得去过香港很多次。<ul>
<li>1.Peter has been to Hong Kong many times.</li>
</ul>
</li>
<li>2.进入初中以来，我对英语很狂热。(be crazy about)<ul>
<li>2.I have been crazy about English since I entered junior high school.</li>
</ul>
</li>
<li>3.到目前为止，我已经完成这项计划的三分之二。<ul>
<li>3.So far, I have finished two third of the project.</li>
</ul>
</li>
<li>4.我最近很忙，恐怕要到下周一我才有空。<ul>
<li>4.I have been very busy recently. l’m afraid that I won’t be free until next Monday.</li>
</ul>
</li>
<li>5.过去5年来，这个好孩子都尽力照顾他生病的母亲。<ul>
<li>5.Over the past 5 years, the good boy has tried his best to take care of his ill mother.</li>
</ul>
</li>
<li>6.史密斯先生搬来这里之前已经在加拿大住了20年。<ul>
<li>6.Mr. Smith had lived in Canada for 20 years before he moved here.</li>
</ul>
</li>
<li>7.等我到达车站时，火车已经开走了。<ul>
<li>7.By the time I got to the station, the train had left.</li>
</ul>
</li>
<li>8.玛丽昨天告诉我她很久以来一直想出国旅游。<ul>
<li>8.Mary told me yesterday that she had long wanted to travel abroad.</li>
</ul>
</li>
<li>9.我很生气，因为我女朋友又对我爽约了。(stand sb. up)<ul>
<li>9.I was very angry because my girlfriend had stood me up again.</li>
</ul>
</li>
<li>10.明天这个时候，约翰将已经达到芝加哥了。<ul>
<li>10.John will have arrived in Chicago by this time tomorrow.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="完成进行态：同时强调动作的结果和过程（延续性动词）"><a href="#完成进行态：同时强调动作的结果和过程（延续性动词）" class="headerlink" title="完成进行态：同时强调动作的结果和过程（延续性动词）"></a>完成进行态：同时强调动作的结果和过程（延续性动词）</h2><ul>
<li>延续性动词<ul>
<li>“我收到一封信”<ul>
<li>你只能说I have received a letter.</li>
<li>但是绝对不能说“I have been receiving a letter.”</li>
<li>因为receive收到这个动词， 是一瞬间完成的，不能延续，你不可能一直不停收同一 封信。</li>
</ul>
</li>
<li>“我住在广州3年了“<ul>
<li>你可以说I have lived in Guangzhou for three years.</li>
<li>也可以说I have been living in Guangzhou for three years.两句话意思完全相同。但是第二句更加生动形象。</li>
<li>瞬间动词是不能放在完成进行形态的。</li>
</ul>
</li>
</ul>
</li>
<li>现在完成进行时<ul>
<li>表示一直继续到现在，且可能继续下去的动作。（通常和表示时间段的副词连用，如for, since, all morning…）<ul>
<li>We have just moved into a new house and I <code>have been working</code> hard all morning. 我们刚刚搬进一所新房子，我辛辛苦苦地干了整整一个上午。</li>
<li>If you haven’t discovered your dream, probably <code>you&#39;ve been missing</code> too much. 如果你还没有发现梦想，或许一直以来你失去的太多了。</li>
</ul>
</li>
</ul>
</li>
<li>过去完成进行时<ul>
<li>表示一直继续到过去某时，而当时仍然在继续的动作。（过去完成进行时的句中必须有表示过去的时间状语）<ul>
<li>Firemen had been fighting the forest fire for nearly three weeks before they could get it under control. 消防队员们同那场森林大火搏斗了将近3个星期才最后把火势控制住。</li>
<li>The planes had been planting seed for nearly a month when it began to rain. 飞机撒播近一一个月后，开始下起雨来。</li>
<li>Bleriot had been making planes since 1905 and this was his latest model. 布莱里奥从1905年起便开始研制飞机，这架飞机是他制作的最新型号。</li>
</ul>
</li>
</ul>
</li>
<li>将来完成进行时<ul>
<li>一直继续到将来某时，且可能继续下去的动作<ul>
<li>The day before his retirement, Mr. Page will have been teaching for a total of forty years. 佩奇先生退休的前一天正好是他执教满40年的日子。</li>
<li>By the time you come back tonight, I will have been sleeping for five hours. 等你今晚回来时，我已经持续睡了5个小时了。</li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>任何完成进行态，都能改成完成态。但是完成态不一定能改成完成进行态，必须是延续动词，才能改</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.约翰自去年起就一直学日语。他希望去日本留学。<ul>
<li>1.John has been learning Japanese since last year. He expects to study in Japan in the future.</li>
</ul>
</li>
<li>2.Lulu的车子抛锚时，她已经持续开了8个小时了。<ul>
<li>2.By the time her car broke down, Lulu had been driving for 8 hours.</li>
</ul>
</li>
<li>3.到今年年底，王老师教英语将有10年了。<ul>
<li>3.Mr. Wang will have been teaching English for 10 years by the end of this year.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="过去将来时"><a href="#过去将来时" class="headerlink" title="过去将来时"></a>过去将来时</h2><ul>
<li>通常多用于叙述性故事中，或间接引语中<ul>
<li>A few hours earlier, someone had told the police that thieves <code>would try</code> to steal the diamonds. 数小时之前，有人向警方报告，说有人企图偷走这些钻石。(一般态)</li>
<li>Then he smiled and told me I <code>would receive</code> an extra thousand pounds a year! 然后他微笑了一下告诉我说，我每年将得到1000英镑的额外收入。(一般态)</li>
<li>He said that it <code>would be</code> possible to build a platform in the centre of the Channel. 他说，可以在隧道中央建造一座平台。(一般态)</li>
<li>She said she <code>would be setting off</code> on the 10 o’clock train. 她说她将乘10点钟的火车走。(进行态)</li>
<li>I guessed that Helen <code>would have told</code> her something. 我猜海伦会告诉她一些情况的。(完成态)</li>
<li>He told me that by the end of the year he <code>would have been living</code> there for thirty years. 他告诉我到今年末他已经住在那儿30年了。(完成进行态)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.在信中她说她明年将到英国来。<ul>
<li>1.In her letter, she said that she would come to England next year.</li>
</ul>
</li>
<li>2.他问我明天上午10点我将干什么。<ul>
<li>2.He asked me what I should be doing at 10 a.m. the next day</li>
</ul>
</li>
<li>3.他告诉我们他会在8点以前干完工作。<ul>
<li>3.He told us he would have finished the work by 8 o’clock.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-英文造句的被动语态"><a href="#3-英文造句的被动语态" class="headerlink" title="3.英文造句的被动语态"></a>3.英文造句的被动语态</h1><h2 id="及物动词和不及物动词"><a href="#及物动词和不及物动词" class="headerlink" title="及物动词和不及物动词"></a>及物动词和不及物动词</h2><ul>
<li>只有及物动词才有被动语态，不及物动词没有被动语态</li>
<li>及物动词后面可以加宾语<ul>
<li>主动语态: I eat meat.我吃肉</li>
<li>被动语态: the meat is eaten by me.</li>
</ul>
</li>
<li>不及物动词后面不可以加宾语，没有被动语态<ul>
<li>主动语态: I appear.我出现了</li>
</ul>
</li>
</ul>
<h2 id="主动语态变成被动语态的方式"><a href="#主动语态变成被动语态的方式" class="headerlink" title="主动语态变成被动语态的方式"></a>主动语态变成被动语态的方式</h2><ul>
<li>1.be动词（根据16中时态变化，与原句时态一致）+过去分词，原句的宾语作主句，而原句的主语，在被动语态中省略，或者前面加上介词by作状语</li>
<li>2.所谓被动语态，其实是一种特殊的主系表句型：过去分词作表语</li>
<li>举例<ul>
<li>I was beaten, 我被打了。(主语+be动词+动词的过去分词)</li>
<li>主动语态: Somebody beat me. 主谓宾结构</li>
<li>被动语态: I was beaten by somebody. 这里的by somebody可以省略。</li>
</ul>
</li>
</ul>
<h2 id="被动语态的时态变化"><a href="#被动语态的时态变化" class="headerlink" title="被动语态的时态变化"></a>被动语态的时态变化</h2><ul>
<li>一般态<ul>
<li>一般现在时<ul>
<li>Our clavichord is kept in the living-room.我们的这架古钢琴存放在起居室里。(这句话里边，可以认为clavichord是主语，is是系动词，kept是表语)</li>
</ul>
</li>
<li>一般过去时<ul>
<li>The instrument was bought by my grandfather many years ago.这件乐器是我祖父在很多年以前买的。(这句话里边，可以认为instrument是主语，was是系动词，bought是表语)</li>
</ul>
</li>
<li>一般将来时<ul>
<li>The Olympic Games will be held in our country in four years’ time. 4年以后，奥林匹克运动会将在我们国家举行。(这句话里边，可以认为Games是主语)</li>
</ul>
</li>
<li>被动语态句中出现情态动词时，用法同will<ul>
<li>The work must be finished in one way or another. 这件事必须设法做好。in one way or another是无论如何的意思</li>
<li>This passage may be given several interpretations.这段文字可以有不同的解释。</li>
</ul>
</li>
</ul>
</li>
<li>进行态: be动词+being+过去分词，be动词时态和原句保持一致<ul>
<li>现在进行时<ul>
<li>It is being repaired by a friend of my father’s.父亲的一个朋友正在修理它。(这句话里边，可以认为It是主语，is being是系动词，repaired是表语)</li>
<li>主动语态: A friend of my father’s is repairing it.</li>
<li>I am a doctor (常规状态).</li>
<li>I am being a doctor. (过去和未来不确定，仅表示现在)</li>
</ul>
</li>
<li>过去进行时<ul>
<li>I was being tested for a driving licence for the third time.(过去进行时)我第3次接受驾驶执照考试。(这句话里边，可以认为I是主语，was being是系动词，tested是表语)</li>
<li>主动语态: Somebody was testing me for a driving licence for the third time.</li>
</ul>
</li>
<li>将来进行时<ul>
<li>He will be being examined when we get there.当我们到那儿时他将正被检查。(这句话里边，可以认为He是主语，will be being是系动词，examined是表语)</li>
<li>主动语态: Somebody will be examming him when we get there</li>
</ul>
</li>
<li>完成态: have/has/had been +动词过去分词<ul>
<li>现在完成时<ul>
<li>The fantastic modern buildings have been designed by Kurt Gunter.这些巨大的现代化建筑是由库尔特.冈特设计的。(这句话里边，可以认为buildings是主语，have been是系动词，designed是表语)</li>
<li>主动语态: Kurt Gunter has designed the fantastic modern buildings</li>
</ul>
</li>
<li>过去完成时<ul>
<li>I had been asked to drive in heavy traffic and had done so successfully.按照要求在车辆拥挤的路上驾驶，我圆满地完成了。(这句话里边，可以认为I是主语，had been是系动词，asked是 表语)</li>
<li>主动语态: Somebody had asked me to drive in heavy traffic</li>
<li>Bluebird, the car he was driving, had been specially built for him.他驾驶的“蓝鸟”牌汽车是专门为他制造的。</li>
<li>主动语态: Somebody had specially built Bluebird, the car he was driving for him</li>
</ul>
</li>
<li>将来完成时<ul>
<li>Your character will have been completed by the time your life comes to an end.当生命走到尽头的时候，你的人格才变得完全。(这句话里边，可以认为character是主语， will have been是系动词，completed是表语)</li>
</ul>
</li>
</ul>
</li>
<li>完成进行态很少用于被动语句</li>
<li>造句练习<ul>
<li>1.欧元在大部分欧洲国家都被使用。<ul>
<li>1.The euro is used in most European countries.</li>
</ul>
</li>
<li>2.这些电脑是在台湾制造的。<ul>
<li>2.These computers were manufactured in Taiwan.</li>
</ul>
</li>
<li>3.2012年的奥运会将在伦敦举行。<ul>
<li>3.The 2012 Olympic Games will be held in London.</li>
</ul>
</li>
<li>4.一名应聘者正被我们的人事经理面试着<ul>
<li>4.An applicant is being interviewed by our personnel manager.</li>
</ul>
</li>
<li>5.那栋旧大楼已被拆除。(tear down)<ul>
<li>5.The old building has been torn down.</li>
</ul>
</li>
<li>6.我们办公室的房间都是每天打扫的。<ul>
<li>6.Our office rooms are cleaned up every day.</li>
</ul>
</li>
<li>7.汤姆昨天被一只狗咬到，所幸无大碍。<ul>
<li>7.Tom was bitten by a dog yesterday. Fortunately, it was nothing serious.</li>
</ul>
</li>
<li>8.因为经济不景气(the economic recession),大约5000名员工将被裁员(lay off)。<ul>
<li>8.Because of the economic recession, about 5,000 employees will be laid off.</li>
</ul>
</li>
<li>9.六个人被困在矿井里已有17个小时了。<ul>
<li>9.Six men have been trapped in a mine for seventeen hours.</li>
</ul>
</li>
<li>10.这场地震结束的时候有多少建筑被毁坏了?<ul>
<li>10.How many buildings had been destroyed when the earthquake ended?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用被动语态的情况"><a href="#使用被动语态的情况" class="headerlink" title="使用被动语态的情况"></a>使用被动语态的情况</h2><ul>
<li>1.为了突出受动者（主动语态中的宾语）<ul>
<li>A hero is distinguished in difficult circumstances.困境之中显英雄。</li>
<li>A liar is not believed when he tells the truth.撒谎的人讲真理也没人相信。</li>
</ul>
</li>
<li>2.施动者（主动语态的主语）不明确或不必指明时<ul>
<li>Then in 1989, twenty-six years after the crash, the plane was accidentally rediscovered in an aerial survey of the island. (没有提到到底是谁发现的) 于是，到了1989年，飞机失事26年后， 在对小岛的一次航空勘查中那架飞机被意外地发现了。</li>
<li>Once a year, a race is held for old cars.旧式汽车的比赛每年举行一次。(没有提到举办者是谁)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》学习笔记11-20章</title>
    <url>/mysql-crash-course-11-20/</url>
    <content><![CDATA[<h1 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h1><ul>
<li>Q:常用的文本处理函数<ul>
<li><img src="https://img.shiqi-lu.tech/20210209162820.png"></li>
</ul>
</li>
<li>Q:使用大写处理<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name, Upper(vend_name) AS vend_name_upcase</span><br><span class="line">    -&gt; FROM vendors</span><br><span class="line">    -&gt; ORDER BY vend_name;</span><br><span class="line">+<span class="comment">----------------+------------------+</span></span><br><span class="line">| vend_name      | vend_name_upcase |</span><br><span class="line">+<span class="comment">----------------+------------------+</span></span><br><span class="line">| ACME           | ACME             |</span><br><span class="line">| Anvils R Us    | ANVILS R US      |</span><br><span class="line">| Furball Inc.   | FURBALL INC.     |</span><br><span class="line">| Jet <span class="keyword">Set</span>        | JET <span class="keyword">SET</span>          |</span><br><span class="line">| Jouets Et Ours | JOUETS ET OURS   |</span><br><span class="line">| LT Supplies    | LT SUPPLIES      |</span><br><span class="line">+<span class="comment">----------------+------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:常用的时间日期处理函数<ul>
<li>注意日期格式必须为’yyyy-mm-dd’</li>
<li><img src="https://img.shiqi-lu.tech/20210209163055.png"></li>
</ul>
</li>
<li>Q:根据日期查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, order_num</span><br><span class="line">    -&gt; FROM orders</span><br><span class="line">    -&gt; WHERE Date(order_date) = &#x27;2005-09-01&#x27;;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:查询某个月的订单<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, order_num</span><br><span class="line">    -&gt; FROM orders</span><br><span class="line">    -&gt; WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:常用的数值处理函数<ul>
<li><img src="https://img.shiqi-lu.tech/20210209163709.png"></li>
</ul>
</li>
</ul>
<h1 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h1><ul>
<li>Q:SQL的5个聚集函数<ul>
<li><img src="https://img.shiqi-lu.tech/20210209163930.png"></li>
</ul>
</li>
<li>Q:取平均的使用<ul>
<li>会忽略NULL的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(prod_price) AS avg_price</span><br><span class="line">    -&gt; FROM products;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| avg_price |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 16.133571 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:COUNT()的使用<ul>
<li>1.使用COUNT(*)对表中行的数目进行计数，包括空值</li>
<li>2.使用COUNT(column)对特定列中具有值的行进行计算，忽略NULL值<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) AS num_cust</span><br><span class="line">    -&gt; FROM customers;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| num_cust |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        5 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(cust_email) <span class="keyword">AS</span> num_cust <span class="keyword">FROM</span> customers;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| num_cust |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        3 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:聚集不同值<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id = 1003;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| avg_price |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 15.998000 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h1><ul>
<li>Q:创建分组数据，根据某个字段统计数目<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; GROUP BY vend_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:过滤分组<ul>
<li>where在分组前过滤，having在分组后过滤<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">    -&gt; FROM orders</span><br><span class="line">    -&gt; GROUP BY cust_id</span><br><span class="line">    -&gt; HAVING COUNT(*) &gt;= 2;</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">| cust_id | orders |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">|   10001 |      2 |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:SELECT子句的顺序<ul>
<li><img src="https://img.shiqi-lu.tech/20210209171155.png"></li>
</ul>
</li>
</ul>
<h1 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h1><ul>
<li>Q:子查询的例子<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id</span><br><span class="line">    -&gt; FROM orders</span><br><span class="line">    -&gt; WHERE order_num IN (SELECT order_num</span><br><span class="line">    -&gt;                     FROM orderitems</span><br><span class="line">    -&gt;                     WHERE prod_id = &#x27;TNT2&#x27;);</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| cust_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|   10001 |</span><br><span class="line">|   10004 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_name,</span><br><span class="line">    -&gt;        cust_state,</span><br><span class="line">    -&gt;        (SELECT COUNT(*)</span><br><span class="line">    -&gt;         FROM orders</span><br><span class="line">    -&gt;         WHERE orders.cust_id = customers.cust_id) AS orders</span><br><span class="line">    -&gt; FROM customers</span><br><span class="line">    -&gt; ORDER BY cust_name;</span><br><span class="line">+<span class="comment">----------------+------------+--------+</span></span><br><span class="line">| cust_name      | cust_state | orders |</span><br><span class="line">+<span class="comment">----------------+------------+--------+</span></span><br><span class="line">| Coyote Inc.    | MI         |      2 |</span><br><span class="line">| E Fudd         | IL         |      1 |</span><br><span class="line">| Mouse House    | OH         |      0 |</span><br><span class="line">| Wascals        | IN         |      1 |</span><br><span class="line">| Yosemite Place | AZ         |      1 |</span><br><span class="line">+<span class="comment">----------------+------------+--------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h1><ul>
<li>Q:创建联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name, prod_name, prod_price</span><br><span class="line">    -&gt; FROM vendors, products</span><br><span class="line">    -&gt; WHERE vendors.vend_id = products.vend_id</span><br><span class="line">    -&gt; ORDER BY vend_name, prod_name;</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet <span class="keyword">Set</span>     | JetPack <span class="number">1000</span>   |      <span class="number">35.00</span> |</span><br><span class="line">| Jet <span class="keyword">Set</span>     | JetPack <span class="number">2000</span>   |      <span class="number">55.00</span> |</span><br><span class="line">| LT Supplies | Fuses          |       <span class="number">3.42</span> |</span><br><span class="line">| LT Supplies | Oil can        |       <span class="number">8.99</span> |</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:内部联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name, prod_name, prod_price</span><br><span class="line">    -&gt; FROM vendors INNER JOIN products</span><br><span class="line">    -&gt;      ON vendors.vend_id = products.vend_id;</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Jet <span class="keyword">Set</span>     | JetPack <span class="number">1000</span>   |      <span class="number">35.00</span> |</span><br><span class="line">| Jet <span class="keyword">Set</span>     | JetPack <span class="number">2000</span>   |      <span class="number">55.00</span> |</span><br><span class="line">+<span class="comment">-------------+----------------+------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h1><ul>
<li>Q:使用表别名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_name, cust_contact</span><br><span class="line">    -&gt; FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">    -&gt; WHERE c.cust_id = o.cust_id</span><br><span class="line">    -&gt;       AND oi.order_num = o.order_num</span><br><span class="line">    -&gt;       AND prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:自联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id = (SELECT vend_id</span><br><span class="line">    -&gt;                  FROM products</span><br><span class="line">    -&gt;                  WHERE prod_id = &#x27;DTNTR&#x27;);</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line">    -&gt;   <span class="keyword">AND</span> p2.prod_id = <span class="string">&#x27;DTNTR&#x27;</span>;</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:自然联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT c.*, o.order_num, o.order_num, o.order_date,</span><br><span class="line">    -&gt;        oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line">    -&gt; FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">    -&gt; WHERE c.cust_id = o.cust_id</span><br><span class="line">    -&gt;   AND oi.order_num = o.order_num</span><br><span class="line">    -&gt;   AND prod_id = &#x27;FB&#x27;;</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+-----------+-----------+---------------------+---------+----------+------------+</span></span><br><span class="line">| cust_id | cust_name   | cust_address   | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email      | order_num | order_num | order_date          | prod_id | quantity | item_price |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+-----------+-----------+---------------------+---------+----------+------------+</span></span><br><span class="line">|   10001 | Coyote Inc. | 200 Maple Lane | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com |     20005 |     20005 | 2005-09-01 00:00:00 | FB      |        1 |      10.00 |</span><br><span class="line">|   10001 | Coyote Inc. | 200 Maple Lane | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com |     20009 |     20009 | 2005-10-08 00:00:00 | FB      |        1 |      10.00 |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+-----------+-----------+---------------------+---------+----------+------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:外部联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT customers.cust_id, orders.order_num</span><br><span class="line">    -&gt; FROM customers LEFT OUTER JOIN orders</span><br><span class="line">    -&gt;   ON customers.cust_id = orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10002 |      NULL |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line">    -&gt;   <span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>对比自然联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT customers.cust_id, orders.order_num</span><br><span class="line">    -&gt; FROM customers INNER JOIN orders</span><br><span class="line">    -&gt;   ON customers.cust_id = orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:使用带聚集函数的联结<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT customers.cust_name,</span><br><span class="line">    -&gt;        customers.cust_id,</span><br><span class="line">    -&gt;        COUNT(orders.order_num) AS num_ord</span><br><span class="line">    -&gt; FROM customers INNER JOIN orders</span><br><span class="line">    -&gt;   ON customers.cust_id = orders.cust_id</span><br><span class="line">    -&gt; GROUP BY customers.cust_id;</span><br><span class="line">+<span class="comment">----------------+---------+---------+</span></span><br><span class="line">| cust_name      | cust_id | num_ord |</span><br><span class="line">+<span class="comment">----------------+---------+---------+</span></span><br><span class="line">| Coyote Inc.    |   10001 |       2 |</span><br><span class="line">| Wascals        |   10003 |       1 |</span><br><span class="line">| Yosemite Place |   10004 |       1 |</span><br><span class="line">| E Fudd         |   10005 |       1 |</span><br><span class="line">+<span class="comment">----------------+---------+---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h1><ul>
<li>Q:使用UNION和对应的WHERE<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price &lt;= 5</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; SELECT vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id IN (1001,1002);</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> products</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:UNION规则<ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关 键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个 UNION关键字）</li>
<li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以 隐含地转换的类型（例如，不同的数值类型或不同的日期类型）</li>
</ul>
</li>
<li>Q:UNION包含或取消重复行<ul>
<li>默认的UNION会从结果集中自动去除重复的行，若要返回所有匹配行，使用UNION ALL</li>
</ul>
</li>
<li>Q:对组合查询结果排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE prod_price &lt;= 5</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; SELECT vend_id, prod_id, prod_price</span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt; WHERE vend_id IN (1001,1002)</span><br><span class="line">    -&gt; ORDER BY vend_id, prod_price;</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h1><ul>
<li>Q:MySQL支持全文本搜索的引擎<ul>
<li>MyISAM支持全文本搜索，InnoDB不支持</li>
</ul>
</li>
<li>Q:通配操作符和正则表达式匹配的3个限制<ul>
<li>性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时</li>
<li>明确控制：使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配</li>
<li>智能化的结果：虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好的匹配 来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行</li>
</ul>
</li>
<li>Q:使用全文本搜索的优势<ul>
<li>MySQL不需要分别查看每个行，不需要分别分析和处理每个词</li>
<li>MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行</li>
<li>MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率</li>
</ul>
</li>
<li>Q:创建表时启用全文本搜索支持<ul>
<li>为了进行全文本搜索，必须索引被搜索的列。在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">  note_id <span class="built_in">int</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  prod_id <span class="built_in">char</span>(<span class="number">10</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_text <span class="built_in">text</span>     <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(note_id),</span><br><span class="line">  FULLTEXT(note_text)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:进行全文本搜索<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;rabbit&#x27;);</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                          |</span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>Match()指定被搜索的列，Against()指定要使用的搜索表达式，传递给 Match() 的值必须与FULLTEXT()定义中的相同</li>
<li>也可用Like子句完成<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE note_text LIKE &#x27;%rabbit%&#x27;;</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">| Customer complaint: rabbit has been able <span class="keyword">to</span> detect trap, food apparently <span class="keyword">less</span> effective now.                          |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>全文本搜索返回以文本匹配的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为 第3个词的行的等级比作为第20个词的行高</li>
<li>LIKE以不特别有用的顺序返回数据</li>
</ul>
</li>
<li>Q:全文本搜索排序的工作方式<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text,</span><br><span class="line">    -&gt;        Match(note_text) Against(&#x27;rabbit&#x27;) AS rank</span><br><span class="line">    -&gt; FROM productnotes;</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span></span><br><span class="line">| note_text                                                                                                                                                  | rank               |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span></span><br><span class="line">| Customer complaint:</span><br><span class="line">Sticks not individually wrapped, too easy to mistakenly detonate all at once.</span><br><span class="line">Recommend individual wrapping.                         |                  0 |</span><br><span class="line">| Can shipped full, refills not available.</span><br><span class="line">Need to order new can if refill needed.                                                                          |                  0 |</span><br><span class="line">| Safe is combination locked, combination not provided <span class="keyword">with</span> safe.</span><br><span class="line">This <span class="keyword">is</span> rarely a problem <span class="keyword">as</span> safes <span class="keyword">are</span> typically blown up <span class="keyword">or</span> dropped <span class="keyword">by</span> customers.         |                  <span class="number">0</span> |</span><br><span class="line">| Quantity varies, sold <span class="keyword">by</span> the sack load.</span><br><span class="line"><span class="keyword">All</span> guaranteed <span class="keyword">to</span> be bright <span class="keyword">and</span> orange, <span class="keyword">and</span> suitable <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait.                                      | <span class="number">1.5905543565750122</span> |</span><br><span class="line">| Included fuses <span class="keyword">are</span> <span class="keyword">short</span> <span class="keyword">and</span> have been known <span class="keyword">to</span> detonate too quickly <span class="keyword">for</span> <span class="keyword">some</span> customers.</span><br><span class="line">Longer fuses <span class="keyword">are</span> available (item FU1) <span class="keyword">and</span> should be recommended. |                  <span class="number">0</span> |</span><br><span class="line">| Matches <span class="keyword">not</span> included, recommend purchase <span class="keyword">of</span> matches <span class="keyword">or</span> detonator (item DTNTR).                                                                             |                  <span class="number">0</span> |</span><br><span class="line">| Please note that <span class="keyword">no</span> <span class="keyword">returns</span> will be accepted <span class="keyword">if</span> <span class="keyword">safe</span> opened <span class="keyword">using</span> explosives.                                                                              |                  <span class="number">0</span> |</span><br><span class="line">| Multiple customer <span class="keyword">returns</span>, anvils failing <span class="keyword">to</span> <span class="keyword">drop</span> <span class="keyword">fast</span> enough <span class="keyword">or</span> falling backwards <span class="keyword">on</span> purchaser. Recommend that customer considers <span class="keyword">using</span> heavier anvils.   |                  <span class="number">0</span> |</span><br><span class="line">| Item <span class="keyword">is</span> extremely heavy. Designed <span class="keyword">for</span> dropping, <span class="keyword">not</span> recommended <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">with</span> slings, ropes, pulleys, <span class="keyword">or</span> tightropes.                                        |                  <span class="number">0</span> |</span><br><span class="line">| Customer complaint: rabbit has been able <span class="keyword">to</span> detect trap, food apparently <span class="keyword">less</span> effective now.                                                               | <span class="number">1.6408053636550903</span> |</span><br><span class="line">| Shipped unassembled, requires common tools (<span class="keyword">including</span> oversized hammer).                                                                                   |                  <span class="number">0</span> |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Circular hole <span class="keyword">in</span> <span class="keyword">safe</span> <span class="keyword">floor</span> can apparently be easily cut <span class="keyword">with</span> handsaw.                                                                |                  <span class="number">0</span> |</span><br><span class="line">| Customer complaint:</span><br><span class="line"><span class="keyword">Not</span> heavy enough <span class="keyword">to</span> generate flying stars around <span class="keyword">head</span> <span class="keyword">of</span> victim. <span class="keyword">If</span> being purchased <span class="keyword">for</span> dropping, recommend ANV02 <span class="keyword">or</span> ANV03 instead.   |                  <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">Call</span> <span class="keyword">from</span> individual trapped <span class="keyword">in</span> <span class="keyword">safe</span> plummeting <span class="keyword">to</span> the ground, suggests an escape hatch be added.</span><br><span class="line"><span class="keyword">Comment</span> forwarded <span class="keyword">to</span> vendor.                            |                  <span class="number">0</span> |</span><br><span class="line">+<span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>Match()和Against() 用来建立一个计算列（别名为rank），此列包含全文本搜索计算出的等级值。等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的 总数以及包含该词的行的数目计算出来。正如所见，不包含词rabbit的行等级为0（因此不被前一例子中的WHERE子句选择）。确实包含词rabbit 的两个行每行都有一个等级值，文本中词靠前的行的等级值比词靠后的行的等级值高</li>
</ul>
</li>
<li>Q:使用查询扩展时MySQL工作方式<ul>
<li>对数据和索引进行两遍扫描来完成搜索<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词</li>
</ul>
</li>
<li>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词</li>
</ul>
</li>
<li>Q:查询扩展的例子<ul>
<li>没有使用<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;anvils&#x27;);</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Multiple customer returns, anvils failing to <span class="keyword">drop</span> <span class="keyword">fast</span> enough <span class="keyword">or</span> falling backwards <span class="keyword">on</span> purchaser. Recommend that customer considers <span class="keyword">using</span> heavier anvils. |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>使用了之后<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Multiple customer returns, anvils failing to <span class="keyword">drop</span> <span class="keyword">fast</span> enough <span class="keyword">or</span> falling backwards <span class="keyword">on</span> purchaser. Recommend that customer considers <span class="keyword">using</span> heavier anvils. |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Sticks <span class="keyword">not</span> individually <span class="keyword">wrapped</span>, too easy <span class="keyword">to</span> mistakenly detonate <span class="keyword">all</span> <span class="keyword">at</span> once.</span><br><span class="line">Recommend individual wrapping.                       |</span><br><span class="line">| Customer complaint:</span><br><span class="line"><span class="keyword">Not</span> heavy enough <span class="keyword">to</span> generate flying stars around <span class="keyword">head</span> <span class="keyword">of</span> victim. <span class="keyword">If</span> being purchased <span class="keyword">for</span> dropping, recommend ANV02 <span class="keyword">or</span> ANV03 instead. |</span><br><span class="line">| Please note that <span class="keyword">no</span> <span class="keyword">returns</span> will be accepted <span class="keyword">if</span> <span class="keyword">safe</span> opened <span class="keyword">using</span> explosives.                                                                            |</span><br><span class="line">| Customer complaint: rabbit has been able <span class="keyword">to</span> detect trap, food apparently <span class="keyword">less</span> effective now.                                                             |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Circular hole <span class="keyword">in</span> <span class="keyword">safe</span> <span class="keyword">floor</span> can apparently be easily cut <span class="keyword">with</span> handsaw.                                                              |</span><br><span class="line">| Matches <span class="keyword">not</span> included, recommend purchase <span class="keyword">of</span> matches <span class="keyword">or</span> detonator (item DTNTR).                                                                           |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）</li>
</ul>
</li>
<li>Q:布尔文本搜索可提供的功能<ul>
<li>以布尔方式，提供关于如下内容的细节：</li>
<li>要匹配的词</li>
<li>要排斥的词(如果某行包含这个词，则不返回该行，即使它包含 其他指定的词也是如此)</li>
<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）</li>
<li>表达式分组</li>
</ul>
</li>
<li>Q:布尔文本搜索举例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;heavy&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Item is extremely heavy. Designed for dropping, not recommended for <span class="keyword">use</span> <span class="keyword">with</span> slings, ropes, pulleys, <span class="keyword">or</span> tightropes.                                      |</span><br><span class="line">| Customer complaint:</span><br><span class="line"><span class="keyword">Not</span> heavy enough <span class="keyword">to</span> generate flying stars around <span class="keyword">head</span> <span class="keyword">of</span> victim. <span class="keyword">If</span> being purchased <span class="keyword">for</span> dropping, recommend ANV02 <span class="keyword">or</span> ANV03 instead. |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配包含heavy但不包含任意以rope开始的词的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:全文本布尔操作符<ul>
<li><img src="https://img.shiqi-lu.tech/20210219143512.png"></li>
</ul>
</li>
<li>Q:匹配包含词rabbit和bait的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;+rabbit +bait&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配包含rabbit和bait中的至少一个词的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;rabbit bait&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">| Customer complaint: rabbit has been able <span class="keyword">to</span> detect trap, food apparently <span class="keyword">less</span> effective now.                          |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配短语 rabbit bait 而不是匹配两个词 rabbit 和 bait<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;&quot;rabbit bait&quot;&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:匹配rabbit和carrot，增加前者的等级，降低后者的等级<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;&gt;rabbit &lt;bait&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                             |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for <span class="keyword">use</span> <span class="keyword">as</span> rabbit bait. |</span><br><span class="line">| Customer complaint: rabbit has been able <span class="keyword">to</span> detect trap, food apparently <span class="keyword">less</span> effective now.                          |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:搜索匹配词safe和combination，降低后者的等级<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT note_text</span><br><span class="line">    -&gt; FROM productnotes</span><br><span class="line">    -&gt; WHERE Match(note_text) Against(&#x27;+safe +(&lt;combination)&#x27; IN BOOLEAN MODE);</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| note_text                                                                                                                                          |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Safe is combination locked, combination not provided <span class="keyword">with</span> safe.</span><br><span class="line">This <span class="keyword">is</span> rarely a problem <span class="keyword">as</span> safes <span class="keyword">are</span> typically blown up <span class="keyword">or</span> dropped <span class="keyword">by</span> customers. |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:全文本搜索的使用说明<ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有具有3个或3个以下字符的词（如果需要，这个数目可以更改）</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参 阅MySQL文档）</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果</li>
<li>忽略词中的单引号。例如，don’t索引为dont</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果</li>
<li>仅在MyISAM数据库引擎中支持全文本搜索</li>
</ul>
</li>
</ul>
<h1 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h1><ul>
<li>Q:插入数据<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO customers</span><br><span class="line">    -&gt; VALUES(NULL,</span><br><span class="line">    -&gt;   &#x27;Pep E. LaPew&#x27;,</span><br><span class="line">    -&gt;   &#x27;100 Main Street&#x27;,</span><br><span class="line">    -&gt;   &#x27;Los Angeles&#x27;,</span><br><span class="line">    -&gt;   &#x27;CA&#x27;,</span><br><span class="line">    -&gt;   &#x27;90046&#x27;,</span><br><span class="line">    -&gt;   &#x27;USA&#x27;,</span><br><span class="line">    -&gt;   NULL,</span><br><span class="line">    -&gt;   NULL);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO customers(cust_name,</span><br><span class="line">    -&gt;    cust_address,</span><br><span class="line">    -&gt;    cust_city,</span><br><span class="line">    -&gt;    cust_state,</span><br><span class="line">    -&gt;    cust_zip,</span><br><span class="line">    -&gt;    cust_country,</span><br><span class="line">    -&gt;    cust_contact,</span><br><span class="line">    -&gt;    cust_email)</span><br><span class="line">    -&gt; VALUES(&#x27;Pep E.LaPew&#x27;,</span><br><span class="line">    -&gt;   &#x27;100 Main Street&#x27;,</span><br><span class="line">    -&gt;   &#x27;Los Angeles&#x27;,</span><br><span class="line">    -&gt;   &#x27;CA&#x27;,</span><br><span class="line">    -&gt;   &#x27;90046&#x27;,</span><br><span class="line">    -&gt;   &#x27;USA&#x27;,</span><br><span class="line">    -&gt;   NULL,</span><br><span class="line">    -&gt;   NULL);</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:插入多行数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO customers(cust_name,</span><br><span class="line">    -&gt;    cust_address,</span><br><span class="line">    -&gt;    cust_city,</span><br><span class="line">    -&gt;    cust_state,</span><br><span class="line">    -&gt;    cust_zip,</span><br><span class="line">    -&gt;    cust_country)</span><br><span class="line">    -&gt; VALUES(</span><br><span class="line">    -&gt;        &#x27;Pep E.LaPew&#x27;,</span><br><span class="line">    -&gt;        &#x27;100 Main Street&#x27;,</span><br><span class="line">    -&gt;        &#x27;Los Angeles&#x27;,</span><br><span class="line">    -&gt;        &#x27;CA&#x27;,</span><br><span class="line">    -&gt;        &#x27;90046&#x27;,</span><br><span class="line">    -&gt;        &#x27;USA&#x27;</span><br><span class="line">    -&gt;       ),</span><br><span class="line">    -&gt;       (</span><br><span class="line">    -&gt;        &#x27;M. Martian&#x27;,</span><br><span class="line">    -&gt;        &#x27;42 Galaxy Way&#x27;,</span><br><span class="line">    -&gt;        &#x27;New York&#x27;,</span><br><span class="line">    -&gt;        &#x27;NY&#x27;,</span><br><span class="line">    -&gt;        &#x27;112113&#x27;,</span><br><span class="line">    -&gt;        &#x27;USA&#x27;</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 2 rows affected (0.04 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li>Q:插入检索出的数据<ul>
<li>从custnew中将所有数据导入customers，注意此处的cust_id也被复制过来了，可以省略这列就能确保cust_id不重复<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_id,</span><br><span class="line">   cust_contact,</span><br><span class="line">   cust_email,</span><br><span class="line">   cust_name,</span><br><span class="line">   cust_address,</span><br><span class="line">   cust_city,</span><br><span class="line">   cust_state,</span><br><span class="line">   cust_zip,</span><br><span class="line">   cust_country)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,</span><br><span class="line">   cust_contact,</span><br><span class="line">   cust_email,</span><br><span class="line">   cust_name,</span><br><span class="line">   cust_address,</span><br><span class="line">   cust_city,</span><br><span class="line">   cust_state,</span><br><span class="line">   cust_zip,</span><br><span class="line">   cust_country</span><br><span class="line"><span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h1><ul>
<li>Q:更新数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE customers</span><br><span class="line">    -&gt; SET cust_name = &#x27;The Fudds&#x27;,</span><br><span class="line">    -&gt;     cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">    -&gt; WHERE cust_id = 10008;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li>Q:删除数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM customers</span><br><span class="line">    -&gt; WHERE cust_id = 10007;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:删除表中所有行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》学习笔记21-30章</title>
    <url>/mysql-crash-course-21-30/</url>
    <content><![CDATA[<h1 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h1><ul>
<li>Q:创建customers表示例，NULL、自增、主键、默认值写法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">  cust_id      <span class="built_in">int</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  cust_name    <span class="built_in">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  cust_address <span class="built_in">char</span>(<span class="number">50</span>)  <span class="literal">NULL</span>,</span><br><span class="line">  cust_city    <span class="built_in">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;bj&#x27;</span>,</span><br><span class="line">  cust_state   <span class="built_in">char</span>(<span class="number">5</span>)   <span class="literal">NULL</span>,</span><br><span class="line">  cust_email   <span class="built_in">char</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NULL：允许NULL值的列允许在插入行时不给出该列的值，NOT NULL则在插入或更新行时该列必须有值</li>
<li>注意NULL值和空串’’，空串是一个有效值，不是NULL</li>
<li>主键：表的每个行必须具有唯一的主键值，如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。主键中只能使用不允许NULL值的列</li>
<li>AUTO_INCREMENT：本列每当增加一行时，自动增量。多个语句连续使用时，可用last_insert_id()获取最后一个AUTO_INCREMENT值，<code>SELECT last_insert_id()</code></li>
<li>默认值：在未给出值时使用该值</li>
<li>引擎类型：<ul>
<li>InnoDB：可靠的事务处理引擎，不支持全文本搜索</li>
<li>MEMORY：功能等同于MyISAM，但数据存储在内存，数据很快，适合临时表</li>
<li>MyISAM：性能极高的引擎，支持全文本搜索，但不支持事务处理</li>
</ul>
</li>
</ul>
</li>
<li>Q:修改表结构，给表添加一个列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li>Q:修改表结构，删除表中的列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> VEND_phone;</span><br></pre></td></tr></table></figure></li>
<li>Q:修改表结构，定义外键<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br></pre></td></tr></table></figure></li>
<li>Q:复杂表结构的更改步骤<ul>
<li>用新的列布局创建一个新表</li>
<li>使用INSERT SELECT语句从旧表复制数据到新表。必要时适用转换函数和计算字段</li>
<li>校验包含所需数据的新表</li>
<li>重命名旧表(如果确定，可以删除它)</li>
<li>用旧表原来的名字重命名新表</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键</li>
<li>注意：使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份(模式和数据的备份)。数据库表的更改不能撤销</li>
</ul>
</li>
<li>Q:删除表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure></li>
<li>Q:重命名多个表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> backup_customers <span class="keyword">TO</span> customers,</span><br><span class="line">             backup_vendors <span class="keyword">TO</span> vendors;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h1><ul>
<li>Q:视图有哪些应用呢<ul>
<li>1.重用SQL语句</li>
<li>2.简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节</li>
<li>3.使用表的组成部分而不是整个表</li>
<li>4.保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</li>
<li>5.更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据</li>
</ul>
</li>
<li>Q:视图的可用操作<ul>
<li>可用与表基本相同的方式利用它们。可对视图执行SELECT操作，过滤和排序数据，将视图联结到其它视图或表，甚至能添加和更新数据(存在一些限制)</li>
<li>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。 视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。 在添加或更改这些表中的数据时，视图将返回改变过的数据</li>
<li>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试</li>
</ul>
</li>
<li>Q:创图创建和使用有哪些常见的规则和限制？<ul>
<li>与表一样，视图必须唯一命名(不能给视图取与别的视图或表相同的名字)</li>
<li>对于可以创建的视图数目没有限制</li>
<li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予</li>
<li>视图可以嵌套，即可利用从其它视图中检索数据的查询来构造一个视图</li>
<li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</li>
<li>视图不能索引， 也不能有关联的触发器或默认值</li>
<li>视图可以和表一起使用。如编写一条联结表和视图的SELECT语句</li>
</ul>
</li>
<li>Q:如何使用视图<ul>
<li>创建：<code>CREATE VIEW</code></li>
<li>查看创建视图的语句：<code>SHOW CREATE VIEW viewname;</code></li>
<li>删除：<code>DROP VIEW viewname;</code></li>
<li>更新：可先用DROP再用CREATE，或<code>CREATE OR REPLACE VIEW</code>。</li>
<li>如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在， 则第2条更新语句会替换原有视图</li>
</ul>
</li>
<li>Q:创建一个名为productcustomers的视图，联结三个表，以返回已订购了任意产品的所有客户的列表<ul>
<li>如果执行<code>SELECT * FROM productcustomers</code>，列出订购了任意产品的所有客户的列表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE VIEW productcustomers AS</span><br><span class="line">    -&gt; SELECT cust_name, cust_contact, prod_id</span><br><span class="line">    -&gt; FROM customers, orders, orderitems</span><br><span class="line">    -&gt; WHERE customers.cust_id = orders.cust_id</span><br><span class="line">    -&gt;   AND orderitems.order_num = orders.order_num;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from productcustomers;</span><br><span class="line">+<span class="comment">----------------+--------------+---------+</span></span><br><span class="line">| cust_name      | cust_contact | prod_id |</span><br><span class="line">+<span class="comment">----------------+--------------+---------+</span></span><br><span class="line">| Coyote Inc.    | Y Lee        | ANV01   |</span><br><span class="line">| Coyote Inc.    | Y Lee        | ANV02   |</span><br><span class="line">| Coyote Inc.    | Y Lee        | TNT2    |</span><br><span class="line">| Coyote Inc.    | Y Lee        | FB      |</span><br><span class="line">| Coyote Inc.    | Y Lee        | FB      |</span><br><span class="line">| Coyote Inc.    | Y Lee        | OL1     |</span><br><span class="line">| Coyote Inc.    | Y Lee        | SLING   |</span><br><span class="line">| Coyote Inc.    | Y Lee        | ANV03   |</span><br><span class="line">| Wascals        | Jim Jones    | JP2000  |</span><br><span class="line">| Yosemite Place | Y Sam        | TNT2    |</span><br><span class="line">| E Fudd         | E Fudd       | FC      |</span><br><span class="line">+<span class="comment">----------------+--------------+---------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>检索订购了产品TN2的客户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_name, cust_contact</span><br><span class="line">    -&gt; FROM productcustomers</span><br><span class="line">    -&gt; WHERE prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:如何使用重新格式化检索出的数据<ul>
<li>经常需要某个格式的结果。不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;)</span><br><span class="line">    -&gt;        AS vend_title</span><br><span class="line">    -&gt; FROM vendors</span><br><span class="line">    -&gt; ORDER BY vend_name;</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| vend_title              |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| ACME (USA)              |</span><br><span class="line">| Anvils R Us (USA)       |</span><br><span class="line">| Furball Inc. (USA)      |</span><br><span class="line">| Jet <span class="keyword">Set</span> (England)       |</span><br><span class="line">| Jouets Et Ours (France) |</span><br><span class="line">| LT Supplies (USA)       |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocations <span class="keyword">AS</span></span><br><span class="line">    -&gt; <span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">&#x27; (&#x27;</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    -&gt;        <span class="keyword">AS</span> vend_title</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> vendors</span><br><span class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM vendorlocations;</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| vend_title              |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| ACME (USA)              |</span><br><span class="line">| Anvils R Us (USA)       |</span><br><span class="line">| Furball Inc. (USA)      |</span><br><span class="line">| Jet <span class="keyword">Set</span> (England)       |</span><br><span class="line">| Jouets Et Ours (France) |</span><br><span class="line">| LT Supplies (USA)       |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:用视图过滤不想要的数据，如定义 customeremaillist视图，它过滤没有电子邮件地址的客户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE VIEW customeremaillist AS</span><br><span class="line">    -&gt; SELECT cust_id, cust_name, cust_email</span><br><span class="line">    -&gt; FROM customers</span><br><span class="line">    -&gt; WHERE cust_email IS NOT NULL;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM customeremaillist;</span><br><span class="line">+<span class="comment">---------+----------------+---------------------+</span></span><br><span class="line">| cust_id | cust_name      | cust_email          |</span><br><span class="line">+<span class="comment">---------+----------------+---------------------+</span></span><br><span class="line">|   10001 | Coyote Inc.    | ylee@coyote.com     |</span><br><span class="line">|   10003 | Wascals        | rabbit@wascally.com |</span><br><span class="line">|   10004 | Yosemite Place | sam@yosemite.com    |</span><br><span class="line">|   10008 | The Fudds      | elmer@fudd.com      |</span><br><span class="line">+<span class="comment">---------+----------------+---------------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:如何使用视图简化计算字段<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id,</span><br><span class="line">    -&gt;        quantity,</span><br><span class="line">    -&gt;        item_price,</span><br><span class="line">    -&gt;        quantity*item_price AS expanded_price</span><br><span class="line">    -&gt; FROM orderitems</span><br><span class="line">    -&gt; WHERE order_num = 20005;</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemexpanded <span class="keyword">AS</span></span><br><span class="line">    -&gt; <span class="keyword">SELECT</span> order_num,</span><br><span class="line">    -&gt;        prod_id,</span><br><span class="line">    -&gt;        quantity,</span><br><span class="line">    -&gt;        item_price,</span><br><span class="line">    -&gt;        quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> orderitems;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM orderitemexpanded</span><br><span class="line">    -&gt; WHERE order_num = 20005;</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">| order_num | prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">|     20005 | ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">|     20005 | ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">|     20005 | TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">|     20005 | FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:什么情况下，MySQL不允许更新、插入和删除视图<ul>
<li>1.分组(使用GROUP BY和HAVING)</li>
<li>2.联结</li>
<li>3.子查询</li>
<li>4.并</li>
<li>5.聚集函数(Min()、Count()、Sum()等)</li>
<li>6.DISTINCT</li>
<li>7.导出(计算)列</li>
</ul>
</li>
</ul>
<h1 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h1><ul>
<li>Q:创建存储过程，返回产品平均价格<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">   <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在命令行中书写时要重新定义分隔符，注意使用完要恢复<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE productpricing()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;    SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">    -&gt;    FROM products;</span><br><span class="line">    -&gt; END //</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL productpricing();</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| priceaverage |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|    16.133571 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:删除存储过程<ul>
<li>如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP PROCEDURE productpricing;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DROP PROCEDURE IF EXISTS proceductpricing;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:创建使用参数的存储过程<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE productpricing(</span><br><span class="line">    -&gt;    OUT pl DECIMAL(8,2),</span><br><span class="line">    -&gt;    OUT ph DECIMAL(8,2),</span><br><span class="line">    -&gt;    OUT pa DECIMAL(8,2)</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;    SELECT Min(prod_price)</span><br><span class="line">    -&gt;    INTO pl</span><br><span class="line">    -&gt;    FROM products;</span><br><span class="line">    -&gt;    SELECT Max(prod_price)</span><br><span class="line">    -&gt;    INTO ph</span><br><span class="line">    -&gt;    FROM products;</span><br><span class="line">    -&gt;    SELECT Avg(prod_price)</span><br><span class="line">    -&gt;    INTO pa</span><br><span class="line">    -&gt;    FROM products;</span><br><span class="line">    -&gt; END //</span><br><span class="line">    </span><br><span class="line">mysql&gt; CALL productpricing(@pricelow,</span><br><span class="line">    -&gt;                     @pricehigh,</span><br><span class="line">    -&gt;                     @priceaverage) //</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @priceaverage //</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| @priceaverage |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">|         16.13 |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值(返回给调用者)。</li>
<li>MySQL支持IN(传递给存储过程)、OUT(从存储过程传出)和INOUT(对存储过程传入和传出)类型的参数</li>
<li>存储过程是一系列SELECT语句，用来检索值，然后保存到相应的变量(通过指定INTO关键字)</li>
<li>存储过程的参数允许的数据类型与表中使用的数据类型相同</li>
</ul>
</li>
<li>Q:使用IN和OUT参数的存储过程，ordertotal接受订单号并返回该订单的合计<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE ordertotal(</span><br><span class="line">    -&gt;    IN onumber INT,</span><br><span class="line">    -&gt;    OUT ototal DECIMAL(8,2)</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;    SELECT Sum(item_price*quantity)</span><br><span class="line">    -&gt;    FROM orderitems</span><br><span class="line">    -&gt;    WHERE order_num = onumber</span><br><span class="line">    -&gt;    INTO ototal;</span><br><span class="line">    -&gt; END//</span><br><span class="line">    </span><br><span class="line">mysql&gt; CALL ordertotal(20005, @total)//</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @total //</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| @total |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 149.87 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:显示用来创建一个存储过程的CREATE语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE PROCEDURE ordertotal //</span><br><span class="line">+<span class="comment">------------+-------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| Procedure  | sql_mode                                                                                                                                  | <span class="keyword">Create</span> <span class="keyword">Procedure</span>                                                                                                                                                                                                       | character_set_client | collation_connection | <span class="keyword">Database</span> <span class="keyword">Collation</span> |</span><br><span class="line">+<span class="comment">------------+-------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| ordertotal | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | <span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="string">`ordertotal`</span>(    <span class="keyword">IN</span> onumber <span class="built_in">INT</span>,    <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>) )</span><br><span class="line"><span class="keyword">BEGIN</span>    <span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity)    <span class="keyword">FROM</span> orderitems    <span class="keyword">WHERE</span> order_num = onumber    <span class="keyword">INTO</span> ototal; <span class="keyword">END</span> | utf8                 | utf8_general_ci      | latin1_swedish_ci  |</span><br><span class="line">+<span class="comment">------------+-------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:获得包括何时、由谁创建等详细信息的存储过程列表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span></span><br></pre></td></tr></table></figure>
<ul>
<li>限制过程状态结果<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27; //</span><br><span class="line">+<span class="comment">-------------+------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| Db          | Name       | Type      | Definer        | Modified            | Created             | Security_type | <span class="keyword">Comment</span> | character_set_client | collation_connection | <span class="keyword">Database</span> <span class="keyword">Collation</span> |</span><br><span class="line">+<span class="comment">-------------+------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| crashcourse | ordertotal | <span class="keyword">PROCEDURE</span> | root@localhost | <span class="number">2021</span><span class="number">-03</span><span class="number">-25</span> <span class="number">13</span>:<span class="number">12</span>:<span class="number">18</span> | <span class="number">2021</span><span class="number">-03</span><span class="number">-25</span> <span class="number">13</span>:<span class="number">12</span>:<span class="number">18</span> | DEFINER       |         | utf8                 | utf8_general_ci      | latin1_swedish_ci  |</span><br><span class="line">+<span class="comment">-------------+------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h1><ul>
<li>Q:使用游标的几个步骤是什么？<ul>
<li>1.在能够使用游标前，必须声明它。这个过程实际上没用检索数据，它只是定义要使用的SELECT语句</li>
<li>2.一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来</li>
<li>3.对于填有数据的游标，根据需要取出(检索)各行</li>
<li>4.在结束游标使用时，必须关闭游标</li>
<li>在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作</li>
</ul>
</li>
</ul>
<h1 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h1><ul>
<li>Q:事务处理是什么？<ul>
<li>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行(除非明确指示)。如果没有发生错误，整组语句提交个诶数据库表。如果发生错误，则进行回退以恢复数据库到某个已知且安全的状态</li>
</ul>
</li>
<li>Q:事务开始和ROLLBACK命令示例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> FRMO ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>
<ul>
<li>事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT、CREATE和DROP，这些语句可以使用，但如果执行回退，不会被撤销</li>
</ul>
</li>
<li>Q:COMMIT命令示例<ul>
<li>一般的MySQL语句是直接针对数据库表执行和编写的，即隐含提交(implicit commit)，即提交(写或保存)操作是自动进行的</li>
<li>但事务处理块中必须用COMMIT进行明确的提交<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:使用保留点，支持回退部分事务处理<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br></pre></td></tr></table></figure></li>
<li>Q:更改默认的提交行为<ul>
<li>默认MySQL是自动提交所有更改。即任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效，不管有没有COMMIT语句</li>
<li>为指示MySQL不自动提交更改，可使用语句<code>SET autocommit=0;</code></li>
<li>注意：autocommit标志是针对每个连接而不是服务器的</li>
</ul>
</li>
</ul>
<h1 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h1><ul>
<li>Q:字符集、编码、校对是什么<ul>
<li>字符集：字母和符号的集合</li>
<li>编码：某个字符集成员的内部表示</li>
<li>校对：规定字符如何比较的指令</li>
</ul>
</li>
<li>Q:查看所支持的字符集完整列表以及每个字符集的描述和默认校对<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CHARACTER SET;</span><br><span class="line">+<span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line">| Charset  | Description                     | Default collation   | Maxlen |</span><br><span class="line">+<span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line">| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |</span><br><span class="line">| ascii    | US ASCII                        | ascii_general_ci    |      1 |</span><br><span class="line">| ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 |</span><br><span class="line">| koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 |</span><br><span class="line">| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |</span><br><span class="line">| greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 |</span><br><span class="line">| cp1250   | Windows Central European        | cp1250_general_ci   |      1 |</span><br><span class="line">| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |</span><br><span class="line">| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |</span><br><span class="line">| cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 |</span><br><span class="line">| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |</span><br><span class="line">| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |</span><br><span class="line">| cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 |</span><br><span class="line">| cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 |</span><br><span class="line">| utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |</span><br><span class="line">| binary   | Binary pseudo charset           | binary              |      1 |</span><br><span class="line">| eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 |</span><br><span class="line">| gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |</span><br><span class="line">+<span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line">41 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:查看所支持校对的完整列表，以及它们使用的字符集<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW COLLATION;</span><br><span class="line">+<span class="comment">--------------------------+----------+-----+---------+----------+---------+</span></span><br><span class="line">| Collation                | Charset  | Id  | Default | Compiled | Sortlen |</span><br><span class="line">+<span class="comment">--------------------------+----------+-----+---------+----------+---------+</span></span><br><span class="line">| big5_chinese_ci          | big5     |   1 | Yes     | Yes      |       1 |</span><br><span class="line">| big5_bin                 | big5     |  84 |         | Yes      |       1 |</span><br><span class="line">| latin1_german1_ci        | latin1   |   5 |         | Yes      |       1 |</span><br><span class="line">| latin1_swedish_ci        | latin1   |   8 | Yes     | Yes      |       1 |</span><br><span class="line">| latin1_danish_ci         | latin1   |  15 |         | Yes      |       1 |</span><br><span class="line">| latin1_german2_ci        | latin1   |  31 |         | Yes      |       2 |</span><br><span class="line">| latin1_bin               | latin1   |  47 |         | Yes      |       1 |</span><br><span class="line">| latin1_general_ci        | latin1   |  48 |         | Yes      |       1 |</span><br><span class="line">| latin1_general_cs        | latin1   |  49 |         | Yes      |       1 |</span><br><span class="line">| latin1_spanish_ci        | latin1   |  94 |         | Yes      |       1 |</span><br><span class="line">| gb2312_chinese_ci        | gb2312   |  24 | Yes     | Yes      |       1 |</span><br><span class="line">| gb2312_bin               | gb2312   |  86 |         | Yes      |       1 |</span><br><span class="line">| gbk_chinese_ci           | gbk      |  28 | Yes     | Yes      |       1 |</span><br><span class="line">| gbk_bin                  | gbk      |  87 |         | Yes      |       1 |</span><br><span class="line">| utf8_general_ci          | utf8     |  33 | Yes     | Yes      |       1 |</span><br><span class="line">| utf8_bin                 | utf8     |  83 |         | Yes      |       1 |</span><br><span class="line">| utf8_unicode_ci          | utf8     | 192 |         | Yes      |       8 |</span><br><span class="line">| utf8_icelandic_ci        | utf8     | 193 |         | Yes      |       8 |</span><br><span class="line">| utf8_roman_ci            | utf8     | 207 |         | Yes      |       8 |</span><br><span class="line">| utf8_persian_ci          | utf8     | 208 |         | Yes      |       8 |</span><br><span class="line">| utf8_croatian_ci         | utf8     | 213 |         | Yes      |       8 |</span><br><span class="line">| utf8_unicode_520_ci      | utf8     | 214 |         | Yes      |       8 |</span><br><span class="line">| utf8_vietnamese_ci       | utf8     | 215 |         | Yes      |       8 |</span><br><span class="line">| utf8_general_mysql500_ci | utf8     | 223 |         | Yes      |       1 |</span><br><span class="line">| gb18030_chinese_ci       | gb18030  | 248 | Yes     | Yes      |       2 |</span><br><span class="line">| gb18030_bin              | gb18030  | 249 |         | Yes      |       1 |</span><br><span class="line">| gb18030_unicode_520_ci   | gb18030  | 250 |         | Yes      |       8 |</span><br><span class="line">+<span class="comment">--------------------------+----------+-----+---------+----------+---------+</span></span><br><span class="line">222 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>有的字符集具有不止一种校对。如latin1对不同的欧洲语言有几种校对，而且许多校对出现两次，一次区分大小写（由_cs表示)，一次不区分大小写（由_ci表示）</li>
<li>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对</li>
</ul>
</li>
<li>Q:确定所用的字符集和校对<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+<span class="comment">--------------------------+----------------------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br><span class="line">+<span class="comment">----------------------+-------------------+</span></span><br><span class="line">| Variable_name        | Value             |</span><br><span class="line">+<span class="comment">----------------------+-------------------+</span></span><br><span class="line">| collation_connection | utf8_general_ci   |</span><br><span class="line">| collation_database   | latin1_swedish_ci |</span><br><span class="line">| collation_server     | latin1_swedish_ci |</span><br><span class="line">+<span class="comment">----------------------+-------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>字符集很少是服务器范围(甚至是数据库范围)的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定</li>
</ul>
</li>
<li>Q:使用带子句的CREATE TABLE给表指定字符集和校对<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE mytable</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;    columnn1 INT,</span><br><span class="line">    -&gt;    columnn2 VARCHAR(10)</span><br><span class="line">    -&gt; ) DEFAULT CHARACTER SET hebrew</span><br><span class="line">    -&gt;   COLLATE hebrew_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.22 sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:MySQL如何确定使用什么样的字符集和校对<ul>
<li>1.如果指定CHARACTER SET和COLLATE两者，则使用这些值</li>
<li>2.如果只指定CHARACTER SET，则使用此字符集及其默认的校对(如SHOW CHARACTER SET的结果中所示)</li>
<li>3.如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认</li>
</ul>
</li>
<li>Q:MySQL如何对特定列设置字符集和校对<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE mytable</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;    columnn1 INT,</span><br><span class="line">    -&gt;    columnn2 VARCHAR(10),</span><br><span class="line">    -&gt;    columnn3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci</span><br><span class="line">    -&gt; ) DEFAULT CHARACTER SET hebrew</span><br><span class="line">    -&gt;   COLLATE hebrew_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.26 sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:如何使用与创建表时不同的校对顺序排序特定的SELECT语句<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM customers</span><br><span class="line">    -&gt; ORDER BY lastname, firstname COLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>
<ul>
<li>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用，这里SELECT使用COLLATE指定一个备用的校对顺序，这会影响到结果排序的次序</li>
<li>这个例子为区分大小写的校对。反之也可以</li>
</ul>
</li>
<li>Q:COLLATE还可以使用在什么语句<ul>
<li>SELECT、ORDER BY、GROUP BY、HAVING、聚集函数、别名等</li>
<li>值得注意的是，如果绝对需要，串可以使用Cast()或Convert()函数在字符集之间进行转换</li>
</ul>
</li>
</ul>
<h1 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h1><ul>
<li>Q:获得所有用户账号列表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
<li>Q:创建用户账号<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;pa@$$w0rd&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>Q:重新命名一个用户账户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure></li>
<li>Q:删除用户账户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure></li>
<li>Q:查看用户账户权限<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GRANTS FOR root;</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| Grants for root@%                         |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果显示<code>USAGE ON *.*</code>，其中USAGE表示根本没有权限</li>
</ul>
</li>
<li>Q:允许用户在crashcourse数据库的所有表上使用SELECT<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure></li>
<li>Q:取消赋予用户bforta的SELECT访问权限<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">FROM</span> bforta;</span><br></pre></td></tr></table></figure></li>
<li>Q:权限表<ul>
<li><img src="https://img.shiqi-lu.tech/20210219172421.png"></li>
</ul>
</li>
<li>Q:设置自己的口令<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">Password</span>(<span class="string">&#x27;n3w p@$$w0rd&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>Q:更改用户口令<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> bforta = <span class="keyword">Password</span>(<span class="string">&#x27;n3w p@$$w0rd&#x27;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h1><ul>
<li>Q:数据备份的3个方案<ul>
<li>备份前首先使用<code>FLUSH TABLES</code>刷新未写数据</li>
<li>使用mysqldump转储所有数据库内容到某个外部文件</li>
<li>使用mysqlhotcopy从一个数据库复制所有数据(某些数据库引擎不支持)</li>
<li>使用MySQL的<code>BACKUP TABLE</code>或<code>SELECT INTO OUTFILE</code>转储所有数据到某个外部文件。这两条语句都接受要创建的系统文件名，此系统文件必须不存在。可用<code>RESTORE TABLE</code>来复原</li>
</ul>
</li>
<li>Q:检查表键是否正确<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE orders;</span><br><span class="line">+<span class="comment">--------------------+---------+----------+----------+</span></span><br><span class="line">| Table              | Op      | Msg_type | Msg_text |</span><br><span class="line">+<span class="comment">--------------------+---------+----------+----------+</span></span><br><span class="line">| crashcourse.orders | <span class="keyword">analyze</span> | <span class="keyword">status</span>   | OK       |</span><br><span class="line">+<span class="comment">--------------------+---------+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:检查CHECK TABLE<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CHECK TABLE orders, orderitems;</span><br><span class="line">+<span class="comment">------------------------+-------+----------+----------+</span></span><br><span class="line">| Table                  | Op    | Msg_type | Msg_text |</span><br><span class="line">+<span class="comment">------------------------+-------+----------+----------+</span></span><br><span class="line">| crashcourse.orders     | <span class="keyword">check</span> | <span class="keyword">status</span>   | OK       |</span><br><span class="line">| crashcourse.orderitems | <span class="keyword">check</span> | <span class="keyword">status</span>   | OK       |</span><br><span class="line">+<span class="comment">------------------------+-------+----------+----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>Q:修复相应表<ul>
<li><code>REPAIR TABLE</code></li>
</ul>
</li>
<li>Q:从一个表中删除大量数据后收回所用空间<ul>
<li><code>OPTIMIZE TABLE</code></li>
</ul>
</li>
<li>Q:MySQL的日志文件<ul>
<li>错误日志：包含启动和关闭问题以及任意关键错误的细节。通常名为 hostname.err，位于 data 目录</li>
<li>查询日志：记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。通常名为 hostname.log ， 位于 data 目录</li>
<li>二进制日志：记录更新过数据的所有语句。通常名为hostname-bin，位于 data 目录</li>
<li>慢查询日志：记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。 此日志通常名为 hostname-slow.log ， 位于 data 目录</li>
</ul>
</li>
</ul>
<h1 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h1><ul>
<li>Q:改善性能的建议<ul>
<li>MySQL（与所有DBMS一样）具有特定的硬件建议。对用于生产的服务器来说，应该坚持遵循这些硬件建议</li>
<li>关键的生产DBMS应该运行在自己的专用服务器上</li>
<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置， 可使用 <code>SHOW VARIABLES;</code> 和 <code>SHOW STATUS;</code>）</li>
<li>MySQL是一个多用户多线程的DBMS。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你到显著的性能不良，可使用<code>SHOW PROCESSLIST</code>显示所有活动进程（以及它们的线程ID和执行时间）。还可用KILL命令终结某个特定的进程</li>
<li>总有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法</li>
<li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句</li>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快</li>
<li>应该总是使用正确的数据类型</li>
<li>决不要检索比需求还要多的数据。除非你真正需要每个列，否则不要用<code>SELECT *</code></li>
<li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作</li>
<li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务， 需要分析使用的 SELECT 语句以找出重复的WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象</li>
<li>SELECT 语句中有一系列复杂的 OR 条件时，通过使用多条 SELECT 语句和连接它们的 UNION 语句， 可看到极大的性能改进</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。 如果有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li>
<li>LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE</li>
<li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变</li>
<li>最重要的规则就是，每条规则在某些条件下都会被打破</li>
</ul>
</li>
</ul>
<h1 id="附录D-MySQL数据类型"><a href="#附录D-MySQL数据类型" class="headerlink" title="附录D MySQL数据类型"></a>附录D MySQL数据类型</h1><ul>
<li>串数据类型<ul>
<li><img src="https://img.shiqi-lu.tech/20210325082641.png"></li>
</ul>
</li>
<li>数值数据类型<ul>
<li><img src="https://img.shiqi-lu.tech/20210325082724.png"></li>
</ul>
</li>
<li>日期和时间数据类型<ul>
<li><img src="https://img.shiqi-lu.tech/20210325082748.png"></li>
</ul>
</li>
<li>二进制数据类型<ul>
<li><img src="https://img.shiqi-lu.tech/20210325082804.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络问题重难点整理</title>
    <url>/network-interview/</url>
    <content><![CDATA[<h1 id="第二部分：应用层"><a href="#第二部分：应用层" class="headerlink" title="第二部分：应用层"></a>第二部分：应用层</h1><ul>
<li>Q:GET 和 POST 的区别<ul>
<li>get提交的数据会放在URL后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在URL中，可能会存在安全问题，因此往往用于获取资源信息。而post参数放在请求主体中，并且参数不会被保留，相比get方法，post方法更安全，主要用于修改服务器上的资源</li>
<li>get请求只支持URL编码，post请求支持多种编码格式</li>
<li>get只支持ASCII字符格式的参数，而post方法没有限制</li>
<li>get提交的数据大小有限制(主要针对浏览器而言)，而post方法提交的数据没有限制</li>
</ul>
</li>
<li>Q:HTTPS建立连接的过程<ul>
<li>1.客户端发起一个HTTPS请求，并连接到服务器的443端口，发送的信息主要包括自身所支持的算法列表和密钥长度等</li>
<li>2.服务端将自身所支持的所有加密算法和客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端</li>
<li>3.服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息</li>
<li>4.最后服务端发送一个报文通知客户端SSL的第一阶段已经协商完成</li>
<li>5.SSL第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为pre_master_secre，并且该报文是经过证书中的公钥加密过的</li>
<li>6.紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre加密的</li>
<li>7.客户端向服务端发送一个finish报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密</li>
<li>8.服务端同样发送与第6步中相同作用的报文，已让客户端进行确认，最后发送finish报文告诉客户端自己能够正确解密报文</li>
<li>当服务端和客户端的finish报文交换完成后，SSL连接就算建立完成了，之后就进行和HTTP相同的通信过程，唯一不同的是在HTTP通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了</li>
</ul>
</li>
<li>Q:HTTPS和HTTP的区别<ul>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程</li>
</ul>
</li>
<li>Q:HTTPS的加密方式<ul>
<li>HTTPS采用对称加密和非对称加密相结合的方式，首先使用SSL/TLS协议进行加密传输，为了弥补非对称加密的缺点，HTTPS采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称密钥进行加密解密，完成整个HTTPS的流程</li>
</ul>
</li>
<li>Q:客户端为什么信任第三方证书<ul>
<li>假设中间人篡改了整数原文，由于他没有CA机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息</li>
<li>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了</li>
</ul>
</li>
<li>Q:HTTP 是不保存状态的协议,如何保存用户状态<ul>
<li>基于 Session 实现的会话保持<ul>
<li>在客户端第一次向服务器发送HTTP请求后，服务器会创建一个session对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识(SessionID)给客户端，这个会话标识一般保存在客户端Cookie中，之后每次该浏览器发送HTTP请求都会带上Cookie中的SessionId到服务器，服务器根据会话标识就可将之前的状态信息与会话联系起来，从而实现会话保持</li>
<li>优点：安全性高，因为状态信息保存在服务器端</li>
<li>缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了</li>
<li>解决办法：采用中间件，如redis，将session信息存储在redis中，使得每个服务器都可以访问到之前的信息</li>
</ul>
</li>
<li>基于 Cookie 实现的会话保持<ul>
<li>在服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中</li>
<li>优点：服务器不用保存状态信息，减轻服务器存储压力，同时便于服务端做水平拓展</li>
<li>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽</li>
<li>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持</li>
</ul>
</li>
</ul>
</li>
<li>Q:HTTP/1.1 和 HTTP/1.0 的区别<ul>
<li>缓存处理：在HTTP/1.0中主要试用header里的if-modified-Since，Expires来做缓存判断的标准。而HTTP/1.1请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如Entity-tag, If-Unmodified-Since, If-Match, If-None-Match等可供选择的缓存头来控制缓存策略</li>
<li>节约带宽：当客户端请求某个资源时，HTTP/1.0默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在HTTP/1.1的请求头中引入了range头域，可使开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发</li>
<li>错误通知的管理：HTTP/1.1在1.0的基础上新增了24个错误状态响应码</li>
<li>Host请求头：早期HTTP/1.0中认为每台服务器都绑定一个唯一的IP地址并提供单一的服务，请求消息中的URL并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1中添加了host请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个404错误状态码</li>
<li>长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成后立即断开TCP连接。HTTP/1.1默认使用持久连接，支持在同一个TCP请求中传送多个HTTP请求和相应。在HTTP/1.1的请求头中，Connection字段帮助长连接的实现，当Connection请求头的值为Keep-alive时，客户端通知服务器返回本次请求结果后继续保持连接，而值为close时，服务器返回本次请求结果后会立即关闭连接</li>
</ul>
</li>
<li>Q:HTTP1.X 和 HTTP2.0 的区别<ul>
<li>相比于HTTP/1.X的文本(字符串)传送，HTTP/2.0采用二进制传送。客户端和服务端传输数据时把数据分成帧，帧组成了数据流，流具有流ID标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题</li>
<li>HTTP/2.0支持多路复用。因为流ID的存在，通过同一个HTTP请求可以实现多个HTTP请求传输，客户端和服务端可以通过流ID来标识究竟是哪个流从而定位到是哪个HTTP请求</li>
<li>HTTP/2.0头部压缩。HTTP/2.0通过gzip和compress压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次HTTP传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量</li>
<li>HTTP/2.0支持服务器推送。服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时刻通过发送复位相关的请求来取消服务端的推送</li>
</ul>
</li>
<li>Q:HTTP/2存在的问题<ul>
<li>统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议(TLS)，还会增加更多的握手次数。HTTP从1.0到2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的HTTP/2，也无法完全解决TCP协议存在的固有问题(慢启动，拥塞窗口尺寸的设置等)。此外，HTTP/2多路复用只是减少了连接数，其队头的阻塞问题并没有完全解决，倘若TCP丢包率过大，则HTTP/2的表现将不如HTTP/1.1</li>
</ul>
</li>
<li>Q:QUIC协议<ul>
<li>QUIC(Quick UDP Internet Connections)，直译为快速UDP网络连接，是谷歌制定的一种基于UDP的低延迟传输协议。其主要目的是解决传输层TCP协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了TCP,TLS,HTTP/2等协议的特性，并基于UDP传输。该协议带来的主要提升有：<ul>
<li>低延迟连接。当客户端第一次连接服务器时，QUIC只需1 RTT(Round-Trip Time)延迟就可以建立安全可靠的连接(采用TLS1.3版本)，相比TCP+TLS的3次RTT要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可实现0 RTT的连接建立延迟</li>
<li>QUIC复用了HTTP/2协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2存在的队头阻塞问题</li>
<li>基于UDP协议的QUIC运行在用户域而不是系统内核，这使得QUIC协议可以快速的更新和部署，从而很好地解决了 TCP 协议部署及更新的困难</li>
<li>QUIC的报文是经过加密和认证的，除了少量的报文，其它所有的QUIC报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改QUIC报文，接收端都能及时发现</li>
<li>具有向前纠错机制，每个数据包携带了除本身内容外的部分其它数据包的内容，使得出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升</li>
</ul>
</li>
</ul>
</li>
<li>Q:HTTP/3<ul>
<li>HTTP/3是在QUIC基础上发展起来的，其底层使用UDP进行数据传输，上层仍然使用HTTP/2。在UDP与HTTP/2之间存在一个QUIC层，其中TLS加密过程在该层进行处理。HTTP/3 主要有以下几个特点：</li>
<li>1.使用 UDP 作为传输层进行通信</li>
<li>2.在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手</li>
<li>3.建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据</li>
<li>4.不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立</li>
<li>5.使用QPACK进行头部压缩，因为在HTTP/2中HPACK要求传输过程有序，这会导致队头阻塞，而QPACK不存在这个问题</li>
</ul>
</li>
<li>Q:怎么实现 DNS 劫持<ul>
<li>DNS劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式</li>
<li>域名劫持往往只能在特定的网络范围内进行，范围外的DNS服务器能够返回正常的IP地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址</li>
</ul>
</li>
<li>Q:socket() 套接字有哪些<ul>
<li>套接字是对网络中不同主机上的应用程序之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程是通过套接字来发送报文来进行通信</li>
<li>有三种类型</li>
<li>流套接字(SOCK_STREAM)：基于TCP传输协议，主要用于提供面向连接、可靠的数据传输服务。由于TCP协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要再程序中进行相应的处理</li>
<li>数据报套接字(SOCK_DGRAM)：基于UDP传输协议，对应于无连接的UDP服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当UDP客户端发送一个数据给服务器后，可以通过同一个套接字给另一个服务器发送数据。当用UDP套接字时，丢包等问题需要在程序中进行处理</li>
<li>原始套接字(SOCK_RAW)：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包(例如ping命令时用的ICMP协议数据包)或者遇到操作系统无法处理的数据包时，此时需要建立原始套接字来发送</li>
</ul>
</li>
<li>Q:网页解析全过程【用户输入网址到显示对应页面的全过程】<ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求，会涉及到负载均衡</li>
<li>处理请求并返回</li>
<li>浏览器渲染</li>
<li>断开连接</li>
</ul>
</li>
</ul>
<h1 id="第三部分：传输层"><a href="#第三部分：传输层" class="headerlink" title="第三部分：传输层"></a>第三部分：传输层</h1><ul>
<li>Q:三次握手<ul>
<li><img src="https://img.shiqi-lu.tech/20210220115326.png"></li>
<li>是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务器也结束CLOSE阶段，被动打开的服务器也结束CLOSE阶段，并进入LISTEN阶段。随后进入三次握手阶段</li>
<li>1.首先客户端向服务器发送一个SYN包，并等待服务器确认，其中<ul>
<li>标志位为SYN，表示请求建立连接</li>
<li>序号为Seq = x</li>
<li>随后客户端进入SYN-SEND阶段</li>
</ul>
</li>
<li>2.服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中<ul>
<li>标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接</li>
<li>序号为Seq = y</li>
<li>确认号为 Ack = x + 1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值，随后服务器端进入SYN-RCVD阶段</li>
</ul>
</li>
<li>3.客户端接收到发送的SYN+ACK包后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段报文。其中<ul>
<li>标志位为ACK，表示确认收到服务器端同意连接的信号</li>
<li>序号为Seq = x + 1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值</li>
<li>确认号为Ack = y + 1，表示收到的服务器端序号seq，并将其值加1作为自己的确认号Ack的值</li>
<li>随后客户端将进入ESTABLISHED</li>
</ul>
</li>
<li>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输时正常的，从而结束SYN-SEND阶段阶段，进入ESTABLISHED阶段，从而完成三次握手</li>
</ul>
</li>
<li>Q:四次挥手<ul>
<li><img src="https://img.shiqi-lu.tech/20210220121011.png"></li>
<li>即TCP连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISHED。随后四次挥手</li>
<li>1.首先客户端向服务器发送一段TCP报文想要释放TCP连接，其中<ul>
<li>标记位为FIN，表示请求释放连接</li>
<li>序号为Seq = u</li>
<li>随后客户端进入FIN-WAIT-1阶段，即半关闭阶段，并且停止向服务端发送通信数据</li>
</ul>
</li>
<li>2.服务器接收到客户端请求断开连接的FIN报文后，结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回一段TCP报文，其中<ul>
<li>标记位位ACK，表示接收到客户端释放连接的请求</li>
<li>序号为Seq = v</li>
<li>确认号为Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加1作为本段报文确认号Ack的值</li>
<li>随后服务器开始准备释放服务器端到客户端方向上的连接</li>
</ul>
</li>
<li>客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</li>
<li>3.服务器端在发出ACK确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过CLOSE-WAIT阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段TCP报文，其中<ul>
<li>标记位为FIN和ACK，表示已经准备好释放连接了</li>
<li>序号为Seq = w</li>
<li>确认号Ack = u + 1，表示是在收到客户端报文的基础上，将其序号Seq的值加1作为本段报文确认号Ack的值</li>
</ul>
</li>
<li>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止向客户端发送数据</li>
<li>4.客户端收到从服务器发来的TCP报文，确认了服务器已经做好释放连接的准备，于是结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器发送一段报文，其中<ul>
<li>标记位为ACK，表示接收到服务器准备好释放连接的信号</li>
<li>序号为Seq = u+1，表示是在已收到服务器报文的基础上，将其确认号Ack值作为本段报文确认号的值</li>
</ul>
</li>
<li>随后客户端开始在TIME-WAIT阶段等待2MSL。服务器端收到从客户端发出的TCP报文结束LAST_ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段。由此完成四次挥手</li>
</ul>
</li>
<li>Q:如果三次握手的时候每次握手信息对方没有收到会怎么样<ul>
<li>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文，因此会等待一段时间后重新发送SYN同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回-1</li>
<li>若第二次握手客户端未接收到服务器回应的ACK报文时，客户端会采取第一次握手失败时的动作，而服务器端此时将阻塞在accept()函数调用处等待client再次发送ACK报文</li>
<li>若第三次握手服务器未接收到客户端发送过来的ACK报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则accept()系统调用返回-1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务端发送数据，但是服务端的accept()系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送RST报文给客户端，消除客户端单方面建立连接的状态</li>
</ul>
</li>
<li>Q:为什么要进行三次握手？两次握手可以吗？<ul>
<li>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据</li>
<li>网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口会一直开着，等到客户端因超时重新发出请求时，服务器就好重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费(虽说这话不完全正确)</li>
</ul>
</li>
<li>Q:为什么要四次挥手？<ul>
<li>释放 TCP 连接时之所以需要四次挥手，是因为FIN释放连接报文和ACK确认接收报文是分别在两次握手中传输的。当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回ACK确认报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接</li>
</ul>
</li>
<li>Q:CLOSE-WAIT 和 TIME-WAIT 的状态和意义<ul>
<li>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求后，服务器进入了CLOSE-WAIT状态，然而此时服务端还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成</li>
<li>TIME-WAIT发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入该状态，若取消该状态，即客户端在收到服务端的FIN报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。此外，假设客户端最后一次发送的ACK包在传输的时候丢失了，由于TCP协议的超时重传机制，服务端将重发FIN报文，若客户端并没有维持TIME-WAIT状态而直接关闭的话，当收到服务端重新发送的FIN包时，客户端就会用RST包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况</li>
</ul>
</li>
<li>Q:TIME_WAIT 状态会导致什么问题，怎么解决<ul>
<li>在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的连接失败</li>
<li>解决方法：修改配置或设置SO_REUSEADDR套接字，使得服务器处于TIME-WAIT状态下的端口能够快速回收和重用</li>
</ul>
</li>
<li>Q:TIME-WAIT 为什么是 2MSL<ul>
<li>当客户端发出最后的ACK确认报文时，并不能确定服务端能够收到该段报文。所以客户端在发送完ACK确认报文后，会设置一个时长为2MSL的计时器。MSL(Maximum Segment Lifetime)指一段TCP报文在传输过程中的最大生命周期。2MSL即是服务端发出FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</li>
<li>若服务器在1MSL内没有收到客户端发出的ACK确认报文，再次向客户端发出FIN报文。如果客户端在2MSL内收到了服务器再次发来的FIN报文，说明服务器由于一些原因并没有收到客户端发出的ACK确认报文。客户端将再次向服务器发出ACK确认报文，并重新开始2MSL的计时</li>
<li>若客户端在2MSL内没有再次收到服务器发送的FIN报文，则说明服务器正常接收到客户端ACK确认报文，客户端可以进入CLOSE阶段，即完成四次挥手</li>
<li>所以客户端要经历2MSL时长的TIME-WAIT阶段，为的是确认服务器能否接收到客户端发出的ACK确认报文</li>
</ul>
</li>
<li>Q:有很多 TIME-WAIT 状态如何解决<ul>
<li>服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口被占用，但TCP连接位于TIME_WAIT状态时可以重用端口。如果服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME-WAIT状态</li>
<li>也可采用长连接方式减少TCP的连接与断开，在长连接的业务中往往不需要考虑TIME-WAIT状态，但其实在长连接的业务中并发量一般不会太高</li>
</ul>
</li>
<li>Q:有很多 CLOSE-WAIT 怎么解决<ul>
<li>首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码</li>
<li>调整系统参数，包括句柄相关参数和TCP/IP参数，一般一个CLOSE_WAIT会维持至少2个小时的时间，可以通过调整参数来缩短这个时间</li>
</ul>
</li>
<li>Q:TCP 和 UDP 的区别<ul>
<li><img src="https://img.shiqi-lu.tech/20210220163423.png"></li>
</ul>
</li>
<li>Q:TCP协议中的7种定时器<ul>
<li>建立连接定时器：该定时器是在建立 TCP 连接的时候使用的，在 TCP 三次握手的过程中，发送方发送 SYN 时，会启动一个定时器（默认为 3 秒），若 SYN 包丢失了，那么 3 秒以后会重新发送 SYN 包，直到达到重传次数</li>
<li>重传定时器：该计时器主要用于 TCP 超时重传机制中，当TCP 发送报文段时，就会创建特定报文的重传计时器，并可能出现两种情况：<ul>
<li>1.若在计时器截止前发送方收到了接收方的ACK报文，则撤销该计时器</li>
<li>2.若计时器截止时间内并没有收到接收方的 ACK 报文，则发送方重传报文，并将计时器复位</li>
</ul>
</li>
<li>坚持计时器：TCP通过让接收方指明希望从发送方接收的数据字节数(窗口大小)来进行流量控制，当接收端的接收窗口满时，接收端会告诉发送端此时窗口已满，请停止发送数据。此时发送端和接收端的窗口大小均为0，直到窗口变为非0时，接收端将发送一个确认ACK告诉发送端可以再次发送数据，但是该报文有可能在传输时丢失。若该ACK报文丢失，则双方可能会一直等待下去，为了避免这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方发送探测报文段，以查看接收方窗口是否变大</li>
<li>延迟应答计时器：延迟应答也被称为捎带ACK，这个定时器是在延迟应答的时候使用的，为了提高网络传输 的效率，当服务器接收到客户端的数据后，不是立即回ACK给客户端，而是等一段时间，这样如果服务端有数据需要发送给客户端的话，就可以把数据和 ACK 一起发送给客户端了</li>
<li>保活定时器：该定时器是在建立TCP连接时指定SO_KEEPLIVE时才会生效，当发送方和接收方长时间没有进行数据交互时，该定时器可以用于确定对端是否还活着</li>
<li>FIN_WAIT_2定时器：当主动请求关闭的一方发送FIN报文给接收端并且收到其对FIN的确认ACK后进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致请求方没有收到接收方发来的FIN，主动关闭的一方会一直等待。该定时器的作用就是为了避免这种情况的发生。当该定时器超时的时候，请求关闭方将不再等待，直接释放连接</li>
<li>TIME_WAIT定时器：在 TCP 四次挥手中，发送方在最后一次挥手之后会进入 TIME_WAIT 状态，不直接进入CLOSE状态的主要原因是被动关闭方万一在超时时间内没有收到最后一个ACK，则会重发最后的FIN，2MSL(报文段最大生存时间)等待时间保证了重发的FIN会被主动关闭的一段收到且重新发送最后一个 ACK。还有一个原因是在这 2 MSL 的时间段内任何迟到的报文段会被接收方丢弃，从而防止老的 TCP 连接的包在新的 TCP 连接里面出现</li>
</ul>
</li>
<li>Q:TCP 是如何保证可靠性的<ul>
<li>数据分块：应用数据被分割成 TCP 认为最适合发送的数据块</li>
<li>序列号和确认应答：TCP给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个ACK报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。此外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据</li>
<li>校验和：TCP将保持它首部和数据部分的校验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li>流量控制：TCP连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP通过滑动窗口协议来支持流量控制机制</li>
<li>拥塞控制：当网络某个节点发生拥塞时，减少数据的发送</li>
<li>ARQ协议：为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组</li>
<li>超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段</li>
</ul>
</li>
<li>Q:UDP 为什么是不可靠的？<ul>
<li>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接收缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的</li>
</ul>
</li>
<li>Q:bind 和 connect 对于 UDP 的作用是什么<ul>
<li>UDP中调用connect只是把对端的IP和端口号记录下来，并且UDP可多次调用connect来指定一个新的IP和端口号，或断开旧的IP和端口号(通过设置connect函数的第二个参数)。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性</li>
<li>当UDP的发送端调用bind函数时，就会将这个套接字指定一个端口，若不调用bind函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能</li>
</ul>
</li>
<li>Q:TCP 的停止等待协议是什么<ul>
<li>停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。通过四种情形来帮助理解停等协议是如何实现可靠传输的：</li>
<li>1.无差错传输<ul>
<li><img src="https://img.shiqi-lu.tech/20210220172913.png"></li>
<li>A 发送分组 Msg 1，发完就暂停发送，直到收到接收方确认收到 Msg 1 的报文后，继续发送 Msg 2，以此类推，该情形是通信中的一种理想状态</li>
</ul>
</li>
<li>2.出现差错<ul>
<li><img src="https://img.shiqi-lu.tech/20210220173007.png"></li>
<li>发送方发送的报文出现差错导致接收方不能正确接收数据，出现差错的情况主要分为两种：<ul>
<li>发送方发送的 Msg 1 在中途丢失了，接收方完全没收到数据。</li>
<li>接收方收到 Msg 1 后检测出现了差错，直接丢弃 Msg 1。</li>
</ul>
</li>
<li>上面两种情形，接收方都不会回任何消息给发送方，此时就会触发超时传输机制，即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，因此重传前面发送过的数据</li>
</ul>
</li>
<li>3.确认丢失<ul>
<li><img src="https://img.shiqi-lu.tech/20210220173100.png"></li>
<li>当接收方回应的 Msg 1 确认报文在传输过程中丢失，发送方无法接收到确认报文。于是发送方等待一段时间后重传 Msg 1，接收方将收到重复的 Msg1 数据包，此时接收方会丢弃掉这个重复报文并向发送方再次发送 Msg1 的确认报文</li>
</ul>
</li>
<li>4.确认迟到<ul>
<li><img src="https://img.shiqi-lu.tech/20210220173136.png"></li>
<li>当接收方回应的 Msg 1 确认报文由于网络各种原因导致发送方没有及时收到，此时发送方在超时重传机制的作用下再次发送了 Msg 数据包，接收方此时进行和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送 Msg 1 确认报文）。发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后，发送方收到了迟到的 Msg 1 确认包会直接丢弃</li>
</ul>
</li>
</ul>
</li>
<li>Q:TCP 最大连接数限制<ul>
<li>Client 最大 TCP 连接数<ul>
<li>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个</li>
</ul>
</li>
<li>Server 最大 TCP 连接数<ul>
<li>Server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用(Unix 的 SO_REUSEADDR选项)的情况下，即使server端有多个IP，本地监听端口也是独占的，因此server端TCP连接4元组中只有客户端的IP地址和端口号是可变的，因此最大TCP连接为客户端IP数 x 客户端port数，对IPv4，在不考虑IP地址分类的情况下，最大TCP连接数约为2的32次方(IP数)x2的16次方(port数)，即server端单机最大TCP连接数约为2的48次方</li>
<li>上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的</li>
</ul>
</li>
</ul>
</li>
<li>Q:TCP 流量控制与拥塞控制<ul>
<li>流量控制<ul>
<li>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复</li>
</ul>
</li>
<li>拥塞控制和流量控制的区别<ul>
<li>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题</li>
</ul>
</li>
</ul>
</li>
<li>Q:如果接收方滑动窗口满了，发送方会怎么做<ul>
<li>基于 TCP 流量控制中的滑动窗口协议，接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大，当发现窗口大小变为非零时，发送方便继续发送数据</li>
</ul>
</li>
<li>Q:TCP拥塞控制采用的4种算法<ul>
<li>慢开始<ul>
<li>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。</li>
<li>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。</li>
<li>1.当 cwnd &lt; ssthresh 时，使用上述的慢开始算法；</li>
<li>2.当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；</li>
<li>3.当 cwnd == ssthresh 时，两者均可。</li>
</ul>
</li>
<li>拥塞避免<ul>
<li>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。</li>
<li>当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</li>
</ul>
</li>
<li>快重传<ul>
<li>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</li>
</ul>
</li>
<li>快恢复<ul>
<li>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</li>
<li>1.当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；</li>
<li>2.由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd</li>
</ul>
</li>
</ul>
</li>
<li>Q:TCP 粘包问题<ul>
<li>发生TCP粘包和拆包的原因<ul>
<li>1.发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包</li>
<li>2.发送方写入的数据小于套接字缓冲区大小，由于TCP默认使用Nagle算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包</li>
<li>3.进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包</li>
<li>4.发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包</li>
</ul>
</li>
<li>常见解决方法<ul>
<li>1.在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容</li>
<li>2.固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但该方法会浪费网络资源</li>
<li>3.设置消息边界，也可理解为分隔符，服务端从数据流中按消息边界分理出消息内容，一般使用换行符</li>
</ul>
</li>
<li>处理粘包问题的时机<ul>
<li>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包</li>
<li>而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题</li>
</ul>
</li>
</ul>
</li>
<li>Q:SYN FLOOD是什么<ul>
<li>是典型的DoS(拒绝服务)攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求(SYN)数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求</li>
</ul>
</li>
</ul>
<h1 id="第四部分：网络层"><a href="#第四部分：网络层" class="headerlink" title="第四部分：网络层"></a>第四部分：网络层</h1><ul>
<li>Q:两台电脑连起来后ping不通的可能问题<ul>
<li>1.看网络是否连接正常，检查网卡驱动是否正确安装</li>
<li>2.局域网设置问题，检查 IP 地址是否设置正确</li>
<li>3.看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 </li>
<li>4.看是否被第三方软件拦截</li>
<li>5.两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">计算机网络面试突击 leetbook</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第9-11章学习笔记</title>
    <url>/tcpip-network-programming-3/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-9-章-套接字的多种可选项"><a href="#第-9-章-套接字的多种可选项" class="headerlink" title="第 9 章 套接字的多种可选项"></a>第 9 章 套接字的多种可选项</h1><h2 id="9-1-套接字可选项和-I-O-缓冲大小"><a href="#9-1-套接字可选项和-I-O-缓冲大小" class="headerlink" title="9.1 套接字可选项和 I/O 缓冲大小"></a>9.1 套接字可选项和 I/O 缓冲大小</h2><ul>
<li>Q:套接字有哪些常用设置选项？<ul>
<li><img src="https://img.shiqi-lu.tech/20210623205237.png"></li>
</ul>
</li>
<li>Q:用于读取套接字可选项的函数getsockopt<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="comment">// sock：用于查看选项套接字文件描述符</span></span><br><span class="line"><span class="comment">// level：要查看的可选项的协议层</span></span><br><span class="line"><span class="comment">// optname：要查看的可选项名</span></span><br><span class="line"><span class="comment">// optval：保存查看结果的缓冲地址值</span></span><br><span class="line"><span class="comment">// optlen：向第四个参数optval传递的缓冲大小。调用函数后，</span></span><br><span class="line"><span class="comment">//        该变量中保存通过第四个参数返回的可选项信息的字节数</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:用于更改套接字可选项的函数setsockopt<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">// sock：用于更改选项套接字文件描述符</span></span><br><span class="line"><span class="comment">// level：要更改的可选项的协议层</span></span><br><span class="line"><span class="comment">// optname：要更改的可选项名</span></span><br><span class="line"><span class="comment">// optval：保存要更改的选项信息的缓冲地址值</span></span><br><span class="line"><span class="comment">// optlen：向第四个参数optval传递的可选项信息的字节数</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:用协议层为SOL_SOCKET、名为SO_TYPE的可选项查看套接字类型(TCP或UDP)的程序示例sock_type.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tcp_sock, udp_sock;</span><br><span class="line">    <span class="keyword">int</span> sock_type;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    optlen = <span class="keyword">sizeof</span>(sock_type);</span><br><span class="line">    <span class="comment">// 分别生成TCP、UDP套接字</span></span><br><span class="line">    tcp_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出创建TCP、UDP套接字时传入的SOCK_STREAM、SOCK_DGRAM</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM: %d\n&quot;</span>, SOCK_STREAM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM: %d\n&quot;</span>, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取套接字类型信息</span></span><br><span class="line">    <span class="comment">// 如果是TCP套接字，将获得SOCK_STREAM常数值1</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE,</span><br><span class="line">                       (<span class="keyword">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Socket type one: %d\n&quot;</span>, sock_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是UDP套接字，则获得SOCK_DGRAM的常数值2</span></span><br><span class="line">    state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE,</span><br><span class="line">                       (<span class="keyword">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Socket type two: %d\n&quot;</span>, sock_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch09$ gcc sock_type.c -o socktype</span><br><span class="line">shiqi@pc:~/network/ch09$ ./socktype</span><br><span class="line">SOCK_STREAM: 1</span><br><span class="line">SOCK_DGRAM: 2</span><br><span class="line">Socket type one: 1</span><br><span class="line">Socket type two: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:读取创建套接字时默认的I/O缓冲大小的实例程序get_buf.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">int</span> snd_buf, rcv_buf, state;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    state = getsockopt(sock, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d\n&quot;</span>, rcv_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch09$ gcc get_buf.c -o getbuf</span><br><span class="line">shiqi@pc:~/network/ch09$ ./getbuf</span><br><span class="line">Output buffer size: 16384</span><br><span class="line">Input buffer size: 131072</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:更改套接字I/O缓冲大小的示例程序set_buf.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">int</span> snd_buf = <span class="number">1024</span>*<span class="number">3</span>, rcv_buf = <span class="number">1024</span>*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 更改 I/O 接收缓冲大小</span></span><br><span class="line">    state = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">void</span> *)&amp;rcv_buf, <span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;setockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改 I/O 发送缓冲大小</span></span><br><span class="line">    state = setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span> *)&amp;snd_buf, <span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;setockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    <span class="comment">// 读取 I/O 发送缓冲大小</span></span><br><span class="line">    state = getsockopt(sock, SOL_SOCKET, SO_SNDBUF,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    <span class="comment">// 读取 I/O 接收缓冲大小</span></span><br><span class="line">    state = getsockopt(sock, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">                       (<span class="keyword">void</span> *)&amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d\n&quot;</span>, rcv_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch09$ gcc set_buf.c -o setbuf</span><br><span class="line">shiqi@pc:~/network/ch09$ ./setbuf</span><br><span class="line">Output buffer size: 6144</span><br><span class="line">Input buffer size: 6144</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="9-2-SO-REUSEADDR"><a href="#9-2-SO-REUSEADDR" class="headerlink" title="9.2 SO_REUSEADDR"></a>9.2 SO_REUSEADDR</h2><ul>
<li>Q:Time-wait状态下，服务器发生bind() error错误程序示例reuseadr_eserver.c<ul>
<li>如果在服务器端和客户端已建立连接的状态下，向服务器端控制台输入CTRL+C，即强制关闭服务器端。相当于模拟服务器端向客户端发送 FIN 消息。以这种方式终止程序，服务端若用统一端口号重新运行，将输出「bind() error」，无法再次运行，这种情况下，大约过3分钟即可重新运行服务器端</li>
<li>解决方案可在套接字的可选项中更改 SO_REUSEADDR 为1，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字，把程序中的注释去掉即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> * message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> option, str_len;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen, clnt_adr_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    optlen = sizeof(option);</span></span><br><span class="line"><span class="comment">    option = TRUE;</span></span><br><span class="line"><span class="comment">    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR,</span></span><br><span class="line"><span class="comment">               (void *)&amp;option, optlen);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr))) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sock = accept(serv_sock,</span><br><span class="line">                       (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                       &amp;clnt_adr_sz);</span><br><span class="line">    <span class="keyword">while</span> ((str_len = read(clnt_sock,</span><br><span class="line">                           message,</span><br><span class="line">                           <span class="keyword">sizeof</span>(message))) != <span class="number">0</span>) &#123;</span><br><span class="line">        write(clnt_sock, message, str_len);</span><br><span class="line">        write(<span class="number">1</span>, message, str_len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行，客户端使用第四章的客户端即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch09$ gcc reuseadr_eserver.c -o eserver</span><br><span class="line">shiqi@pc:~/network/ch09$ ./eserver 9898</span><br><span class="line">mmu</span><br><span class="line">^C</span><br><span class="line">shiqi@pc:~/network/ch09$ ./eserver 9898</span><br><span class="line">bind() error</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="9-3-TCP-NODELAY"><a href="#9-3-TCP-NODELAY" class="headerlink" title="9.3 TCP_NODELAY"></a>9.3 TCP_NODELAY</h2><ul>
<li>Q:Naggle算法是什么？<ul>
<li><img src="https://img.shiqi-lu.tech/20210625213956.png"></li>
<li>TCP 套接字默认使用 Nagle 算法交换数据，只有收到前一数据的 ACK 消息时，Nagle算法才发送下一数据，在此之前会最大限度地进行缓冲</li>
<li>如左图，为了发送字符串「Nagle」, 将其传递到输出缓冲。这时头字符「N」之前没有其他数据(没有需接收的ACK )，因此立即传输。之后开始等待字符「N」的ACK消息，等待过程中，剩下的「agle」填入输出缓冲。接下来，收到字符「N」的ACK消息后，将输出缓冲的「agle」装入一个数据包发送。也就是说，共需传递4个数据包以传输1个字符串</li>
<li>右图是未使用Nagle算法时发送字符串「Nagle」的过程。假设字符「N」到「e」依序传到输出缓冲。此时的发送过程与ACK接收与否无关，因此数据到达输出缓冲后将立即被发送出去，可以看到，发送字符串「Nagle」时共需10个数据包</li>
<li>由此可知，不使用Nagle算法将对网络流量(Traffic:指网络负载或混杂程度)产生负面影响。即使只传输1个字节的数据，其头信息都有可能是几十个字节。因此，为了提高网络传输效率，必须使用Nagle算法</li>
</ul>
</li>
<li>Q:什么时候可以禁用 Nagle 算法？<ul>
<li>网络流量并未受太大影响时，不使用Nagle算法要比使用它时传输速度快</li>
<li>最典型的是「传输大文件数据」，将文件数据传入输出缓冲不会花太多时间，因此，即便不使用 Nagle 算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而会在无需等待 ACK 的前提下连续传输，因此可以大大提高传输速度</li>
<li>一般情况下，不使用 Nagle 算法可以提高传输速度。但如果无条件放弃使用 Nagle 算法，就会增加过多的网络流量，反而会影响传输。因此，未准确判断数据特性时不应禁用 Nagle 算法</li>
</ul>
</li>
<li>Q:如何禁用 Nagle 算法<ul>
<li>把套接字可选项 TCP_NODELAY 改为1(True)即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt_val = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,</span><br><span class="line">           (<span class="keyword">void</span> *)&amp;opt_val, <span class="keyword">sizeof</span>(opt_val));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:如何查看 Nagle 算法的设置状态<ul>
<li>查看 TCP_NODELAY 的值，如果正在使用 Nagle 算法，opt_val 变量中会保存 0，禁用保存 1<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt_val;</span><br><span class="line"><span class="keyword">socklen_t</span> opt_len;</span><br><span class="line">opt_len = <span class="keyword">sizeof</span>(opt_val);</span><br><span class="line">getsockopt(sock, IPPROTO_TCP, TCP_NODELAY,</span><br><span class="line">           (<span class="keyword">void</span> *)&amp;opt_val, &amp;opt_len);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第-10-章-多进程服务器端"><a href="#第-10-章-多进程服务器端" class="headerlink" title="第 10 章 多进程服务器端"></a>第 10 章 多进程服务器端</h1><h2 id="10-1-进程概念及应用"><a href="#10-1-进程概念及应用" class="headerlink" title="10.1 进程概念及应用"></a>10.1 进程概念及应用</h2><ul>
<li>Q:具有代表性的并发服务端的实现模型和方法<ul>
<li>多进程服务器：通过创建多个进程提供服务</li>
<li>多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务</li>
</ul>
</li>
<li>Q:通过fork函数创建进程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回进程ID, 失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>fork函数将创建调用的进程副本。即并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。</li>
<li>两个进程都将执行fork函数调用后的语句(准确说是fork函数返回后)。但因通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分</li>
<li>父进程(Parent Process)，即原进程，为调用fork函数的主体：fork函数返回子进程ID</li>
<li>子进程(Child Process)，即通过父进程调用 fork 函数复制出的进程：fork函数返回0</li>
<li><img src="https://img.shiqi-lu.tech/20210217162244.png"></li>
</ul>
</li>
<li>Q:fork函数示意fork.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gval = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> lval = <span class="number">20</span>;</span><br><span class="line">    ++gval, lval += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        gval += <span class="number">2</span>, lval += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        gval -= <span class="number">2</span>, lval -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Proc: [%d,%d] \n&quot;</span>, gval, lval);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Proc: [%d,%d] \n&quot;</span>, gval, lval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc fork.c -o fork</span><br><span class="line">shiqi@inspiron:~/network$ ./fork</span><br><span class="line">Parent Proc: [9,23]</span><br><span class="line">Child Proc: [13,27]</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="10-2-进程和僵尸进程"><a href="#10-2-进程和僵尸进程" class="headerlink" title="10.2 进程和僵尸进程"></a>10.2 进程和僵尸进程</h2><ul>
<li>Q:产生僵尸进程的原因<ul>
<li>调用fork函数产生子进程的两种终止方式<ul>
<li>传递参数并调用exit函数</li>
<li>main函数中执行return语句并返回值</li>
</ul>
</li>
<li>向 exit 函数传递的参数值和 main 函数的 return 语句返回的值都回传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程，处在这种状态下的进程就是僵尸进程</li>
<li>即将子进程变成僵尸进程的是操作系统</li>
<li>僵尸进程被销毁的时机是，操作系统向创建子进程的父进程传递子进程的 exit 参数值或 return 语句的返回值后</li>
<li>操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）的时候，操作系统才会传递该值，即如果父进程未主动要求获得子进程结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态</li>
</ul>
</li>
<li>Q:创建僵尸进程示例zombie.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hi, I am a child process&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 输出子进程ID，可通过该值查看子进程状态（是否为僵尸进程）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process ID: %d \n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 如果父进程终止，处于僵尸状态的子进程将同时销毁</span></span><br><span class="line">        <span class="comment">// 因此延缓父进程的执行以验证僵尸进程</span></span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End child proess&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End parent process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc zombie.c -o zombie</span><br><span class="line">shiqi@inspiron:~/network$ ./zombie</span><br><span class="line">Child Process ID: 24767</span><br><span class="line">Hi, I am a child process</span><br><span class="line">End child proess</span><br><span class="line">End parent process</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) shiqi@inspiron:~/network$ ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">shiqi    24766  0.0  0.0   4504   720 pts/1    S+   16:42   0:00 ./zombie</span><br><span class="line">shiqi    24767  0.0  0.0      0     0 pts/1    Z+   16:42   0:00 [zombie] &lt;defunct&gt;</span><br></pre></td></tr></table></figure></li>
<li>Q:销毁僵尸进程 1：利用 wait 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> * statloc)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回终止的子进程 ID ,失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main 函数的 return 返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他信息，因此需要用下列宏进行分离<ul>
<li>WIFEXITED：子进程正常终止时返回真</li>
<li>WEXITSTATUS：返回子进程的返回值</li>
</ul>
</li>
<li>即向 wait 函数传递变量 status 的地址时，调用 wait 函数后应编写如下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">    <span class="comment">// 是正常终止的吗？</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Normal termination!&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child pass num: %d&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用 wait 函数时，如果没有已经终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此要谨慎调用该函数</li>
</ul>
</li>
<li>Q:wait函数示例wait.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// 这里的子进程将通过 return 语句终止</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d \n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 这里的子进程将通过 exit() 函数终止</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d \n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前终止的子进程相关信息将被保存到 status 中</span></span><br><span class="line">            <span class="comment">// 同时相关子进程被完全销毁</span></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="comment">// 通过 WIFEXITED 来验证子进程是否正常终止</span></span><br><span class="line">            <span class="comment">// 如果正常终止，则调用 WEXITSTATUS 宏输出子进程返回值</span></span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send one: %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为之前创建了两个进程，所以再次调用 wait 函数和宏</span></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send two: %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 暂停父进程，此时可查看子进程的状态</span></span><br><span class="line">            sleep(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc wait.c -o wait</span><br><span class="line">shiqi@inspiron:~/network$ ./wait</span><br><span class="line">Child PID: 24876</span><br><span class="line">Child PID: 24877</span><br><span class="line">Child send one: 3</span><br><span class="line">Child send two: 7</span><br></pre></td></tr></table></figure></li>
<li>Q:销毁僵尸进程 2：使用 waitpid 函数<ul>
<li>waitpid可以防止阻塞<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> * statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">// pid: 等待终止的目标子进程的ID，若传递-1，则与wait函数相同</span></span><br><span class="line"><span class="comment">//      可以等待任意子进程终止</span></span><br><span class="line"><span class="comment">// statloc: 与wait函数的statloc参数一样</span></span><br><span class="line"><span class="comment">// options: 传递头文件 sys/wait.h 中声明的常量WNOHANG,</span></span><br><span class="line"><span class="comment">//          即使没有终止的子进程也不会进入阻塞状态，</span></span><br><span class="line"><span class="comment">//          而是返回0并退出函数</span></span><br><span class="line"><span class="comment">// 成功时返回终止的子进程ID 或 0 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:waitpid函数示例waitpid.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// 这里的子进程将通过 return 语句终止</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d \n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 这里的子进程将通过 exit() 函数终止</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d \n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前终止的子进程相关信息将被保存到 status 中</span></span><br><span class="line">            <span class="comment">// 同时相关子进程被完全销毁</span></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="comment">// 通过 WIFEXITED 来验证子进程是否正常终止</span></span><br><span class="line">            <span class="comment">// 如果正常终止，则调用 WEXITSTATUS 宏输出子进程返回值</span></span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send one: %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为之前创建了两个进程，所以再次调用 wait 函数和宏</span></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send two: %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 暂停父进程，此时可查看子进程的状态</span></span><br><span class="line">            sleep(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network$ gcc waitpid.c -o waitpid</span><br><span class="line">shiqi@pc:~/network$ ./waitpid</span><br><span class="line">sleep 3 sec.</span><br><span class="line">sleep 3 sec.</span><br><span class="line">sleep 3 sec.</span><br><span class="line">sleep 3 sec.</span><br><span class="line">sleep 3 sec.</span><br><span class="line">Child send 24</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="10-3-信号处理"><a href="#10-3-信号处理" class="headerlink" title="10.3 信号处理"></a>10.3 信号处理</h2><ul>
<li>Q:信号注册函数原型signal<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 为了在产生信号时调用，返回之前注册的函数指针</span></span><br><span class="line"><span class="comment">// 函数名: signal</span></span><br><span class="line"><span class="comment">// 参数: int signo, void(*func)(int)</span></span><br><span class="line"><span class="comment">// 返回类型: 参数为int型，返回void型函数指针```</span></span><br><span class="line">    - 第一个参数是特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值(指针)。发生第一个参数代表的情况时，调用第二个参数所指的函数</span><br><span class="line">    - 可以在 signal 函数中注册的部分特殊情况和对应的函数</span><br><span class="line">        - SIGALRM：已到通过调用 alarm 函数注册时间</span><br><span class="line">        - SIGINT：输入 ctrl+c</span><br><span class="line">        - SIGCHLD：子进程终止</span><br><span class="line">- Q:alarm函数原型</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">// 返回 0 或以秒为单位的距 SIGALRM 信号发生所剩时间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果调用该函数的同时向它传递一个正整形参数，相应时间后(以秒为单位)将产生 SIGALRM 信号</li>
<li>若向该函数传递为 0 ，则之前对 SIGALRM 信号的预约将取消</li>
<li>如果通过该函数预约信号后未指定该信号对应的处理函数，则（通过调用 signal 函数）终止进程，不做任何处理</li>
</ul>
</li>
<li>Q:信号处理示例signal.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理器(Handler)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每隔2秒重复产生 SIGALRM 信号</span></span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keycontrol</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;CTRL+C pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 注册 SIGALRM、SIGINT 信号及相应处理器</span></span><br><span class="line">    signal(SIGALRM, timeout);</span><br><span class="line">    signal(SIGINT, keycontrol);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>产生信号时，将唤醒由于调用 sleep 函数而进入阻塞状态的进程，进程一旦被唤醒，就不会再进入睡眠状态，即使还未到 sleep 函数中规定的时间也是如此</li>
<li>编译运行，第一次运行是没有任何输入的运行结果，第二次在运行过程中输入CTRL+C<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch10$ gcc signal.c -o signal</span><br><span class="line">shiqi@pc:~/network/ch10$ ./signal</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">shiqi@pc:~/network/ch10$ ./signal</span><br><span class="line">wait...</span><br><span class="line">^CCTRL+C pressed</span><br><span class="line">wait...</span><br><span class="line">^CCTRL+C pressed</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:信号处理函数sigaction<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction * act,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct sigaction * oldact)</span></span>;</span><br><span class="line"><span class="comment">// signo：传递信号信息，同signal函数</span></span><br><span class="line"><span class="comment">// act：对应于第一个参数的信号处理函数（信号处理器）信息</span></span><br><span class="line"><span class="comment">// oldact：通过此参数获取之前注册的信号处理函数指针，若不需要则传递0</span></span><br><span class="line"><span class="comment">// 成功时返回 0 ，失败时返回 -1```</span></span><br><span class="line">    - 需要声明并初始化 sigaction 结构体变量来调用 sigaction</span><br><span class="line">    - ```c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sa_handler：保存信号处理函数的指针值</span></span><br><span class="line"><span class="comment">// sa_mask和sa_flags：用于指定信号相关的选项和特性，</span></span><br><span class="line"><span class="comment">//                   所有位均初始化为0即可</span></span><br></pre></td></tr></table></figure></li>
<li>Q:sigaction函数的程序示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了注册信号处理函数，声明 sigaction 结构体变量</span></span><br><span class="line">    <span class="comment">// 并在 sa_handler 成员中保存函数指针值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = timeout;</span><br><span class="line">    <span class="comment">// sigemptyset 函数将 sa_mask 成员的所有位初始化为0</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 SIGALRM 信号的处理器。</span></span><br><span class="line">    <span class="comment">// 调用 alarm 函数预约2秒后发生 SIGALRM 信号</span></span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch10$ gcc sigaction.c -o sigaction</span><br><span class="line">shiqi@pc:~/network/ch10$ ./sigaction</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:使用信号处理技术消灭僵尸进程的示例程序remove_zombie.c<ul>
<li>使用子进程终止时会向父进程产生SIGCHLD信号的特性<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> id = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Removed proc id: %d \n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child send: %d \n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程执行区域</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hi, I&#x27;m child process&quot;</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程执行区域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d\n&quot;</span>, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 另一子程序执行区域</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Hi! I&#x27;m child process2&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">24</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch10$ gcc remove_zombie.c -o zombie</span><br><span class="line">shiqi@pc:~/network/ch10$ ./zombie</span><br><span class="line">Child proc id: 24086</span><br><span class="line">Hi, I&#x27;m child process</span><br><span class="line">Child proc id: 24087</span><br><span class="line">wait...</span><br><span class="line">Hi! I&#x27;m child process2</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 24087</span><br><span class="line">Child send: 24</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 24086</span><br><span class="line">Child send: 12</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="10-4-基于多任务的并发服务器"><a href="#10-4-基于多任务的并发服务器" class="headerlink" title="10.4  基于多任务的并发服务器"></a>10.4  基于多任务的并发服务器</h2><ul>
<li>Q:基于进程的并发服务器模型是怎样的？实现步骤是怎样<ul>
<li><img src="https://img.shiqi-lu.tech/20210626184246.png"></li>
<li>每当有客户端请求服务(连接请求)时，回声服务器端都创建子进程以提供服务</li>
<li>1.回声服务器端(父进程)通过调用 accept 函数受理连接请求</li>
<li>2.此时获取的套接字文件描述符创建并传递给子进程</li>
<li>3.子进程利用传递来的文件描述符提供服务</li>
</ul>
</li>
<li>Q:实现并发服务器的基于多进程实现的回声服务器echo_mpserv.c<ul>
<li>注意，在调用 fork 函数后，要将无关的套接字文件描述符关掉</li>
<li><img src="https://img.shiqi-lu.tech/20210626191027.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removed proc id: %d \n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止产生僵尸进程</span></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz  = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        <span class="comment">// 这个套接字fork之后，父子进程均会有</span></span><br><span class="line">        clnt_sock = accept(serv_sock,</span><br><span class="line">                           (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                           &amp;adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;new client connected...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程运行区域</span></span><br><span class="line">            <span class="comment">// 服务器套接字文件描述符同样也传递到子进程中</span></span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="keyword">while</span> ((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                write(clnt_sock, buf, str_len);</span><br><span class="line">            &#125;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行</li>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch10$ gcc echo_mpserv.c -o mpserv</span><br><span class="line">shiqi@pc:~/network/ch10$ ./mpserv 9190</span><br><span class="line">new client connected...</span><br><span class="line">new client connected...</span><br><span class="line">client disconnected...</span><br><span class="line">removed proc id: 24342</span><br><span class="line">client disconnected...</span><br><span class="line">removed proc id: 24227</span><br></pre></td></tr></table></figure></li>
<li>客户端1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch04$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): zz</span><br><span class="line">Message from server: zz</span><br><span class="line">Input message(Q to quit): ad</span><br><span class="line">Message from server: ad</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure></li>
<li>客户端2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch04$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): zmmz</span><br><span class="line">Message from server: zmmz</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="10-5-分割TCP的I-O程序"><a href="#10-5-分割TCP的I-O程序" class="headerlink" title="10.5  分割TCP的I/O程序"></a>10.5  分割TCP的I/O程序</h2><ul>
<li>Q:分割I/O程序是什么？<ul>
<li>分割数据收发过程，分割后，不同进程分别负责输入和输出</li>
<li>优点：</li>
<li>1.程序的实现更简单</li>
<li>2.提高频繁交换数据的程序性能</li>
<li><img src="https://img.shiqi-lu.tech/20210626192821.png"></li>
<li>图10-6左侧演示的是之前的回声客户端数据交换方式，右侧演示的是分割IO后的客户端数据传输方式。服务器端相同，不同的是客户端区域。分割I/O后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，由此提高同一时间内传输的数据量。这种差异在网速较慢时尤为明显</li>
</ul>
</li>
<li>Q:回声客户端的I/O程序分割示例echo_mpclient.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> str_len = read(sock, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 调用shutdown函数向服务器端传递EOF</span></span><br><span class="line">            <span class="comment">// return后即可调用主函数的close函数传递EOF</span></span><br><span class="line">            <span class="comment">// 因为主函数的fork函数复制了文件描述符，</span></span><br><span class="line">            <span class="comment">// 无法通过1次close函数调用传递EOF，</span></span><br><span class="line">            <span class="comment">// 因此需要通过shutdown函数另外传递</span></span><br><span class="line">            shutdown(sock, SHUT_WR);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock,</span><br><span class="line">                (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">                <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        write_routine(sock, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read_routine(sock, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行，服务端可用本章的echo_mpserv.c<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch10$ gcc echo_mpclient.c -o mpclient</span><br><span class="line">shiqi@pc:~/network/ch10$ ./mpclient 127.0.0.1 9190</span><br><span class="line">px</span><br><span class="line">Message from server: px</span><br><span class="line">rt</span><br><span class="line">Message from server: rt</span><br><span class="line">q</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第11章-进程间通信"><a href="#第11章-进程间通信" class="headerlink" title="第11章  进程间通信"></a>第11章  进程间通信</h1><h2 id="11-1-进程间通信的基本概念"><a href="#11-1-进程间通信的基本概念" class="headerlink" title="11.1  进程间通信的基本概念"></a>11.1  进程间通信的基本概念</h2><ul>
<li>Q:创建管道的pipe函数原型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// filedes[0]：通过管道接收数据时使用的文件描述符，即管道出口</span></span><br><span class="line"><span class="comment">// filedes[1]：通过管道传输数据时使用的文件描述符，即管道入口</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:pipe函数的示例程序pipe1.c，父进程与子进程进行数据交换<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;Who are you?&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        write(fds[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch11$ gcc pipe1.c -o pipe</span><br><span class="line">shiqi@pc:~/network/ch11$ ./pipe</span><br><span class="line">Who are you?```</span><br><span class="line">- Q:2个进程使用1个管道进行双向数据交换的程序示例pipe2.c</span><br><span class="line">    - ```c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">define BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fds[2];</span><br><span class="line">    char str1[] = &quot;Who are you?&quot;;</span><br><span class="line">    char str2[] = &quot;Thank you for your message&quot;;</span><br><span class="line">    char buf[BUF_SIZE];</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        write(fds[1], str1, sizeof(str1));</span><br><span class="line">        // 这个不能注释，注释后，下一个read会把管道内数据取走</span><br><span class="line">        // 而父进程则阻塞在read函数中无限等待</span><br><span class="line">        sleep(2);</span><br><span class="line">        read(fds[0], buf, BUF_SIZE);</span><br><span class="line">        printf(&quot;Child proc output: %s\n&quot;, buf);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        read(fds[0], buf, BUF_SIZE);</span><br><span class="line">        printf(&quot;Parent proc output: %s\n&quot;, buf);</span><br><span class="line">        write(fds[1], str2, sizeof(str2));</span><br><span class="line">        sleep(3);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch11$ gcc pipe2.c -o pipe2</span><br><span class="line">shiqi@pc:~/network/ch11$ ./pipe2</span><br><span class="line">Parent proc output: Who are you?</span><br><span class="line">Child proc output: Thank you for your message</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:2个进程使用2个管道进行双向数据交换的程序示例pipe3.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds1[<span class="number">2</span>], fds2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;Who are you?&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;Thank you for your message&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        write(fds1[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">        read(fds2[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc output: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fds1[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent proc output: %s\n&quot;</span>, buf);</span><br><span class="line">        write(fds2[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch11$ gcc pipe3.c -o pipe3</span><br><span class="line">shiqi@pc:~/network/ch11$ ./pipe3</span><br><span class="line">Parent proc output: Who are you?</span><br><span class="line">Child proc output: Thank you for your message</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="11-2-运用进程间通信"><a href="#11-2-运用进程间通信" class="headerlink" title="11.2  运用进程间通信"></a>11.2  运用进程间通信</h2><ul>
<li>Q:使用多进程的回声服务器端，并将回声客户端传输的字符串按序保持到文件中的程序示例echo_storeserv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_childproc</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removed proc id: %d \n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">int</span> str_len, state;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        FILE * fp = fopen(<span class="string">&quot;echomsg.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> msgbuf[BUF_SIZE];</span><br><span class="line">        <span class="keyword">int</span> i, len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            len = read(fds[<span class="number">0</span>], msgbuf, BUF_SIZE);</span><br><span class="line">            fwrite((<span class="keyword">void</span> *)msgbuf, <span class="number">1</span>, len, fp);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock,</span><br><span class="line">                           (struct sockaddr *)&amp;clnt_adr,</span><br><span class="line">                           &amp;adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;new client connected...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="keyword">while</span> ((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                write(clnt_sock, buf, str_len);</span><br><span class="line">                write(fds[<span class="number">1</span>], buf, str_len);</span><br><span class="line">            &#125;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(clnt_sock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@pc:~/network/ch11$ gcc echo_storeserv.c -o serv</span><br><span class="line">shiqi@pc:~/network/ch11$ ./serv 9190</span><br><span class="line">new client connected...</span><br><span class="line">client disconnected...</span><br><span class="line">removed proc id: 25075</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCP/IP网络编程》第1-5章学习笔记</title>
    <url>/tcpip-network-programming-1/</url>
    <content><![CDATA[<p>注：博主只关注编程实现的方面以及linux部分，部分网络原理讲解和windows实现部分跳过</p>
<h1 id="第-1-章-理解网络编程和套接字"><a href="#第-1-章-理解网络编程和套接字" class="headerlink" title="第 1 章 理解网络编程和套接字"></a>第 1 章 理解网络编程和套接字</h1><h2 id="1-1-理解网络编程和套接字"><a href="#1-1-理解网络编程和套接字" class="headerlink" title="1.1 理解网络编程和套接字"></a>1.1 理解网络编程和套接字</h2><ul>
<li>Q:网络编程中接受连接请求的套接字创建过程？<ul>
<li>1.调用 socket 函数创建套接字<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>2.调用 bind 函数分配IP地址和端口号<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, </span></span></span><br><span class="line"><span class="function"><span class="params">         struct sockaddr *myaddr, </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>3.调用 listen 函数转换为可接受请求状态<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>4.调用 accept 函数受理套接字请求<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:请求连接客户端程序的套接字的创建过程？<ul>
<li>1.调用 socket 函数 和 connect 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conncet</span><span class="params">(<span class="keyword">int</span> sockfd, </span></span></span><br><span class="line"><span class="function"><span class="params">            struct sockaddr *serv_addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>2.与服务端共同运行以收发字符串数据</li>
</ul>
</li>
<li>Q:Hello World服务端和客户端的例子<ul>
<li>服务端hello_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 socket 函数创建套接字</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用 bind 函数分配ip地址和端口号</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 listen 函数将套接字转为可接受连接状态</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">// 调用 accept 函数受理连接请求。如果在没有连接请求的情况下调用该函数，</span></span><br><span class="line">    <span class="comment">// 则不会返回，直到有连接请求为止</span></span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write 函数用于传输数据，若程序经过 accept 这一行执行到本行，</span></span><br><span class="line">    <span class="comment">// 则说明已经有了连接请求</span></span><br><span class="line">    write(clnt_sock, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端hello_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字，此时套接字并不马上分为服务端和客户端</span></span><br><span class="line">    <span class="comment">// 如果紧接着调用 bind,listen 函数，将成为服务器套接字</span></span><br><span class="line">    <span class="comment">// 如果调用 connect 函数，将成为客户端套接字</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 connect 函数向服务器发送连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str_len = read(sock, message, <span class="keyword">sizeof</span>(message) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (str_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc hello_server.c -o hserver</span><br><span class="line">shiqi@inspiron:~/network$ ./hserver 9190</span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc hello_client.c -o hclient</span><br><span class="line">shiqi@inspiron:~/network$ ./hclient 127.0.0.1 9190</span><br><span class="line">Message from server : Hello World!</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-基于-Linux-的文件操作"><a href="#1-2-基于-Linux-的文件操作" class="headerlink" title="1.2 基于 Linux 的文件操作"></a>1.2 基于 Linux 的文件操作</h2><ul>
<li>Q:分配给标准输入输出及标准错误的文件描述符<ul>
<li>0：标准输入(Standard Input)</li>
<li>1：标准输出(Standard Output)</li>
<li>2：标准错误(Standard Error)</li>
</ul>
</li>
<li>Q:打开文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// path：文件名的字符串地址</span></span><br><span class="line"><span class="comment">// flag：文件打开模式（文件特性信息）</span></span><br><span class="line"><span class="comment">// 成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件打开模式，如需传递多个参数，可通过位或运算符组合传递</li>
<li>O_CREAT：必要时创建文件</li>
<li>O_TRUNC：删除全部现有数据</li>
<li>O_APPEND：维持现有数据，保存到其后面</li>
<li>O_RDONLY：只读打开</li>
<li>O_WRONLY：只写打开</li>
<li>O_RDWR：读写打开</li>
</ul>
</li>
<li>Q:关闭文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// fd：需要关闭的文件或套接字的文件描述符</span></span><br><span class="line"><span class="comment">// 成功时返回 0 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:将数据写入文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// fd：显示数据传输对象的文件描述符</span></span><br><span class="line"><span class="comment">// buf：保存要传输数据的缓冲值地址</span></span><br><span class="line"><span class="comment">// nbytes：要传输数据的字节数</span></span><br><span class="line"><span class="comment">// 成功时返回写入的字节数 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在此函数的定义中，size_t 是通过 typedef 声明的 unsigned int 类型。对 ssize_t 来说，ssize_t 前面多加的 s 代表 signed ，即 ssize_t 是通过 typedef 声明的 signed int 类型</li>
</ul>
</li>
<li>Q:创建新文件并保存数据示例low_open.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;Let&#x27;s go!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O_CREAT | O_WRONLY | O_TRUNC 是文件打开模式，将创建新文件，并且只能写</span></span><br><span class="line">    <span class="comment">// 如存在 data.txt 文件，则清空文件中的全部数据</span></span><br><span class="line">    fd = open(<span class="string">&quot;data.txt&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;open() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file descriptor: %d \n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对应 fd 中保存的文件描述符的文件传输 buf 中保存的数据</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;write() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc low_open.c -o lopen</span><br><span class="line">shiqi@inspiron:~/network$ ./lopen</span><br><span class="line">file descriptor: 3</span><br><span class="line">shiqi@inspiron:~/network$ cat data.txt</span><br><span class="line">Let&#x27;s go!</span><br></pre></td></tr></table></figure></li>
<li>Q:读取文件中的数据<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// fd： 显示数据接收对象的文件描述符</span></span><br><span class="line"><span class="comment">// buf： 要保存接收的数据的缓冲地址值。</span></span><br><span class="line"><span class="comment">// nbytes： 要接收数据的最大字节数</span></span><br><span class="line"><span class="comment">// 成功时返回接收的字节数（但遇到文件结尾则返回 0），失败时返回 -1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:通过read()读取data.txt中的数据示例low_read.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;open() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file descriptor: %d \n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file data: %s&quot;</span>, buf);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc low_read.c -o lread</span><br><span class="line">shiqi@inspiron:~/network$ ./lread</span><br><span class="line">file descriptor: 3</span><br><span class="line">file data: Let&#x27;s go!</span><br></pre></td></tr></table></figure></li>
<li>Q:同时创建文件和套接字，并用整数型态比较返回的文件描述符的值，程序示例fd_seri.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;test.dat&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br><span class="line">    <span class="keyword">int</span> fd3 = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\n&quot;</span>, fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2: %d\n&quot;</span>, fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3: %d\n&quot;</span>, fd3);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc fd_seri.c -o fds</span><br><span class="line">shiqi@inspiron:~/network$ ./fds</span><br><span class="line">fd1: 3</span><br><span class="line">fd2: 4</span><br><span class="line">fd3: 5</span><br></pre></td></tr></table></figure>
<h2 id="1-3-基于-Windows-平台的实现"><a href="#1-3-基于-Windows-平台的实现" class="headerlink" title="1.3 基于 Windows 平台的实现"></a>1.3 基于 Windows 平台的实现</h2><h2 id="1-4-基于-Windows-的套接字相关函数及示例"><a href="#1-4-基于-Windows-的套接字相关函数及示例" class="headerlink" title="1.4 基于 Windows 的套接字相关函数及示例"></a>1.4 基于 Windows 的套接字相关函数及示例</h2></li>
</ul>
<h1 id="第-2-章-套接字类型与协议设置"><a href="#第-2-章-套接字类型与协议设置" class="headerlink" title="第 2 章 套接字类型与协议设置"></a>第 2 章 套接字类型与协议设置</h1><h2 id="2-1-套接字协议及数据传输特性"><a href="#2-1-套接字协议及数据传输特性" class="headerlink" title="2.1 套接字协议及数据传输特性"></a>2.1 套接字协议及数据传输特性</h2><ul>
<li>Q:创建套接字的 socket 函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：套接字中使用的协议族(Protocol Family)信息</span></span><br><span class="line"><span class="comment">// type：套接字数据传输类型信息</span></span><br><span class="line"><span class="comment">// protocol：计算机间通信中使用的协议信息</span></span><br><span class="line"><span class="comment">// 成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:头文件 sys/socket.h 中声明的协议族<ul>
<li>通过 socket 函数的第一个参数传递套接字中使用的协议分类信息，即协议族(Protocol Family)</li>
<li>PF_INETIPV4：互联网协议族</li>
<li>PF_INET6IPV6：互联网协议族</li>
<li>PF_LOCAL：本地通信 Unix 协议族</li>
<li>PF_PACKET：底层套接字的协议族</li>
<li>PF_IPX：IPX Novel 协议族</li>
<li>套接字中实际采用的最终的协议信息是通过 socket 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数</li>
</ul>
</li>
<li>Q:套接字类型1：面向连接的套接字(SOCK_STREAM)<ul>
<li>特点<ul>
<li>传输过程中数据不会消失</li>
<li>按序传输数据</li>
<li>传输的数据不存在数据边界（Boundary）</li>
</ul>
</li>
<li>收发数据的套接字内部有缓冲（buffer），即字节数组。通过套接字传输的数据将保存到该数组。因此收到数据并不意味着马上调用 read 函数。只要不超过数组容量，则有可能在数据填充满缓冲后通过一次或多次 read 函数调用读取</li>
<li>在面向连接的套接字中，read、write 函数的调用次数无太大意义，即为不存在数据边界</li>
<li>面向连接的套接字可总结为：可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字</li>
</ul>
</li>
<li>Q:套接字类型2：面向消息的套接字(SOCK_DGRAM)<ul>
<li>特点<ul>
<li>强调快速传输而非传输有序</li>
<li>传输的数据可能丢失也可能损毁</li>
<li>传输的数据有边界</li>
<li>限制每次传输数据的大小</li>
</ul>
</li>
<li>面向消息的套接字比面向连接的套接字具有更快的传输速度，但无法避免数据丢失或损毁。另外，每次传输的数据大小具有一定限制，并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同</li>
<li>面向消息的套接字特性总结：不可靠的、不按序传递的、以数据的高速传输为目的的套接字</li>
</ul>
</li>
<li>Q:协议的最终选择<ul>
<li>socket 函数的第三个参数决定最终采用的协议。因同一协议族中存在多个数据传输方式相同的协议，需要通过第三个参数指定具体的协议</li>
<li>创建IPv4协议族(PF_INET)中面向连接的套接字(SOCK_STREAM)，满足这两个条件的协议为 IPPROTO_TCP，即TCP套接字</li>
<li><code>int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)</code></li>
<li>创建IPv4协议族(PF_INET)中面向消息的套接字(SOCK_DGRAM)，满足这两个条件的协议为 IPPROTO_UDP，即UDP套接字</li>
<li><code>int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)</code></li>
</ul>
</li>
<li>Q:面向连接的套接字:TCP套接字示例<ul>
<li>服务端tcp_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 socket 函数创建套接字</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用 bind 函数分配ip地址和端口号</span></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 listen 函数将套接字转为可接受连接状态</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">// 调用 accept 函数受理连接请求。如果在没有连接请求的情况下调用该函数，</span></span><br><span class="line">    <span class="comment">// 则不会返回，直到有连接请求为止</span></span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write 函数用于传输数据，若程序经过 accept 这一行执行到本行，</span></span><br><span class="line">    <span class="comment">// 则说明已经有了连接请求</span></span><br><span class="line">    write(clnt_sock, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端tcp_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP套接字，此时套接字并不马上分为服务端和客户端</span></span><br><span class="line">    <span class="comment">// 如果紧接着调用 bind,listen 函数，将成为服务器套接字</span></span><br><span class="line">    <span class="comment">// 如果调用 connect 函数，将成为客户端套接字</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 若前两个参数使用PF_INET 和 SOCK_STREAM，</span></span><br><span class="line">    <span class="comment">// 则可以省略第三个参数 IPPROTO_TCP</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 connect 函数向服务器发送连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while循环中反复调用read函数，每次读取1个字节。</span></span><br><span class="line">    <span class="comment">// 如果read返回0，即文件末尾，则循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (read_len = read(sock, &amp;message[idx++], <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_handling(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count : %d \n&quot;</span>, str_len);</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc tcp_server.c -o hserver</span><br><span class="line">shiqi@inspiron:~/network$ ./hserver 9191</span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc tcp_client.c -o hclient</span><br><span class="line">shiqi@inspiron:~/network$ ./hclient 127.0.0.1 9191</span><br><span class="line">Message from server : Hello World!</span><br><span class="line">Function read call count : 13</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第-3-章-地址族与数据序列"><a href="#第-3-章-地址族与数据序列" class="headerlink" title="第 3 章 地址族与数据序列"></a>第 3 章 地址族与数据序列</h1><h2 id="3-1-分配给套接字的-IP-地址与端口号"><a href="#3-1-分配给套接字的-IP-地址与端口号" class="headerlink" title="3.1 分配给套接字的 IP 地址与端口号"></a>3.1 分配给套接字的 IP 地址与端口号</h2><h2 id="3-2-地址信息的表示"><a href="#3-2-地址信息的表示" class="headerlink" title="3.2 地址信息的表示"></a>3.2 地址信息的表示</h2><ul>
<li>Q:表示IPv4地址的结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family;  <span class="comment">// 地址族（Address Family）</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;    <span class="comment">// 16位TCP/UDP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// 32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span>           sin_zero[<span class="number">8</span>]; <span class="comment">// 不使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">// 32位IPv4地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义的数据类型说明<ul>
<li><img src="https://img.shiqi-lu.tech/20210213152341.png"></li>
</ul>
</li>
<li>sin_family：指定每种协议族适用的地址族(Address Family)<ul>
<li>AF_INET：IPV4用的地址族</li>
<li>AF_INET6：IPV6用的地址族</li>
<li>AF_LOCAL：本地通信中采用的 Unix 协议的地址族</li>
</ul>
</li>
<li>sin_port<ul>
<li>保持16位端口号，以网络字节序保存</li>
</ul>
</li>
<li>sin_addr<ul>
<li>保存32位IP地址信息，且以网络字节序保存，可同时观察结构体in_addr，其中声明为uint32_t，只需当作32位整数型即可</li>
</ul>
</li>
<li>sin_zero<ul>
<li>无特殊含义。只是为使结构体sockaddr_in的大小与sockaddr结构体保持一致而插 入的成员。必需填充为0，否则无法得到想要的结果。</li>
<li>sockaddr_in结构体变量地址值将以如下方式传递给bind函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_addr,</span><br><span class="line">         <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>此处 bind 第二个参数期望得到的是 sockaddr 结构体变量的地址值，包括地址族、端口号、IP地址等<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">// 地址族(Address Family)</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];       <span class="comment">// 地址信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该结构体成员 sa_data 保存的地址信息中需包含IP地址和端口号，剩余部分应填充0。而这对于包含地址的信息非常麻烦，所以有sockaddr_in结构体，最后转换为sockaddr 型的结构体变量，再传递给 bind 函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-网络字节序与地址变换"><a href="#3-3-网络字节序与地址变换" class="headerlink" title="3.3 网络字节序与地址变换"></a>3.3 网络字节序与地址变换</h2><ul>
<li>Q:CPU向内存保存数据的2种方式<ul>
<li>大端序（Big Endian）：高位字节存放到低位地址</li>
<li>小端序（Little Endian）：高位字节存放到高位地址</li>
<li><img src="https://img.shiqi-lu.tech/20210213160004.png"></li>
<li>网络传输数据时约定统一为大端序，即网络字节序(Network Byte Order)</li>
</ul>
</li>
<li>Q:字节序转换(Endian Conversions)函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>h：主机（host）字节序</li>
<li>n：主机（host）字节序</li>
<li>s：2个字节short，用于端口号转换</li>
<li>l：4个字节long，用于IP地址转换</li>
</ul>
</li>
<li>Q:字节序转换示例程序endian_conv.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> net_port = htons(host_port);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> host_addr = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> net_addr = htonl(host_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered port: %#x \n&quot;</span>, host_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered port: %#x \n&quot;</span>, net_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered address: %#lx \n&quot;</span>, host_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered address: %#lx \n&quot;</span>, net_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc endian_conv.c -o conv</span><br><span class="line">shiqi@inspiron:~/network$ ./conv</span><br><span class="line">Host ordered port: 0x1234</span><br><span class="line">Network ordered port: 0x3412</span><br><span class="line">Host ordered address: 0x12345678</span><br><span class="line">Network ordered address: 0x78563412</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-4-网络地址的初始化与分配"><a href="#3-4-网络地址的初始化与分配" class="headerlink" title="3.4 网络地址的初始化与分配"></a>3.4 网络地址的初始化与分配</h2><ul>
<li>Q:将字符串形式的IP地址转换成32位整数型数据，并同时进行网络字节序转换的inet_addr<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回32位大端序整数型值，失败时返回INADDR_NONE</span></span><br></pre></td></tr></table></figure>
<ul>
<li>示例inet_addr.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * addr1 = <span class="string">&quot;1.2.3.4&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> * addr2 = <span class="string">&quot;1.2.3.256&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> conv_addr = inet_addr(addr1);</span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conv_addr = inet_addr(addr2);</span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc inet_addr.c -o addr</span><br><span class="line">shiqi@inspiron:~/network$ ./addr</span><br><span class="line">Network ordered integer addr: 0x4030201</span><br><span class="line">Error occured!</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:利用了in_addr结构体将字符串形式IP地址转换为32位网络字节序整数返回的inet_aton函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>, struct in_addr * addr)</span></span>;</span><br><span class="line"><span class="comment">// string：含有需转换的IP地址信息的字符串地址值</span></span><br><span class="line"><span class="comment">// addr：将保存转换结果的in_addr结构体变量的地址值</span></span><br><span class="line"><span class="comment">// 成功时返回 1 ，失败时返回 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>示例inet_aton.c<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> error_handling(char *message)</span><br><span class="line">&#123;</span><br><span class="line">    fputs(message, stderr);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * addr = <span class="string">&quot;127.232.124.79&quot;</span>;</span><br><span class="line">    struct sockaddr_in addr_inet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inet_aton(addr, &amp;addr_inet.sin_addr)) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;Conversion error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">&quot;Network ordered integer addr: %#x \n&quot;</span>,</span><br><span class="line">               addr_inet.sin_addr.s_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc inet_aton.c -o aton</span><br><span class="line">shiqi@inspiron:~/network$ ./aton</span><br><span class="line">Network ordered integer addr: 0x4f7ce87f</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:把网络字节序整数型IP地址转换为字符串形式的inet_ntoa函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">inet_ntoa</span><span class="params">(struct in_addr adr)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回转换的字符串地址值，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，返回值为char指针。返回字符串地址意味着字符串已经保存在内存空间，但是该函数未向程序员要求分配内存，而是在内部申请了内存保存了字符串</li>
<li>即调用完该函数候要立即把字符串信息复制到其他内存空间。原因是若再次调用inet_ntoa函数可能会覆盖之前保存的字符串信息。即再次调用 inet_ntoa 函数前返回的字符串地址是有效的。长期保存则应复制到其它内存空间</li>
<li>示例inet_ntoa.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr1</span>, <span class="title">addr2</span>;</span></span><br><span class="line">    <span class="keyword">char</span> * str_ptr;</span><br><span class="line">    <span class="keyword">char</span> str_arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    addr1.sin_addr.s_addr = htonl(<span class="number">0x1020304</span>);</span><br><span class="line">    addr2.sin_addr.s_addr = htonl(<span class="number">0x1010101</span>);</span><br><span class="line"></span><br><span class="line">    str_ptr = inet_ntoa(addr1.sin_addr);</span><br><span class="line">    <span class="built_in">strcpy</span>(str_arr, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation1: %s \n&quot;</span>, str_ptr);</span><br><span class="line"></span><br><span class="line">    inet_ntoa(addr2.sin_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation2: %s \n&quot;</span>, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation3: %s \n&quot;</span>, str_arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc inet_ntoa.c -o ntoa</span><br><span class="line">shiqi@inspiron:~/network$ ./ntoa</span><br><span class="line">Dotted-Decimal notation1: 1.2.3.4</span><br><span class="line">Dotted-Decimal notation2: 1.1.1.1</span><br><span class="line">Dotted-Decimal notation3: 1.2.3.4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Q:套接字创建过程中常见的网络地址信息初始化方法<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> * serv_ip = <span class="string">&quot;211.217.168.13&quot;</span>; <span class="comment">// 声明IP地址字符串</span></span><br><span class="line"><span class="keyword">char</span> * serv_port = <span class="string">&quot;9190&quot;</span>;         <span class="comment">// 声明端口号字符串</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));    <span class="comment">// 结构体变量 addr 的所有成员初始化为0</span></span><br><span class="line">addr.sin_family = AF_INET;                 <span class="comment">// 指定地址族</span></span><br><span class="line">addr.sin_addr.s_addr = inet_addr(serv_ip); <span class="comment">// 基于字符串的IP地址初始化</span></span><br><span class="line">addr.sin_port = htons(atoi(serv_port));    <span class="comment">// 基于字符串的IP地址端口号初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>服务器端声明sockaddr_in结构体，将其初始化为赋予服务器端IP和套接字的端口号，然后调用bind函数</li>
<li>客户端声明sockaddr_in结构体，并初始化为要与之连接的服务器端套接字的IP和端口号，然后调用connect函数</li>
</ul>
</li>
<li>Q:服务器端使用INADDR_ANY自动获取运行服务器端的计算机IP地址<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> * serv_port = <span class="string">&quot;9190&quot;</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 注意这里</span></span><br><span class="line">addr.sin_port = htons(atoi(serv_port));</span><br></pre></td></tr></table></figure>
<ul>
<li>若同一计算机已分配多个IP地址(多宿主(Multi-homed)计算机，一般路由器属于这一类)，则只要端口号一致，即可从不同IP地址接受数据。服务器优先考虑这种方式</li>
</ul>
</li>
<li>Q:向套接字分配网络地址bind<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：要分配地址信息(IP地址和端口号)的套接字文件描述符</span></span><br><span class="line"><span class="comment">// myaddr：存有地址信息的结构体变量地址值</span></span><br><span class="line"><span class="comment">// addrlen：第二个结构体变量的长度</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第-4-章-基于-TCP-的服务端-客户端（1）"><a href="#第-4-章-基于-TCP-的服务端-客户端（1）" class="headerlink" title="第 4 章 基于 TCP 的服务端/客户端（1）"></a>第 4 章 基于 TCP 的服务端/客户端（1）</h1><h2 id="4-1-理解-TCP-和-UDP"><a href="#4-1-理解-TCP-和-UDP" class="headerlink" title="4.1 理解 TCP 和 UDP"></a>4.1 理解 TCP 和 UDP</h2><h2 id="4-2-实现基于-TCP-的服务器-客户端"><a href="#4-2-实现基于-TCP-的服务器-客户端" class="headerlink" title="4.2 实现基于 TCP 的服务器/客户端"></a>4.2 实现基于 TCP 的服务器/客户端</h2><ul>
<li>Q:TCP 服务端的默认函数的调用程序<ul>
<li><img src="https://img.shiqi-lu.tech/20210213171357.png"></li>
</ul>
</li>
<li>Q:进入等待连接请求状态的listen函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sock：希望进入等待连接请求状态的套接字文件描述符，</span></span><br><span class="line"><span class="comment">//       传递的描述符套接字参数成为服务端套接字（监听套接字）</span></span><br><span class="line"><span class="comment">// backlog：连接请求等待队列的长度，若为5，则队列长度为5，</span></span><br><span class="line"><span class="comment">//          表示最多使5个连接请求进入队列</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure></li>
<li>Q:受理客户端连接请求的accept函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, sockaddr * addr, <span class="keyword">socklen_t</span> * addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sock: 服务端套接字的文件描述符</span></span><br><span class="line"><span class="comment">// addr: 保存发起连接请求的客户端地址信息的变量地址值</span></span><br><span class="line"><span class="comment">//       调用函数后向传递来的地址变量参数填充客户端地址信息</span></span><br><span class="line"><span class="comment">// addrlen: 第二个参数addr结构体的长度，但是存放有长度的变量地址。</span></span><br><span class="line"><span class="comment">//          函数调用完成后，该变量即被填入客户端地址长度</span></span><br><span class="line"><span class="comment">// 成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>accept 函数受理连接请求队列中待处理的客户端连接请求。函数调用成功时，accept 函数内部将产生用于数据I/O的套接字，并返回其文件描述符</li>
<li>需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接</li>
</ul>
</li>
<li>Q:TCP 客户端的默认函数调用顺序<ul>
<li><img src="https://img.shiqi-lu.tech/20210213180234.png"></li>
</ul>
</li>
<li>Q:客户端发起连接请求的connect函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, </span></span></span><br><span class="line"><span class="function"><span class="params">            struct sockaddr * servaddr, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sock: 客户端套接字文件描述符</span></span><br><span class="line"><span class="comment">// servaddr: 保存目标服务器端地址信息的变量地址值</span></span><br><span class="line"><span class="comment">// addrlen: 以字节为单位传递给第二个结构体参数 servaddr 的变量地址长度</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端调用 connect 函数候，发生以下函数之一才会返回（完成函数调用）:<ul>
<li>服务器接受连接请求</li>
<li>发生断网等异常情况而中断连接请求</li>
</ul>
</li>
<li>注意：「接受连接」并不代表服务端调用accept函数，其实是服务端把连接请求信息记录到等待队列。因此 connect 函数返回后并不立即进行数据交换</li>
</ul>
</li>
<li>Q:基于 TCP 的服务端/客户端函数调用关系<ul>
<li><img src="https://img.shiqi-lu.tech/20210213181511.png"></li>
<li>1.服务器端创建套接字后连续调用bind、listen函数进入等待状态</li>
<li>2.客户端通过调用connect函数发起连接请求。(只能等到服务器端调用listen函数后才能调connect函数，同事客户端调用connect函数前，服务器端可能率先调用accept函数。当然此时服务器端在调用accept函数时进入阻塞(blocking)状态，知道客户端调connect函数为止)</li>
</ul>
</li>
</ul>
<h2 id="4-3-实现迭代服务端-客户端：服务端将客户端传输的字符串数据原封不动的传回客户端"><a href="#4-3-实现迭代服务端-客户端：服务端将客户端传输的字符串数据原封不动的传回客户端" class="headerlink" title="4.3 实现迭代服务端/客户端：服务端将客户端传输的字符串数据原封不动的传回客户端"></a>4.3 实现迭代服务端/客户端：服务端将客户端传输的字符串数据原封不动的传回客户端</h2><ul>
<li>Q:迭代服务器端的流程<ul>
<li>通过插入循环语句反复调用accept函数，可实现继续处理后续客户端连接请求</li>
<li><img src="https://img.shiqi-lu.tech/20210213182055.png"></li>
<li>目前该程序同一时刻只能服务于一个客户端</li>
</ul>
</li>
<li>Q:迭代回升服务器端/客户端程序(不完美版本)<ul>
<li>服务端echo_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端套接字若调用close函数，这一个循环条件变成假</span></span><br><span class="line">        <span class="keyword">while</span> ((str_len = read(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>) &#123;</span><br><span class="line">            write(clnt_sock, message, str_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对套接字调用close函数，向连接的相应套接字发送EOF</span></span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端echo_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connceted........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = read(sock, message, BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">        message[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<ul>
<li>服务端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc echo_server.c -o eserver</span><br><span class="line">shiqi@inspiron:~/network$ ./eserver 9190</span><br><span class="line">Connected client 1</span><br><span class="line">Connected client 2</span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shiqi@inspiron:~/network$ gcc echo_client.c -o eclient</span><br><span class="line">shiqi@inspiron:~/network$ ./eclient 127.0.0.1 9190</span><br><span class="line">Connceted........</span><br><span class="line">Input message(Q to quit): Hi</span><br><span class="line">Message from server: Hi</span><br><span class="line">Input message(Q to quit): cd</span><br><span class="line">Message from server: cd</span><br><span class="line">Input message(Q to quit): q</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>存在问题<ul>
<li>在客户端的代码中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">str_len = read(sock, message, BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">message[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br></pre></td></tr></table></figure></li>
<li>以上代码有个错误的假设「每次调用 read、write函数时都会以字符串为单位执行实际 I/O 操作」</li>
<li>注意「TCP不存在数据边界」，上述客户端是基于 TCP 的，因此多次调用 write 函数传递的字符串有可能一次性传递到服务端。此时客户端有可能从服务端收到多个字符串。即需要考虑服务端「字符串太长，需要分2个数据包发送」</li>
<li>服务端希望通过调用 1 次 write 函数传输数据，但是如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端可能在尚未收到全部数据包时就调用 read 函数</li>
<li>以上的问题都是源自 TCP 的传输特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第-5-章-基于-TCP-的服务端-客户端（2）"><a href="#第-5-章-基于-TCP-的服务端-客户端（2）" class="headerlink" title="第 5 章 基于 TCP 的服务端/客户端（2）"></a>第 5 章 基于 TCP 的服务端/客户端（2）</h1><h2 id="5-1-回声客户端的完美实现"><a href="#5-1-回声客户端的完美实现" class="headerlink" title="5.1 回声客户端的完美实现"></a>5.1 回声客户端的完美实现</h2><ul>
<li><p>Q:回声客户端的完美实现</p>
<ul>
<li>因可提前确定接收数据的大小，使用循环控制即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> str_len, recv_len, recv_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connceted........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str_len = write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        recv_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (recv_len &lt; str_len) &#123;</span><br><span class="line">            recv_cnt = read(sock, message, BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (recv_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">                error_handling(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            recv_len += recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        message[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Q:计算器服务端客户端实现</p>
<ul>
<li><img src="https://img.shiqi-lu.tech/20210811145456.png"></li>
<li>客户端 op_client.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RLT_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPSZ 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">char</span> opmsg[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> result, opnd_cnt, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock,</span><br><span class="line">                (struct sockaddr *)&amp;serv_adr,</span><br><span class="line">                <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operand count: &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opnd_cnt);</span><br><span class="line">    opmsg[<span class="number">0</span>] = (<span class="keyword">char</span>)opnd_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opnd_cnt; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Operand %d: &quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">int</span>*)&amp;opmsg[i*OPSZ+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operator:&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;opmsg[opnd_cnt*OPSZ+<span class="number">1</span>]);</span><br><span class="line">    write(sock, opmsg, opnd_cnt*OPSZ+<span class="number">2</span>);</span><br><span class="line">    read(sock, &amp;result, RLT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Operation result: %d\n&quot;</span>, result);</span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>服务端 op_server.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPSZ 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> opnum, <span class="keyword">int</span> opnds[], <span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = opnds[<span class="number">0</span>], i;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; ++i) &#123;</span><br><span class="line">                result += opnds[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; ++i) &#123;</span><br><span class="line">                result -= opnds[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; ++i) &#123;</span><br><span class="line">                result *= opnds[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">char</span> opinfo[BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> result, opnd_cnt, i;</span><br><span class="line">    <span class="keyword">int</span> recv_cnt, recv_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock,</span><br><span class="line">             (struct sockaddr*)&amp;serv_adr,</span><br><span class="line">             <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        opnd_cnt = <span class="number">0</span>;</span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp; clnt_adr_sz);</span><br><span class="line">        read(clnt_sock, &amp;opnd_cnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        recv_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((opnd_cnt*OPSZ+<span class="number">1</span>) &gt; recv_len) &#123;</span><br><span class="line">            recv_cnt = read(clnt_sock, &amp;opinfo[recv_len], BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">            recv_len += recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        result = calculate(opnd_cnt, (<span class="keyword">int</span> *)opinfo, opinfo[recv_len<span class="number">-1</span>]);</span><br><span class="line">        write(clnt_sock, (<span class="keyword">char</span> *)&amp;result, <span class="keyword">sizeof</span>(result));</span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">47@pc:~/network/ch05$ gcc op_server.c -o serv</span><br><span class="line">47@pc:~/network/ch05$ ./serv 9190</span><br><span class="line"></span><br><span class="line">47@pc:~/network/ch05$ gcc op_client.c -o clnt</span><br><span class="line">47@pc:~/network/ch05$ ./clnt 127.0.0.1 9190</span><br><span class="line">Connected....</span><br><span class="line">Operand count: 3</span><br><span class="line">Operand 1: 8</span><br><span class="line">Operand 2: 9</span><br><span class="line">Operand 3: 10</span><br><span class="line">Operator:*</span><br><span class="line">Operation result: 720</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸语法10-12课</title>
    <url>/gramma10-12/</url>
    <content><![CDATA[<h1 id="10-如何构建长难句的主语和宾语"><a href="#10-如何构建长难句的主语和宾语" class="headerlink" title="10.如何构建长难句的主语和宾语"></a>10.如何构建长难句的主语和宾语</h1><h2 id="动名词短语是什么"><a href="#动名词短语是什么" class="headerlink" title="动名词短语是什么"></a>动名词短语是什么</h2><ul>
<li>动名词短语相当于名称从句里边的that从句的化简。任何一个that从句，都可以用动名词短语代替。动名词具有名词的性质。所以，名词能作什么，动名词就能作什么</li>
<li>Many people pretend that they understand modern art. = Many people pretend understanding modern art.</li>
</ul>
<h2 id="动名词作主语"><a href="#动名词作主语" class="headerlink" title="动名词作主语"></a>动名词作主语</h2><ul>
<li>举例<ul>
<li>Working 12 hours a day exhausts me completely. 每天工作12小时让我筋疲力尽。(动名词具有名词的特征，在没有特指是谁发出这个动作的情况下，可以不考虑其逻辑主语，因为在语境中一眼就能看出是谁发出的动作，比如本句话，主语working 12 hours a day当然是句中的“我”发出的动作)。本句如果改成主语从句，那就是: That I work 12 hours a day exhausts me completely. 但是这里用主语从句，远远不如用动名词短语作主语简洁明了。</li>
<li>Playing football is my favorite sport.踢足球是我最喜欢的运动。</li>
</ul>
</li>
<li>动名词作主语时，和名词从句一样，也可用形式主语It取代，然后将动名词放在句子主干之后（尤其是动名词比较长时）<ul>
<li>It was no use pretending that I had not seen him, so I waved to him. 若再装作没看见他已是没有用了，我只好向他招手。</li>
</ul>
</li>
<li>注:动名词短语作主语时，一律视为第三人称单数！但and连接的两个动名词短语作主语时，视为复数。<ul>
<li>Singing with you guys is a lot of fun. 和你们一伙人唱歌很有趣。</li>
<li>Learning English and listening to music are my hobbies. 学英语和唱歌时我的爱好。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.慢跑是保持健康的好方法。<ul>
<li>1.Jogging is a good way to stay health/fit.</li>
</ul>
</li>
<li>2.与你共事一直以来都是愉快的经历。(用完成进行态)<ul>
<li>2.Working with you has been a pleasant experience. / It has been a pleasant experience to work with you.</li>
</ul>
</li>
<li>3.说是一回事，做又是另一回事。<ul>
<li>3.Saying is one thing; doing is another.</li>
</ul>
</li>
<li>4.出国旅游有助于增长你的见识。<ul>
<li>4.Travelling abroad helps broaden your horizons. / lt helps to broaden your horizons to travelling abroad.</li>
</ul>
</li>
<li>5.做家务和照顾我们的小孩是我老婆每天要做的事。<ul>
<li>5.Doing the housework and taking care of our children are what my wife does every day.</li>
</ul>
</li>
<li>6.学而不思则罔，思而不学则殆。<ul>
<li>6.Learning without thinking is useless; thinking without learning is dangerous.</li>
</ul>
</li>
<li>7.相信自己是成功的秘诀!<ul>
<li>7.Believing in yourself is the secret of success.</li>
</ul>
</li>
<li>8.拥有知己本身就是一种幸福。<ul>
<li>8.Having intimate friends is happiness in itself.</li>
</ul>
</li>
<li>9.取胜并不重要，但努力去赢得胜利却是重要的。<ul>
<li>9.Winning is not everything, but trying to win is everything.</li>
</ul>
</li>
<li>10.拥有目标是一种幸福的状态。<ul>
<li>10.Having a goal is a state of happiness.</li>
</ul>
</li>
<li>11.牛奶已撒，哭也没用。<ul>
<li>11.It is no use crying over spilt milk.</li>
</ul>
</li>
<li>12.光学习不实践是没用的。<ul>
<li>12.lt is no use learning without practice.</li>
</ul>
</li>
<li>13.从事自己喜欢的事情没用，你必须喜欢自己从事的事情。<ul>
<li>13.lt is no use doing what you like; you have got to like what you do.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动名词作宾语"><a href="#动名词作宾语" class="headerlink" title="动名词作宾语"></a>动名词作宾语</h2><ul>
<li>作及物动词的宾语<ul>
<li>I love traveling in the country, but I don’t like losing my way. 我喜欢在乡间旅行，但却不愿意迷路。翻译成宾语从句是I love that I travel in the country….</li>
<li>Losers avoid becoming self-responsible. 失败者逃避为自己负责。</li>
</ul>
</li>
<li>作介词的宾语<ul>
<li>My friends kept on offering me cigarettes and cigars. 我的朋友们不断地向我递香烟和雪茄。(on和后面的动名词短语一起，作kept的宾语)</li>
<li>Some children can cover the whole length of the pool without coming up for breath even once. 有些孩子能够跑完游泳池的全长而不用露出水面换气。</li>
</ul>
</li>
<li>有些动词只能跟动名词而不能跟不定式作宾语<ul>
<li>懂得欣赏，克制想象：understand, appreciate(也可作”感激“之意), deny(也可作否认，拒绝), imagine</li>
<li>喜欢实践，逃避抵抗：enjoy, practice, avoid, escape</li>
<li>介意打扰，讨厌原谅：mind, excuse, dislike/hate, pardon</li>
<li>支持建议，推迟考虑：favor(也可作赞成，宠爱), suggest, delay/postpone, consider</li>
<li>错过盼望，完成冒险：miss, look forward to, finish, risk</li>
</ul>
</li>
<li>含有介词to的介词短语，也是动名词作宾语<ul>
<li>look forward to: 期待</li>
<li>object to: 反对</li>
<li>be/get used to: 习惯于，注意和used to不一样，I used to love movie.我曾经很喜欢电影。跟I am used to playing basketball.我习惯了打篮球。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.大多数小朋友喜欢看卡通。<ul>
<li>1.Most children enjoy watching cartoons.</li>
</ul>
</li>
<li>2.很多大学毕业生正考虑在寻找工作前先去度个假。<ul>
<li>2.A lot of college graduates are considering taking a vacation before their job hunting.</li>
</ul>
</li>
<li>3.我每晚睡前都练习弹钢琴一个小时 。<ul>
<li>3.I practice playing the piano for an hour before I go to bed every night.</li>
</ul>
</li>
<li>4.你能想象被困在交通阻塞中超过3小时吗?<ul>
<li>4.Can you imagine being caught in traffic jam for over three hours?</li>
</ul>
</li>
<li>5.我盼望不久再见到您。再见。<ul>
<li>5.I look forward to seeing you again soon. Goodbye.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动名词做表语"><a href="#动名词做表语" class="headerlink" title="动名词做表语"></a>动名词做表语</h2><ul>
<li>The subject of life is making choices. 人生的课题就是做选择。</li>
<li>Courage is doing what you’ re afraid to do. 勇气就是去做自己害怕做的事情。</li>
</ul>
<h2 id="动名词做同位语（较少见）"><a href="#动名词做同位语（较少见）" class="headerlink" title="动名词做同位语（较少见）"></a>动名词做同位语（较少见）</h2><ul>
<li>Many people admire his special ability, learning three languages at the same time.很多人都美慕他的特殊能力:同时学习3种语言。</li>
<li>My hobby swimming dates from my childhood.我的业余爱好游泳源于我的童年。</li>
</ul>
<h2 id="动名词短语的逻辑主语——所有格-动名词"><a href="#动名词短语的逻辑主语——所有格-动名词" class="headerlink" title="动名词短语的逻辑主语——所有格+动名词"></a>动名词短语的逻辑主语——所有格+动名词</h2><ul>
<li>概述<ul>
<li>I remember <code>that he promised to help these poor students.</code></li>
<li>本句如果改成: I remember <code>promising to help these poor students.</code> 那就是一个错句子。因为promising这个动名词，在这样的语境中，会被默认为是主语“我”发出的动作。但是显然和句意不符合。</li>
<li>这时候，我们就要给动名词加上逻辑主语，原则上，如果主语是代词，通常用所有格，但是如果主语是名词，则用所有格和普通格都正确。</li>
</ul>
</li>
<li>注：美国英语中，可以使用主格（动名词作主语），或宾格（动名词作宾语）代替所有格<ul>
<li><code>His not finishing</code> the work disappointed me. 他未能准时完成工作让我失望</li>
<li>Would you mind <code>my coming</code> with you? 我跟你一道去行吗?</li>
<li>Excuse <code>my interrupting you</code>. 请原谅我打断了您。</li>
<li>上述3个例句可改为:</li>
<li>He not finishing the work disappointed me.</li>
<li>Would you mind me coming with you?</li>
<li>Excuse me interrupting you.</li>
</ul>
</li>
<li>下列情况即使在正式文体中，动名词的逻辑主语也习惯使用普通格：<ul>
<li>1.逻辑主语为名词指物<ul>
<li>The children are looking forward to spring coming.</li>
</ul>
</li>
<li>2.逻辑主语为多个名词<ul>
<li>Do you remember Mary and her mother coming to see us last June?</li>
</ul>
</li>
<li>3.逻辑主语为以”s”结尾的名词<ul>
<li>It’s a disaster the bosses shutting all those factories.</li>
</ul>
</li>
<li>4.逻辑主语与动名词分离<ul>
<li>I remember mother once telling us a story about the fox.</li>
</ul>
</li>
<li>5.逻辑主语为不定代词，如:someone, everything, something;<ul>
<li>They complained about everything going wrong.</li>
</ul>
</li>
</ul>
</li>
<li>注意特殊句型<ul>
<li>Would/Do you mind + V-ing？你介意…吗？<ul>
<li>Would you mind <code>my opening</code> the window? It’ s very hot in here. 你介意我打开窗户吗?这里太热了!</li>
<li>Do you mind <code>handing</code> me that book? 介意把那本书给我吗?</li>
</ul>
</li>
<li>Would/Do you mind + if + 句子？ <ul>
<li>Do you mind if… （真实语气：一般现在时）<ul>
<li>Do you mind if I <code>smoke</code> here?</li>
</ul>
</li>
<li>Would you mind if… (虚拟语气：一般过去时)<ul>
<li>Would you mind if I <code>smoked</code> here?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我记得他曾经承诺，一旦我们遇到麻烦(get into trouble)他就会来帮助我们。<ul>
<li>1.I remember his/him once promising to help us if we got into trouble.</li>
</ul>
</li>
<li>2.你介意我提一个建议吗?<ul>
<li>2.Would you mind my/me making a suggestion.</li>
</ul>
</li>
<li>3.老师拒绝接受我的建议让我很恼火。<ul>
<li>3.My teacher’s refusing to accept my suggestion upset me.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动名词短语的时态和语态变化"><a href="#动名词短语的时态和语态变化" class="headerlink" title="动名词短语的时态和语态变化"></a>动名词短语的时态和语态变化</h2><ul>
<li>动名词短语和分词短语完全一样，没有“时”的变化，只有“态”的变化，而且同样只有<code>一般态</code>和<code>完成态</code>。同样，和分词短语一样，动名词的两种态，均有<code>主动语态</code>和<code>被动语态</code>两种语态</li>
<li>当动名词的动作和主句主语同时发生，用一般态。如果是表示被动的含义，要用被动语态。注意：动名词短语如果是being，任何时候都不能省略<ul>
<li>No one can avoid <code>being influenced</code> by advertisements.没有人能避免受广告的影响。(一般态，被动语态)</li>
<li>Everyone appreciates <code>being appreciated.</code>每个人都喜欢得到赞赏。(一 般态，被动语态)</li>
<li>There is only one thing in the world worse than <code>being talked about</code>, and that is not being talked about. 世界上比被人议论更糟糕的一件事，就是根本没人去议论。(王尔德名言 )</li>
<li><code>Being</code> deeply <code>loved</code> by someone gives you strength, while <code>loving</code> someone deeply gives you courage. 人爱者有力，爱人者勇。(老子)</li>
</ul>
</li>
<li>当动名词的动作，发生在主句动作之前时，要用完成态。（但动名词短语具有名词性质，时态要求没有分词那么严格，此时用一般态也不算错误）<ul>
<li>No good thing can be enjoyed by us, without <code>having cost</code> labor. 不付出辛劳，我们就不能享受任何美好的事物。(完成态，主动语态)。本句如果用No good thing can be enjoyed by us, without <code>costing</code> labor.也不算错误，但是用完成态更好，因为是先劳动，再享受。</li>
<li>I appreciate <code>having been given</code> the opportunity to study abroad two years ago.我很感激两年前得到一次出国留学的机会。(完成态，被动语态)</li>
</ul>
</li>
<li>两个短语为固定搭配，虽说是主动的形式，但表达被动的含义<ul>
<li>sth. need doing: 某事需要被做<ul>
<li>The classroom is so dirty that it <code>needs cleaning</code> thoroughly. 教室很脏，需要彻底清洁。</li>
</ul>
</li>
<li>sth. be worth doing: 某事值得被做<ul>
<li>By this time, a Lancaster bomber in reasonable condition <code>was worth rescuing.</code> 这个时候，一架状态良好的lancaster轰炸机是值得拯救的。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.这台电视机开关的声音在大街上都能被听到。<ul>
<li>1.The noise of the television being opened and closed can be heard in the street.</li>
</ul>
</li>
<li>2.我一直后悔上学时没有更加努力的学习。<ul>
<li>2.I have always regretted not having studied harder at school.</li>
</ul>
</li>
<li>3.墙角处的那个人承认对这家公司的经理撒了谎(tell a lie)。<ul>
<li>3.The man in the corner confessed to having told a lie to the manager of company.</li>
</ul>
</li>
<li>4.马克每次违反交通规则(break traffic regulation)以后都常常试图逃避被罚款。<ul>
<li>4.Mark often attempts to escape being fined whenever he breaks traffic regulations.</li>
</ul>
</li>
<li>5.我们的现代文明绝不能被认为(be thought of as)是短期内建立的。<ul>
<li>5.Our modern civilization must not be thought as having been created in a short period of time.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="11-如何正确使用不定式短语"><a href="#11-如何正确使用不定式短语" class="headerlink" title="11.如何正确使用不定式短语"></a>11.如何正确使用不定式短语</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>不定时同时具有和动名词与分词类似的功能。要特别注意，不定时有“逻辑将要”的含义，故其动作发生在前面的动词之后，而且多表达意愿、目的、企图等</li>
</ul>
<h2 id="不定式短语的构成和功能"><a href="#不定式短语的构成和功能" class="headerlink" title="不定式短语的构成和功能"></a>不定式短语的构成和功能</h2><ul>
<li>1.名词从句的化简：作主语，及物动词的宾语，表语，宾语补语</li>
<li>2.状语从句的化简：作状语</li>
<li>3.定语从句的化简：作定语</li>
</ul>
<h2 id="名词从句的化简"><a href="#名词从句的化简" class="headerlink" title="名词从句的化简"></a>名词从句的化简</h2><ul>
<li>作主语<ul>
<li>概述<ul>
<li>To make large sums of money is my dream. 挣大钱是我的梦想。(相当于That I wilI make large sums of money is my dream)</li>
<li>注意:如果本句用Making large sums of money is my dream. 也对，但是用不定式暗示“我要去挣钱”，但目前还没有挣到钱。现代英语中，不定式和动名词作主语一般可通用。</li>
</ul>
</li>
<li>不定式作主语时，可用形式主语It取代，然后将不定式放在句子主干之后<ul>
<li>It was his job to repair bicycles and at that time he used to work fourteen hours a day.他那时的工作是修理自行车，并且通常是一天工作14个小时。(相当于It was his job that he repaired bicycles…)</li>
<li>So, it comes as a surprise to learn that giant fish are terrifying the divers on North Sea oil rigs. 因此，听说北海石油钻井平台上的潜水员受到巨型鱼类的恐吓，确实很让人吃惊。(相当于it comes as a surprise that we learn giant fish ….)</li>
</ul>
</li>
<li>和动名词短语一样，不定式短语作主语时，一律视为第三人称单数！但and连接的两个不定式短语作主语时，视为复数<ul>
<li><code>To become a great scientist</code> is his ultimate goaI. 成为伟大的科学家是他的终极目标。</li>
<li><code>To study</code> and <code>to play</code> are equally important. 学习和玩耍同样重要。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.成为职业篮球选手是我的抱负之一。<ul>
<li>To become a professional basketball player is one of my ambitions. /It is one of my ambitions to become a professional basketball player.</li>
</ul>
</li>
<li>2.精通一门外语需要不断的努力。<ul>
<li>To master a foreign language takes constant effort. /It takes constant effort to master a foreign language.</li>
</ul>
</li>
<li>3.提高我们的生产力是我们今年的主要目标。<ul>
<li>To increase our productivity is our main goal this year. /It is our main goal this year to increase our productivity.</li>
</ul>
</li>
<li>4.对于某些人而言，活着就是受苦。<ul>
<li>For some people, to live is to suffer.</li>
</ul>
</li>
<li>5.一天大笑三次有益健康。<ul>
<li>It is good for your health to laugh three times a day.</li>
</ul>
</li>
<li>6.犯错是人之常情，宽恕则超凡入圣。<ul>
<li>To err is human; to forgive is divine.</li>
</ul>
</li>
<li>7.知道做什么是智慧，知道怎么做是技能。<ul>
<li>To know what to do is wisdom. To know how to do it is skilI.</li>
</ul>
</li>
<li>8.让自己的孩子诚实是教育的开端。<ul>
<li>To make your children capable of honesty is the beginning of education.</li>
</ul>
</li>
<li>9.爱是世界上最美的动词。<ul>
<li>To love is the most beautiful verb in the worId.</li>
</ul>
</li>
<li>10.人生得一知己足矣。<ul>
<li>It is enough to have one close friend in one’ s life.</li>
</ul>
</li>
<li>11.诅咒黑暗不如点亮一支蜡烛。 (临渊羡鱼，不如退而结网)<ul>
<li>It is better to light a candle than to curse the darkness.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>作及物动词的宾语：（绝对不能作介词的宾语）<ul>
<li>attempt企图，choose选择，decide决定，expect期望，hope希望，intend打算，manage设法，offer/volunteer主动提议，plan计划，want要，wish希望，endeavor努力</li>
<li>大部分及物动词，其后即可用不定式，也可用动名词，比如begin doing = begin to do</li>
<li>但是表示“企图”或者“意愿”的及物动词，其宾语是“将要发生的事情”，所以通常只能用不定式作宾语<ul>
<li>Debbie is only eleven years old and she hopes <code>to set up a new world record.</code> 黛比只有11岁，她希望创一项新的世界纪录。(相当于…that she can set up a new world record. )</li>
<li>Last Christmas, the circus owner, Jimmy Gates, decided <code>to take some presents to a children&#39;s hospital.</code> 去年圣诞节，马戏团老板吉米.盖茨决定送些礼物给儿童医院。</li>
<li>It has four Rolls-Royce Merlin engines, but the group will need <code>to have only three of them rebuilt.</code> 该飞机装装配有4台罗尔斯-罗伊斯的默林发动机，但是他们只需要修复其中的3台。(相当于…that they will have only three of them rebuilt. )</li>
<li>The pilot managed <code>to circle the balloon</code> for some time. 飞行员设法绕着气球飞了一阵。</li>
</ul>
</li>
<li>在第四大句型中，不定式作不完全及物动词的宾语时，必须用形式宾语it取代，加上宾语补语之后，再加不定式<ul>
<li>在前面的名词从句部分，学过形式宾语句型：某人 认为 做某事 是怎么样的</li>
<li>比如：我认为每天多喝水很有必要</li>
<li>I think <code>it</code> necessary that I should drink a lot of water.</li>
<li>同样，本句型中，如果宾语是不定式，也要用形式宾语</li>
<li>think, believe, find, deem, consider + it + (to be) + 名词或形容词（补语）+ 不定式（宾语）</li>
<li>其中to be可省略</li>
<li>所以：I think <code>it</code> necessary <code>to drink a lot of water.</code><ul>
<li>I <strong>consider</strong> <code>it</code> a great <code>honor</code> to be invited to dinner. 我认为能被邀请参加晚宴是很大的荣幸。</li>
<li>I <strong>deem</strong> <code>it</code> a great <code>honor</code> to serve you. 我认为为您服务是一项光荣。</li>
<li>A Frenchman, for instance, might <strong>find</strong> <code>it hard</code> to laugh at a Russian joke. 例如，法国人听完一则俄国笑话可能很难发笑。</li>
</ul>
</li>
</ul>
</li>
<li>和名词从句不同，不定式短语还可以和动词make构成宾补句型，用于表示“使某种事情变得怎么样”：make + it + (to be) + 名词或形容词（补语）+ 不定式（宾语）<ul>
<li>The invention of computers has <code>made</code> it <code>possible</code> to free man from the complex labor. 计算机的发明使得人们有可能从繁杂劳动中解放出来。</li>
<li>I <code>made</code> it <code>my  business</code> to know all about them. 我把了解他们作为我的业务。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我主动提议帮玛丽忙，但她拒绝了(turn sb. down)。<ul>
<li>I offered to give Mary a hand, but she turned me down.</li>
</ul>
</li>
<li>2.我们企图说服约翰戒烟，但没有效果。<ul>
<li>We attempted to persuade John to quit smoking, but in vain.</li>
</ul>
</li>
<li>3.我不觉得理解V0A的慢速英语节目有难度。<ul>
<li>I don’t think it difficult to understand the VOA Special English.</li>
</ul>
</li>
<li>4.虽然声音被听得很清楚，但费了我很长时间才作出反应。<ul>
<li>Though the sound could be heard clearly, it took me a long time to react.</li>
</ul>
</li>
</ul>
</li>
<li>有些及物动词，既可以用动名词也可以用不定式作宾语，但是意义不同。要区分很简单：动名词表示已经做过的事情，不定式表示正打算做的事情<ul>
<li>stop doing:停止做某事</li>
<li>stop to do:停下来去做某事</li>
<li>remember doing:记得做过某事</li>
<li>remember to do:记得去做某事</li>
<li>forget doing:忘记做过某事</li>
<li>forget to do:忘记去做某事</li>
</ul>
</li>
</ul>
</li>
<li>作表语（名词性）<ul>
<li>概述<ul>
<li>The only way to do this was <code>to operate.</code> 搞清的唯一办法就是手术。</li>
<li>My hope is <code>to become a scientist</code> like Einstein. 我的希望就是做一个像爱因斯坦那样的科学家。</li>
</ul>
</li>
<li>主语是人的时候，不定式作表语表示一定会发生的情况（计划，命令，肯定推测等）<ul>
<li>I <code>am to</code> realize the goal of life. 我一定要实现人生的目标。(肯定推测)</li>
<li>You <code>are to</code> be back by 10 o’ clock. 你必须十点以前回来。(命令)</li>
<li>You <code>are not to</code> smoke in the reading-room. 你不能在阅读室吸烟。(用于否定句表示“禁止”)</li>
</ul>
</li>
<li>特征动词的表语，通常用不定式（to be可省略）：seem似乎是，appear看起来是，prove被证明是，turn out结果是<ul>
<li>The majority of people <strong>seem</strong> <code>to prefer TV to radio.</code> 多数人喜欢电视胜过广播。</li>
<li>These birds <strong>seem</strong> <code>unaffected</code> by climate.这些鸟似乎不受气候的影响。</li>
<li>He <strong>appears</strong> <code>a perfectly normaI person.</code> 他看上去是一个完全正常的人。</li>
<li>The search <strong>proved</strong> <code>difficult.</code> 这次搜索被证明是很困难的。</li>
<li>He <strong>turned out</strong>  <code>to be right.</code> 结果他是对的。</li>
<li>Babies of two months old do not <strong>appear</strong> <code>to be reluctant</code> to enter the water. 两个月的婴儿并未显得不愿意入水。</li>
<li>By this time, a Lancaster bomber in reasonable condition <strong>was worth rescuing.</strong> 这个时候，一架状态良好的lancaster轰炸机是值得拯救的。</li>
<li>The operation, which lasted for over four hours, <strong>proved</strong> <code>to be very difficult</code> because of the hard resin which covered the skin. 手术持续了4个多小时，非常难做，因为皮肤上覆盖着一层硬硬的树脂。</li>
</ul>
</li>
</ul>
</li>
<li>作宾语补语 或 被动语态的主语补语：此时不定式如果是to be，可以省略<ul>
<li>She wanted him <code>to repair their son&#39;s bicycle!</code> 她叫他去修理孙子的自行车。</li>
<li>When it was eventually brought to shore, it was found <code>to be over thirteen feet long.</code> 当终于把它弄上岸后，人们发现它身长超过了13英尺。(本句中to be可省略)</li>
</ul>
</li>
<li>作同位语<ul>
<li>My plan <code>to visit the town</code> was refused. 我的参观小镇这个计划被拒绝了。</li>
<li>(相当于同位语从句My plan <code>that I will visit the town</code> was refused. )</li>
</ul>
</li>
<li>疑问词+不定式：构成名词短语，用法和名词相同<ul>
<li>I was just wondering <code>how to spend the morning.</code> 我正不知道怎么消磨这一上午呢。</li>
<li>(相当于宾语从句I was just wondering ^how I would spend the morning.` )</li>
</ul>
</li>
</ul>
<h2 id="状语从句的简化（目的，结果）"><a href="#状语从句的简化（目的，结果）" class="headerlink" title="状语从句的简化（目的，结果）"></a>状语从句的简化（目的，结果）</h2><ul>
<li>概述<ul>
<li>分词短语作状语，可以表示伴随，时间，原因，结果，目的，方式，让步，条件。但是不定式状语只能表目的和结果</li>
</ul>
</li>
<li>作目的状语<ul>
<li>Fifteen policemen had to push very hard <code>to get him off the main street.</code> 15个警察不得不用很大的力气把它推离主要街道。(相当于目的状语从句… that they could get him off…)</li>
<li>When the bull got close to him, he clumsily stepped aside <code>to let it pass.</code> 当公牛逼近他时，他踉跄地住旁边一闪，牛扑空了。(相当于目的状语从句….so that he could let it pass. 由于let是不完全及物动词，故此不定式短语类似第四大句型，it是不定式to let的宾语，pass是宾语补语. )</li>
<li>It was not long before a helicopter arrived on the scene <code>to rescue the survivors of the plane crash.</code> 不久，一架直升飞机飞抵飞机失事现场，来搭救这几个幸存者。(相当于目的状语从句…so that it could rescue…)</li>
<li>Specially-made lanterns are hung outside each house <code>to help the dead to find their way.</code> 特制的灯笼挂在各家的门外，为的是帮助亡灵看清道路。(相当于 目的状语从句…. that they could help the dead..由于heIp是不完全及物动词，故此不定式短语类似第四大句型)</li>
</ul>
</li>
<li>有时候为了强调目的状语，可以将不定式放在句首<ul>
<li><code>To acquire knowledge,</code> one must study; but <code>to acquire wisdom,</code> one must observe. 要想获得知识，就必须学习，但是要想获得智慧，就必须学会观察。</li>
<li><code>To be really happy and really safe,</code> one ought to have at least two or three hobbies, and they must alI be real. 要想真正幸福和平安，一个人至少应该有两三种业余爱好，而且必须是真正的爱好。</li>
</ul>
</li>
<li>作结果状语（不定式表示意料之外的结果，而分词短语表示意料之中的结果）<ul>
<li>Farm laborers said that they always woke up <code>to find the work had been done</code> overnight. 农场工们说，常常一早起来却发现有人在夜里把活干了。(意料之外)</li>
<li>The small company has beaten other big companies, <code>to win the title</code> of best business-class service. 这个小航空公司击败了其他大公司从而赢得了最佳商务舱服务奖。(意料之外)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.憎恨别人，犹如为了除掉一只老鼠而烧掉自己的房子。<ul>
<li>Hating people is like burning down your own house to get rid of a rat.</li>
</ul>
</li>
<li>2.为了赢得这个奖，你应该很努力地奋斗。<ul>
<li>To win the award, you should work very hard.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定语从句的化简"><a href="#定语从句的化简" class="headerlink" title="定语从句的化简"></a>定语从句的化简</h2><ul>
<li>关系代词作主语引导的定语从句化简（修饰的名词被绝对性形容词修饰的时候）<ul>
<li>I have <code>no</code> friend <code>to advise me.</code> 我没有可以给我忠告的朋友。(相当于I have no friend <code>who can advise me.</code> ) (因为本句中有绝对性形容词no，所以用不定式作定语，而不用分词)</li>
<li>He was the <code>first</code> person <code>to greet me</code> when I arrived there.当我到那儿的时候，他是第一个来迎接我的人。(因为本句中有绝对性形容词first,所以用不定式作定语，而不用分词)</li>
</ul>
</li>
<li>关系代词作宾语引导的定语从句化简。(通常表示“有某事要做”)<ul>
<li>I will write a letter. 我要写一封信。</li>
<li>I have a letter to write. 我有一封信要写。</li>
<li>这两句话中文意思其实是一样的，英文意思也是一样的。此时，不定式to write作定语，修饰名词letter, 但是一定要注意，这里的不定式动词write是及物动词!!! 其修饰的名词letter就是不定式的逻辑宾语! !</li>
<li>He never has anything to do.他从来都是无事可做。(相当于He never has anything <code>that he can do.</code> )</li>
<li>注意:此时的不定式必须是及物动词或者及物动词短语。</li>
<li>请看这个句子: He is a nice man <code>to work.</code> (X)</li>
<li>这个句子中，work是不及物动词，自然不能接宾语man, 所以，必须改为: He is a nice man <code>to work with.</code> 他人不错，可以与他共事。</li>
</ul>
</li>
<li>关系副词引导的定语从句化简：此时不定式短语必须是<code>不及物动词</code>，或者<code>及物动词+宾语</code><ul>
<li>The time <code>to go</code> is July. (不及物动词go) 应该在7月份去。(相当于The time <code>when we should go</code> is July. )</li>
<li>It is time <code>to draw a conclusion.</code> (及物动词draw+宾语conclusion) 到下结论的时间了。</li>
<li>A good place <code>to eat food</code> is the Sichuan restaurant around the corner. 一个吃饭的好地方就是拐角的那家川菜馆。(相当于A good place where we can eat …)</li>
<li>The only way <code>to do this</code> was to operate. 搞清的唯一办法就是手术。(相当于The only way <code>in which they can do this</code>…)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我有一封信要写。<ul>
<li>I have a letter to write.</li>
</ul>
</li>
<li>2.他是做最后决定的最佳人选。<ul>
<li>He is the best man to make the final choice.</li>
</ul>
</li>
<li>3.在天黑前，我们还有很长的路要走。<ul>
<li>We had a long journey to make before nightfall.</li>
</ul>
</li>
<li>4.她有四个孩子要照顾。<ul>
<li>She has four children to take care of.</li>
</ul>
</li>
<li>5.下一列到达的火车是从纽约开过来的。<ul>
<li>The next train to arrive is from New York.</li>
</ul>
</li>
<li>6.克林顿是这次空难中唯一的幸存者。<ul>
<li>Clinton is the only person to survive the air crash.</li>
</ul>
</li>
<li>7.角色扮演(role playing)是一种有效而且自得其乐的英语学习方法。<ul>
<li>Role playing is an effective and enjoyable way to learn English. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="不定式的逻辑主语"><a href="#不定式的逻辑主语" class="headerlink" title="不定式的逻辑主语"></a>不定式的逻辑主语</h2><ul>
<li>当不定式的逻辑主语和句子的主语不一致的时候，通常用下面的结构：for + 名词 + 不定式<ul>
<li>He expects <code>for his sister to meet you.</code> 他期望他妹妹认识你。(相当于He expects <code>that his sister can meet you.</code> )</li>
<li>There is no need <code>for you to go. </code> 你没有必要去。</li>
<li>Dentists always ask questions when it is impossible <code>for you to answer.</code> 牙科医生们总是在你无法作出回答的时候向你提出问题。</li>
<li>Chinese parents wanted their children to be successful, while American parents expressed a desire <code>for their children to be happy.</code> 中国的父母希望孩子成功，而美国的父母表达了他们的愿望，那就是希望他们孩子幸福。</li>
</ul>
</li>
<li>表达“对于…来说做某事是怎样的”，通常都可以采用这种不定式带上逻辑主语的结构：It is + 形容词 + for sb. to do sth.<ul>
<li>It is necessary <code>for him to study English every day.</code> 对于他来说，每天学习英语是很有必要的。</li>
</ul>
</li>
<li>代词作不定式的逻辑主语时，用宾格。<ul>
<li>My sister told me that she would love for me to babysit for her. 姐姐告诉我她很想要我帮她照顾小孩</li>
</ul>
</li>
<li>在It is + 形容词 + for sb. to do sth.句型中，表示人物性格的形容词（聪明，善良，粗心，愚蠢。。等）和不定式连用时，要用of代替for<ul>
<li>It’s wise <code>of you</code> not to argue with your boss. 明智的做法是不和你的老板争吵。</li>
<li>It was very careless <code>of him</code> to make such silly mistakes. 他太粗心了，居然犯了如此愚蠢的错误。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.此刻，我很难表达我的心情。<ul>
<li>It’s very difficult for me to express my feelings at this moment.</li>
</ul>
</li>
<li>2.你有必要亲自去那里一趟。<ul>
<li>It’s necessary for you to go there in person.</li>
</ul>
</li>
<li>3.他很慷慨，把它的车借给了我。<ul>
<li>It’s generous of him to lend me his car.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="不定式短语的时态和语态变化"><a href="#不定式短语的时态和语态变化" class="headerlink" title="不定式短语的时态和语态变化"></a>不定式短语的时态和语态变化</h2><ul>
<li>不定式短语没有“时”的变化，只有“态”的变化<ul>
<li>不定式的4态构成非常简单，就是to+4态</li>
<li>而不定式的被动语态，就是to+4态的被动语态(但进行态和完成进行态很少用于被动语态)。</li>
<li>以动词do为例:</li>
<li><img src="https://img.shiqi-lu.tech/20201117145336.png"></li>
<li>He wanted some photographs <code>to be taken</code> when he visited Taiwan. 他在台湾参观的时候想找人拍几张照片。(一般态，被动语态)</li>
</ul>
</li>
<li>不定式的完成态，表示不定式的动作发生在谓语动作之前<ul>
<li>Fisherman and sailors sometimes claim <code>to have seen</code> monsters in the sea. 渔夫和水手们有时声称自己看到过海里的妖怪。(完成态，主动语态)</li>
<li>This building was said <code>to have been built</code> from their own designs.这据说是他们自行设计建造的。(完成态， 被动语态)</li>
</ul>
</li>
<li>常见固定搭配<ul>
<li>claim to do: 宣称</li>
<li>be said to do: 据说</li>
<li>be supposed/thought/expected to do: 应该<ul>
<li>Everyone went to the funeral, for the ‘ghost’ was none other than Eric Cox, a third brother who <code>was supposed to have died</code> as a young man. 大家都去参加了葬礼，因为那“鬼”不是别人，正是农场主的兄弟埃里克.考科斯。人们以为埃里克年轻时就死了。</li>
<li>When I was a boy, my grandfather told me how a German taxi driver, Franz Bussman, found a brother who was thought <code>to have been killed</code> twenty years before. 当我是个孩子的时候，我祖父给我讲了一位德国出租汽车司机弗朗兹.巴斯曼如何找到了据信已在20年前死去的兄弟的事。</li>
</ul>
</li>
<li>seem/appear: 似乎</li>
</ul>
</li>
<li>不定式的进行态，表示不定式的动作与谓语动作同时发生。（不定式进行态不常用，通常只用于seem/appear, happen等动词之后），表达“似乎正在做某事”，“碰巧正在做某事”等等<ul>
<li>A pilot noticed a balloon which seemed <code>to be making for</code> a Royal Air Force Station nearby. 一个飞行员发现了一只气球，它像是正飞往附近的一个皇家空军基地。</li>
</ul>
</li>
<li>不定式的完成进行态，是完成态的延续动词用法（少见）<ul>
<li>The are said to have been collecting stamps.</li>
<li>The are said to have collected stamps.</li>
<li>据说他们一直在收集邮票。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.他想要找人立刻把这些信打印出来。<ul>
<li>He wanted the letters to be typed at once.</li>
</ul>
</li>
<li>2.我很抱歉在这个时候还用这么多问题来打扰你。<ul>
<li>I’m sorry to have bothered you with so many questions on such an occasion.</li>
</ul>
</li>
<li>3.她妈妈走进来的时候，他假装正在睡觉。<ul>
<li>He pretended to be sleeping when his mother came in. </li>
</ul>
</li>
<li>4.那个小女孩今晚好像一直在看电视。<ul>
<li>The little girl seems to have been watching TV all this evening.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="12-条件状语从句和虚拟语气"><a href="#12-条件状语从句和虚拟语气" class="headerlink" title="12.条件状语从句和虚拟语气"></a>12.条件状语从句和虚拟语气</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>条件状语从句分为两大类：真实条件状语从句和虚拟语气</li>
<li>请看两句话:</li>
<li>1.如果我明天发了工资,我就请你吃饭。</li>
<li>2.如果明天我彩票中了500万, 我就请你吃饭。</li>
</ul>
<h2 id="真实条件状语从句"><a href="#真实条件状语从句" class="headerlink" title="真实条件状语从句"></a>真实条件状语从句</h2><ul>
<li>if(如果…)：后面可加then，如果then省略了，也隐含在句子的意思里<ul>
<li>表示客观事实，主句用一般现在时或现在进行时，从句用一般现在时(可记忆为”主现从现”)<ul>
<li>If I eat too much, I feel uncomfortable. 如果我吃太多，就会觉得不舒服。(真实的情况，而且主句用的是一般现在时，表示这是客观事实。)</li>
<li>If you can’t beat them, join them. 如果你不能打败他们，就加入他们。(谚语 )</li>
<li>If you drink and drive, you are breaking the law. 如果你酒驾，那你就是在违法了。(真实的情况，而且主句用的现在进行时，加强语气，给人一种生动的感觉)</li>
</ul>
</li>
<li>表示将来可能发生的情况，主句用一般将来时，从句要用一般现在时，此时主句的will表示肯定或很可能发生的事情。（真实的情况，而且主句用的一般将来时，表示这是推测）(可记忆为”主将从现”)<ul>
<li><code>If you park your car in the wrong place,</code> a traffic policeman will soon find it. 一旦你把汽车停错了地方，交通警很快就会发现。</li>
<li>You will be very lucky <code>if he lets you go</code> without a ticket. 如果他没给你罚单就放你走了，算你走运。</li>
<li><code>If she comes,</code> she will get a surprise. 如果她来了，她会感到非常惊奇了。</li>
<li>注:如果主句的肯定程度不是很高，就可以用别的情态助动词代替will。<ul>
<li>Are you successful in language learning? <code>If it is less successful</code>, you should do well to try the above ways. 你在语言学习方面成功吗?如果你不那么成功，你应该好好尝试以上的方法。</li>
<li>If they are not brought to the surface soon they may lose their lives. 如果不把他们尽快救到地面上来，他们就有可能丧生。</li>
<li><code>If the students are interested</code> in sports, they can join different sports clubs. 如果学生对运动感兴趣，他们可以加入不同的运动俱乐部。</li>
</ul>
</li>
</ul>
</li>
<li>如果在条件状语从句中出现了will，不是表示将来时，而是表示意愿<ul>
<li>If I <code>will</code> prepare, my chance will come someday. 如果我愿意准备，总有一天机会将来临。</li>
<li>If a man <code>will</code> not seek knowledge, it will not seek him. 如果一个人不去找知识，知识也不会去找他。</li>
</ul>
</li>
</ul>
</li>
<li>unless(除非。。)：unless引导的条件状语从句，其主句否定句比肯定句更常用<ul>
<li>All dreams are of no value <code>unless they are followed by action.</code> 如果不付诸行动，一切梦想都毫无价值。</li>
<li>I won’t call you, <code>unless something unexpected happens.</code> 除非有意外事情发生，我将不会给你打电话。</li>
</ul>
</li>
<li>其它常用的连接副词<ul>
<li>suppose/supposing (that)<ul>
<li><code>Suppose you make some mistakes</code>, it’s not the end of the world. 假如你犯了一些错误，这并不是世界的末日。</li>
</ul>
</li>
<li>on condition that</li>
<li>so long as/as long as<ul>
<li><code>So long as there&#39;s something to identify,</code> we will give people their money back. 只要有东西可以识别，我们会把钱还给人家的。</li>
<li>My parents don’t mind what job I <code>do as long as I am happy.</code> 我父母不介意我做什么工作，只要我快乐就行。</li>
</ul>
</li>
<li>providing/provided (that)<ul>
<li>We can do whatever we wish to do <code>provided (that)</code> our wish is strong. 如果我们的愿望很强，我们就能做任何我们想做的事情。</li>
</ul>
</li>
<li>assuming<ul>
<li><code>Assuming you are willing to work hard,</code> I see a great future waiting for you. 如果你愿意努力学习，我看到光明的未来在等着你。</li>
</ul>
</li>
<li>once<ul>
<li>You’ll like her <code>once you get to know her.</code> 你一旦了解她，就喜欢她了。</li>
</ul>
</li>
<li>in case<ul>
<li><code>In case you fail</code>, don’t be discouraged. Keep trying. 假如你失败了，不要气馁， 要继续努力。</li>
</ul>
</li>
</ul>
</li>
<li>only if (只有…才)和if only(只要…就)<ul>
<li>He can continue to support himself and his family <code>only if he produces a surplus.</code> 只有生产有了盈余，他才能继续养活自己和家人。</li>
<li><code>Only if</code> I get a job will I have enough money to go to school. 我只有找到了工作才有足够的钱上学。(only if放句首，主句要倒装)</li>
<li>The Almighty has given men arms long enough to reach the stars <code>if only they would put them out.</code> 万能的造物主赋予人类足以够到星辰的手臂，只要人类愿意伸出。</li>
<li>注: only if前可以加上but</li>
<li>I’ll do that, <code>but only if</code> we set a few rules. 我可以干，但我们得定几条规矩。</li>
</ul>
</li>
<li>造句练习 <ul>
<li>1.如果我熬夜(stay up)过半夜，第二天早上起来看起来就很糟。<ul>
<li>1.If I stay up over midnight, I looked awful the tomorrow morning.</li>
</ul>
</li>
<li>2.你如果接受这份昂贵的礼物，就是在受贿了(take a bribe)。<ul>
<li>2.If you accept this expensive gift, you are taking a bribe.</li>
</ul>
</li>
<li>3.如果明天下雨，我们将取消这个活动。<ul>
<li>3.If it rains tomorrow, we will cancel this activity.</li>
</ul>
</li>
<li>4.你们大伙如果形成团队(team up),可能有助 于形成个双赢的(win-win)局 面。<ul>
<li>4.If you guys team up, it may help create a win-win situation.</li>
</ul>
</li>
<li>5.除非你加紧用功，否则你就不能通过考试。<ul>
<li>5.Unless you work harder, you will not pass the examination.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟语气的常规用法"><a href="#虚拟语气的常规用法" class="headerlink" title="虚拟语气的常规用法"></a>虚拟语气的常规用法</h2><ul>
<li>概述<ul>
<li>虚拟语气，就是不可能发生的情况的假设，汉语里边的虚拟语气是通过语境实现的，在英语的虚拟语气则是通过谓语动词的变化实现的</li>
<li>1.就算把整个太平洋的水倒出，也浇不灭我对你爱情的火焰! (暗示:整个太平洋的水能全部倒出来吗?不能!)</li>
<li>2.如果上天再给我一次重来的机会， 我会对那个女孩说3个字我爱你! (暗示:能有重来的机会吗?没有! )</li>
</ul>
</li>
<li>虚拟语气的常规构成<ul>
<li><img src="https://img.shiqi-lu.tech/mweb/16055960586548-2020-11-17.jpg"></li>
</ul>
</li>
<li>现在虚拟<ul>
<li>‘Young man,’ she answered, ‘if you <code>ate</code> more and <code>talked</code> less, we <code>would</code> both enjoy our dinner!’ “年轻人，”她回答说，“如果你多吃点，少说点，我们两个都会吃得好的!”</li>
<li>The tunnel <code>would be</code> well-ventilated if tall chimneys <code>were</code> built above sea-level. 如果再建些伸出海面的高大的烟囱状通风管，隧道就具备了良好的通风条件。</li>
<li>This would solve the problem of ventilation, for if a train <code>entered</code> this tunnel, it <code>would draw</code> in fresh air behind it. 因为如果有列火车开进隧道，它就把新鲜空气随之抽进了隧道。</li>
<li>if they <code>knew</code> how difficult it was to drill through the hard rock, they <code>would lose heart.</code> 如果他们知道了钻透那坚硬的岩石有多么困难，他们会丧失信心的。</li>
</ul>
</li>
<li>注：现在虚拟be动词的过去式用were<ul>
<li>If I were you, I would take the subway. 如果我是你，我会坐地铁。</li>
<li>现在虚拟中的“现在”，不一定是发生在现在的事情，也可能是“常态”，也就是对客观事实的虚拟。比如“如果太阳从西边出来，中国队就能打败巴西队”</li>
</ul>
</li>
<li>将来虚拟：比较少见，只是表达一种可能性<ul>
<li>If Peter should come again, I would throw him out. 如果彼得再来的话，我会把他轰出去。</li>
</ul>
</li>
<li>过去虚拟<ul>
<li>If, at the time, the British <code>had not feared</code> invasion, the tunnel <code>would have been completed.</code> 如果不是因为那时英国人害怕入侵，隧道早已建成了。</li>
<li>If the Houses of Parliament <code>had not been burned down</code> in 1834, the great clock <code>would never have been erected.</code> 如果不是国会大厦在1834年被焚毁的话，这座大钟永远也不会建造。</li>
<li>If there <code>had not been</code> a hard layer of rock beneath the soil, they <code>would have completed</code> the job in a few hours. 如果不是因为土壤下面有一层坚硬的岩石，他们的营救工作仅用几个小时就可以完成了。</li>
</ul>
</li>
<li>补充：if从句中的were, should, had可以放在主语前，同时省略if<ul>
<li>If he were here, I would tell him the truth. = <code>Were</code> he here, I <code>would tell</code> him the truth.</li>
<li>If it should rain, our plan would be spoiled. = <code>Should</code> it rain, our plan <code>would be spoiled.</code></li>
<li>If you had helped me, I could have finished the work on time. = <code>Had</code> you helped me, I <code>could have finished</code> the work on time.</li>
<li>“<code>Should</code> humanity leave Earth to travel across the universe,” she said, concluding her impassioned explanation, “it <code>would be no different from</code> an infant leaving its mother in the middle of a desert!” “人类在宇宙间离开了地球，”她充满激情地说，“就像婴儿在沙漠中离开了母亲!” ——《The wandering earth》Liu Cixin (刘慈欣《流浪地球》)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.如果当时你帮助我的话，我就可以完成任务了。(当时你没有帮助我)<ul>
<li>1.If you had helped me then, I would have accomplished the mission.</li>
</ul>
</li>
<li>2.要是我是你，我会坐地铁去那儿。(可惜我不是你)<ul>
<li>2.If I were you, I would go there by subway.</li>
</ul>
</li>
<li>3.如果我有100万美元，我就会买一套豪华别墅。(可惜我是穷光蛋)<ul>
<li>3.IfI had a million dollars, I would buy a luxury villa.</li>
</ul>
</li>
<li>4.万一火山爆发了，有可能造成一场可怕的灾难。<ul>
<li>4.If the volcano should erupt, it would cause a terrible disaster.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="条件状语从句转化为分词短语"><a href="#条件状语从句转化为分词短语" class="headerlink" title="条件状语从句转化为分词短语"></a>条件状语从句转化为分词短语</h2><ul>
<li>分词短语表条件，单从分词短语本身，是看不出真实和虚拟的，只有从主句的时态才能看出来<ul>
<li><code>Cooked</code> in wine, snails are a great luxury in various parts of the world. 蜗牛加酒烧煮后，便成了世界上许多地方的一道珍奇的名菜。 (因为主句是一般现在时，所以本句的分词短语是真实条件，相当于真实条件状语从句If snails cooked in wine, …)</li>
<li>Weather <code>permitting,</code> we’ll go fishing. 如果天气允许，我们就去钓鱼。(因为主句是一般将来时，所以本句的分词独立主格结构是真实条件，相当于真实条件状语从句If weather permits, we’ll go fishing. )</li>
<li><code>Added to steel</code>, chromium increases the metal’s hardness. 把铬加进钢里，能增加钢的硬度。(相当于真实条件状语从句If chromium is added to steel, it increases the metal’s hardness.)</li>
<li><code>Given more time</code>, I would be able to complete it. 如果多给我一些时间，我就能把它做完。(相当于虚拟条件状语从句If I were given more time, I would be able to complete it.)</li>
<li><code>Given the right kind of training,</code> these teenage soccer players may one day grew the international stars. 如果给予适当形式的训练，这些十几岁的足球运动员有一天会成为国际明星。</li>
</ul>
</li>
</ul>
<h2 id="虚拟语气的特殊用法"><a href="#虚拟语气的特殊用法" class="headerlink" title="虚拟语气的特殊用法"></a>虚拟语气的特殊用法</h2><ul>
<li>与客观真理相反的强烈虚拟语气，从句用were to + 动词原形，主句用过去将来时(would可改为should, might, could)<ul>
<li>If I were to live my life over again, I would have you as my wife. 如果有来生，我一定娶你为妻。</li>
<li>If the sun were to rise in the west, I would marry you. 要想我嫁给你?除非太阳从西边出来。</li>
</ul>
</li>
<li>主观意志动词“建议”，“要求”，“命令”3大类之后的宾语从句，要使用助动词should(可省略)<ul>
<li>建议：suggest, advise, propose<ul>
<li>He <code>suggested</code> that a double railway tunnel <code>(should) be built.</code> 他提议建一条双轨隧道， 这样就解决了通风问题。</li>
</ul>
</li>
<li>要求：demand, require, request, insist<ul>
<li>In life, your goals may <code>require</code> that you <code>(should) try</code> different approaches and persevere. 生活中，你的目标或许要求你尝试不同的方法，然后持之以恒。</li>
</ul>
</li>
<li>命令：order, command</li>
</ul>
</li>
<li>should (ought to) have + 过去分词，表示与过去事实相反的推测，译为“早应，本应该…”<ul>
<li>He <code>should have known</code> that the police would never allow this sort of thing. 他本该知道警察绝不会允许这类事情发生。</li>
<li>Those who failed to get in need not have felt disappointed as many of the artistes who <code>should have appeared</code> did not come. 那些没能进到场内的人没有必要感到失望，因为很多应该出场的专业演员都没有来。</li>
<li>A policeman approached Jimmy and told him he <code>ought to have</code> gone along a side-street as Jumbo was holding up the traffic. 一个警察走过来告诉吉米，他应该走一条小路，因为江波阻碍了交通。</li>
</ul>
</li>
<li>whether引导的让步状语从句，可用虚拟语气，注：这种句型也可倒装：去掉whether，把be放在从句句首<ul>
<li>Whether it <code>be</code> bird, fish or beast, the porpoise is intrigued with anything that is alive. 海豚对凡是活的东西都感兴趣，不管是鸟、是鱼，还是野兽。也可变成<code>Be</code> bird, fish or beast, the porpoise is intrigued with anything that is alive.</li>
<li>After all, all living creatures live by feeding on something else, whether it <code>be</code> plant or animal, dead or alive. 因为一切生物都靠吃别的东西来活命，不管这种东西是植物还是动物，死的还是活的。</li>
<li><code>Be</code> it a rock or a grain of sand, they sink as the same in water. 无论是岩石还是沙粒，在水中都会沉没。</li>
<li>All students of English, <code>be</code> they native speakers or those who are studying English as a second language, will profit from this book. 所有学习英语的学生都将从本书中受益，不管是把英语作为母语还是第二语言的学生。</li>
</ul>
</li>
<li>wish后面的宾语从句，必须使用虚拟语气<ul>
<li>现在虚拟，用<code>一般过去时</code>。<ul>
<li>I wish he <code>were</code> here. 我真希望他在这儿。</li>
</ul>
</li>
<li>过去虚拟，用<code>过去完成时</code>。<ul>
<li>I wish I <code>had kept</code> faithful to my childhood dreams. 我希望当初信守儿时的梦想。</li>
</ul>
</li>
<li>将来虚拟，用<code>过去将来时</code>。(would 可改为should, might, could)<ul>
<li>I wish you <code>would keep</code> on trying to improve your English. 我希望你继续坚持提高英语水平。</li>
</ul>
</li>
</ul>
</li>
<li>if only用于虚拟，表示“要是…该多好啊”（时态变化同wish）<ul>
<li>If only he <code>were</code> here. 要是他在这儿该多好啊!</li>
<li>If only I <code>had known</code> it earlier. 要是我早点知道这件事该多好啊。</li>
<li>If only I <code>would make</code> a lot of money. 要是我发财该多好啊。</li>
</ul>
</li>
<li>as if/ as though用于虚拟，表示“就像…一样”（时态变化同wish）<ul>
<li>He acted as if he <code>had</code> never <code>lived</code> in England before. 他的举动就好像他从未在英国生活过一样。</li>
<li>I do not turn for protection to dreary cliches about respect of elders – as if mere age <code>were</code> a reason for respect. 我不会用应当尊重长者这一套陈词滥调来为我自己辨护，似乎年长就是受人尊敬的理由。</li>
<li>I felt as if <code>I had stumbled into</code> a nightmare country, as you sometimes do in dreams. 我感到自己就像平时作梦那样迷迷糊糊地闯进了恶梦境地。就像在恶梦里一样。</li>
<li>It looks as if there <code>would be</code> an exciting race across the Channel. 看来会有一场激烈的飞越英吉利海峡的竞争。</li>
</ul>
</li>
<li>would rather / would sooner用于虚拟，表示“宁可….”<ul>
<li>现在和将来虚拟，均用一般过去时<ul>
<li>I would rather you <code>had</code> more health than wealth. 我宁愿你有更多的健康而不是财富。(现在虚拟)</li>
<li>I would rather my father <code>kept</code> his mind and body active after he retires in three years. 我宁愿三年后父亲退休以后能保持身心活跃。(将来虚拟)</li>
</ul>
</li>
<li>过去虚拟，用过去完成时<ul>
<li>I would rather my son <code>had become</code> a doctor, but he became a teacher after graduating. 我宁愿我儿子做一名医生，但是他毕业后当了教师。</li>
</ul>
</li>
</ul>
</li>
<li>lest/in case/for fear的虚拟，表示“以防…”，谓语均要使用should(可省略) + 动词原形<ul>
<li>Weigh well your words <code>lest</code> they <code>(should) be</code> swords. 要斟酌自己的言辞，以防他们伤人。</li>
<li>Take time when time comes, <code>in case</code> it <code>(should) steal</code> away. 时机来临的时候要抓住，以防它偷偷溜走。</li>
<li>We must not promise what we should not, <code>for fear that</code> we (should) be called on to perform what we cannot. 不要许诺不该做的事，以防别人要求我们做我们做不了的事。</li>
</ul>
</li>
<li>what if…? 如果…会怎么样呢？<ul>
<li>What if he doesn’t agree? 如果他不同意该怎么办呢?</li>
<li>But what if your data do not support your hypothesis? Perhaps different experiments are needed. 但是如果你的数据不支持你的假设该怎么办呢?或许需要做不同的实验。( 加州小学3年级科学课本)</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.你若中了一亿美元，你可能会做什么?<ul>
<li>1.If you were to win 100 million dollars, what might you do?</li>
</ul>
</li>
<li>2.如果我五年前遇到她，今天她可能就是我的妻子了。<ul>
<li>2.If I had met her five years ago, she might be my wife today.</li>
</ul>
</li>
<li>3.我建议你把这篇作文撕掉，再从头开始写。<ul>
<li>3.I suggest that you (should) tear up the composition and start over again.</li>
</ul>
</li>
<li>4.我们几个月前就该预见到这一困难。<ul>
<li>4.We should have foreseen the trouble months ago.</li>
</ul>
</li>
<li>5.既然已完成了工作，你本就应该好好休息一下。<ul>
<li>5.You ought to have a good rest now that you’ve finished the work.</li>
</ul>
</li>
<li>6.所有物质，不论是气体、液体、或固体，都是由原子构成的。<ul>
<li>6.All matter, whether it be gas, liquid or solid, is made up of atoms.</li>
</ul>
</li>
<li>7.我希望我能改掉吸烟的习惯。<ul>
<li>7.I wish I could get out of the habit of smoking.</li>
</ul>
</li>
<li>8.我倒希望你当初别把这一切都告诉我。<ul>
<li>8.I wish you hadn’t told me all this.</li>
</ul>
</li>
<li>9.我多么希望你妹妹能在这儿。<ul>
<li>9.I wish your sister were here.</li>
</ul>
</li>
<li>10.太疲倦了。 如果明天能不上班多好。<ul>
<li>10.I am so tired. If only I would take the day off tomorrow.</li>
</ul>
</li>
<li>11.玛丽对着我微笑，仿佛他已经了解我想要什么。<ul>
<li>11.Mary is smiling at me as if she had understood what I want.</li>
</ul>
</li>
<li>12.我们小声说话以免吵醒婴儿。<ul>
<li>12.We talked in a low voice lest we should wake the baby up.</li>
</ul>
</li>
<li>13.我要是没有买这栋房子又会怎么样呢?<ul>
<li>13.What if I have not bought this house?</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸语法7-9课</title>
    <url>/gramma7-9/</url>
    <content><![CDATA[<h1 id="7-把一个句子连接到另一个句子上，变身“大副词”"><a href="#7-把一个句子连接到另一个句子上，变身“大副词”" class="headerlink" title="7.把一个句子连接到另一个句子上，变身“大副词”"></a>7.把一个句子连接到另一个句子上，变身“大副词”</h1><h2 id="时间状语从句：一个句子在另外一个句子里面充当时间状语"><a href="#时间状语从句：一个句子在另外一个句子里面充当时间状语" class="headerlink" title="时间状语从句：一个句子在另外一个句子里面充当时间状语"></a>时间状语从句：一个句子在另外一个句子里面充当时间状语</h2><ul>
<li>当…的时候：<ul>
<li>when…/as…：从句多用一般态，可接短暂动词，也可接延续动词<ul>
<li><code>When</code> he began to play a tune, we had our first glimpse of the snake. 当他开始吹奏一支曲子时，我们才第一次看到那条蛇。</li>
<li>I looked down and nearly fell off the ladder <code>when</code> I saw a policeman. 当我看清是一个警察时，差一点儿从梯子上掉下去。</li>
<li><code>As</code> the thieves were trying to get away in their car, Roy drove his bus into the back of it. 当那两个小偷企图乘车逃跑时，罗伊驾驶他的公共汽车撞在了那辆车的后尾上。</li>
<li><code>As</code> she walked away, I followed her out of the fair. 8当她走开时，我也跟着她出了集市</li>
</ul>
</li>
<li>while…：强调动作进行，从句多用进行态，只能接延续动词<ul>
<li><code>While</code> he was eating, I asked him to lend me twenty pounds. 当他吃饭时，我提出向他借20英镑。</li>
<li><code>While</code> the battered car was moving away, Roy stopped his bus and telephoned the police. 当那辆被撞坏的车开走后，罗伊停下车，给警察挂了电话。</li>
</ul>
</li>
<li>when有时候也有“就在此时”的意思，用以说明前一个分句的时间。这是，when引导的从句必须放在主句后面。<ul>
<li>I had nearly reached the town, <code>when</code> the young man suddenly said, very slowly, ‘Do you speak English?’ 就要到达那个镇时，那青年突然开了口，慢慢地说道: “你会讲英语吗?”</li>
<li>I was almost there <code>when</code> a sarcastic voice below said, ‘I don’t think the windows need cleaning at this time of the night.’ 快要爬到窗口时，下面一个人用讽刺的口吻说:“ 我看不必在夜里这个时候擦窗子吧。”</li>
</ul>
</li>
</ul>
</li>
<li>如果时间状语从句表示将来，一般将来时要改为一般现在时<ul>
<li>I will be a teacher when I grow up. 我长大的时候，要做一个老师。(虽然 “长大”发生在将来，但因为是时间状语从句，所以用一般现在时)</li>
<li>whenever无论何时，每当，是when的强调形式<ul>
<li>Whenever you have an aim, you must sacrifice something of freedom to attain it.每当有了目标，你必须牺牲一定的自由去达到目标</li>
<li>Forgive others whenever you can.得饶人处且饶人。</li>
</ul>
</li>
</ul>
</li>
<li>while既可以用作副词连词，也可以作并列连词<ul>
<li>1.表示“当…时”，while视为副词连词，引导状语从句，此时两个句子通常时态不同。<ul>
<li><code>While</code> two detectives were keeping guard at the door, two others opened the parcel.两个侦探在门口站岗期间，另外两个侦探打开了包裹。(时态不同)</li>
<li>A robot-arm will grab the telescope and hold it <code>while</code> the astronauts make the necessary repairs.当宇航员进行必要的修复工作时，“奋进”号上的一只机器手将抓住望远镜并托住它。(时态不同)</li>
</ul>
</li>
<li>2.表示“而…”，while视为并列连词，连接两个分句，此时两个句子时态相同<ul>
<li>When the plane arrived, some of the detectives were waiting inside the main building <code>while</code> others were waiting on the airfield.当飞机到达时，一些侦探等候在主楼内，另一些侦探则守候在停机坪上。</li>
</ul>
</li>
</ul>
</li>
<li>before/after，通常接短暂动词，但可也接延续动词<ul>
<li><code>After</code> I had left a small village in the south of France, I drove on to the next town. 在离开法国南部的一个小村庄后，我继续驶往下一个城镇。</li>
<li><code>After</code> he has retired, he will devote himself to gardening. 他退休后，将致力于园艺。</li>
<li><code>Before</code> he retired, Frank was the head of very large business company, but as a boy he used to work in a small shop. 在退休前，弗兰克是一家非常大的商业公司的经理，但他小时候却在一家小铺里做工。</li>
</ul>
</li>
<li>before用以说明主句的时间很长，翻译为“才”。用以说明主句的时间很短，翻译为“就”。这时，before引导的从句必须放在主句后面<ul>
<li>Nearly a week passed <code>before</code> the girl was able to explain what had happened to her. 几乎过了一个星期，那姑娘才能讲述自己的遭遇。</li>
</ul>
</li>
<li>直到：until/till，从句只能接短暂动词，主句肯定用延续动词，主句否定用短暂动词<ul>
<li>The young man did <code>not</code> wake up <code>until</code> the bed had struck the ground. 那年轻人直到床撞到地上才醒了过来。(not..util… 翻译为直到….才…)</li>
<li>He waited until the volcano became quiet and he was able to return two days later.他等到火山平静下来,两天以后又返回去。</li>
</ul>
</li>
<li>一…就…：as soon as/ the moment(只能接短暂动词)<ul>
<li><code>As soon as</code> he had got into the car, I said good morning to him in French and he replied in the same language.他一上车，我就用法语向他问早上好，他也同样用法语回答我。</li>
<li><code>As soon as</code> this was done, they cooked a meal over an open fire. 这件事刚刚做完，他们就在篝火上烧起了饭。</li>
<li><code>The moment</code> you leave this tent, you will get a big surprise. 您一走出这个帐篷，就会大吃一惊。</li>
</ul>
</li>
<li>刚…就…：no sooner…than…（主句动作已完成），hardly/scarcely…when/before…(主句动作差点完成)，主句用过去完成时，从句用一般过去时，且只能接短暂动词<ul>
<li>He had no sooner returned than he bought a house and went to live there. 他刚一回到英国便买下了一幢房子住了进去。</li>
<li>He had hardly had time to settle down when he sold the house and left the country. 还没等安顿下来就卖掉了房子，离开了这个国家。</li>
<li>I had scarcely fallen asleep before the noise from neighbor woke me up. 我刚一睡着，邻居发出的噪音就把我吵醒了。</li>
</ul>
</li>
<li>自从…：since/ever since(可以接短暂动词，也可接延续动词)，since后面不可以接完成时的，只能接一般态的短暂动词<ul>
<li>He has just bought a new house in the city, but ever since he moved in, he has had trouble with cars and their owner.他刚在城里买下一所新房子，但自从搬进去后，就和汽车及车主们发生了磨擦。</li>
<li>We haven’t seen each other since we graduated.自从毕业后我们彼此就没有见过面。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.当我走进这座大楼的时候，看见一位拿着公文包的女士(while)。<ul>
<li>1.I saw a lady with a briefcase while I was walking into the building.</li>
</ul>
</li>
<li>2.当你长大，你就会知道父母有多伟大。<ul>
<li>2.When you grow up, you will know how great your parents are.</li>
</ul>
</li>
<li>3.每当你发现你和多数人站在同一边时，就是改革的时候了。<ul>
<li>3.Whenever you find that you are on the side of the majority, it is the time to reform.</li>
</ul>
</li>
<li>4.玛丽打开礼物后，便开始写感谢函(thank-you notes)了。<ul>
<li>4.After she opened her gifts, Mary started writing thank-you notes.</li>
</ul>
</li>
<li>5.雨一停，天空中就出现了一道彩虹。<ul>
<li>5.As soon as the rain stooped, a rainbow appeared in the sky.</li>
</ul>
</li>
<li>6.比赛才刚刚开始，两个队就打了起来。(no sooner.. .than)<ul>
<li>6.The game had no sooner started than the two teams began to fight.</li>
</ul>
</li>
<li><ol start="7">
<li>Lulu刚用她的新电脑，电脑就坏了。(hardly..when)<ul>
<li>7.Lulu had hardly used her new computer when it broke.</li>
</ul>
</li>
</ol>
</li>
<li>8.我们会待在海边直到天黑。<ul>
<li>8.We are going to stay at the beach until it gets dark.</li>
</ul>
</li>
<li>9.已经过了三个月，大卫才提到他生病了。<ul>
<li>9.It had been three months before David mentioned he was sick.</li>
</ul>
</li>
<li>10.我在电影院门口等Lisa，不久以后她就到了。<ul>
<li>10.We waited for Lisa in front of the cinema and it was not long before she arrived.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="地点状语从句：一个句子在另外一个句子里面充当地点状语"><a href="#地点状语从句：一个句子在另外一个句子里面充当地点状语" class="headerlink" title="地点状语从句：一个句子在另外一个句子里面充当地点状语"></a>地点状语从句：一个句子在另外一个句子里面充当地点状语</h2><ul>
<li>地点状语从句的连词是where，但是要注意，where引导的地点状语从句，不仅可以表示地点，还可以表示抽象意义“在…形势之下”<ul>
<li>Where there is a will, there is a way.有志者，事竟成。</li>
<li>Where there is a smoke, there is fire.无风不起浪 </li>
<li>A driver should slow down where there are schools. 在有学校的地方， 司机应缓行。</li>
<li>Where the cost of government is high, resources for development are corresponding low.凡是政府管理费用高的地方，用于发展国家经济的资金就会相应地减少。</li>
<li>Where others ran away in fear, the soldier bravely fought against the enemy.在其他人惊慌逃跑的情况下，这名士兵英勇地抗击敌军。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.有生命就有希望。<ul>
<li>1.Where there is life, there is hope.</li>
</ul>
</li>
<li>2.在我成长的地方，人们在马路上都是靠右行驶。<ul>
<li>2.Where I grew up, people drive on the right side of the road.</li>
</ul>
</li>
<li>3.医生建议我住在空气更新鲜的地方。<ul>
<li>3.The doctor advised me to live where the air is fresher.</li>
</ul>
</li>
<li>4.在你有足够信心的前提下，你将会成功。<ul>
<li>4.Where you have enough confidence, you will succeed.</li>
</ul>
</li>
<li>5.无论你去哪里，无论你做什么，我将一直在这儿等你。<ul>
<li>5.Wherever you go, whatever you do, I will be right here waiting for you.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="原因状语从句：一个句子在另外一个句子里面充当原因状语"><a href="#原因状语从句：一个句子在另外一个句子里面充当原因状语" class="headerlink" title="原因状语从句：一个句子在另外一个句子里面充当原因状语"></a>原因状语从句：一个句子在另外一个句子里面充当原因状语</h2><ul>
<li>because, as, since, for, in that均可引导原因状语从句</li>
<li>because语气最强（强调从句），只有它能回答why的提问，也只有because才能被强调词only, just, perhaps来修饰</li>
<li>for/in that语气最弱（强调主句），所以只能放在主句后面。for表示推断的理由，故多用于主句后面</li>
<li>注:汉译英的时候，“既然”翻译为since,“由于”翻译为as<ul>
<li>Teenagers are damaging their health <code>because</code> they play computer games too much. 因为青少年们玩电脑游戏太多，他们的健康正在受损。</li>
<li><code>Perhaps because</code> Mom missed so much time with her own kids, she made it up with her grandchildren. 或许我妈妈错过了太多与她自己的孩子在一起的时间，因此她在孙辈中找到补偿。</li>
<li><code>As</code> a great many people will be visiting the country, the government will be building new hotels, an immense stadium, and a new Olympic-standard swimming pool. 由于将有大批的人到我们国家来，所以政府准备建造一些新的饭店、一个大型体育场和一个新的奥运会标准游泳池</li>
<li>I will seek to balance career and family <code>since</code> both are important to me. 由于事业和家庭对我都重要，我要努力在两者之间取得平衡。</li>
<li>He had had a long and uncomfortable trip, <code>for</code> he had been confined to the wooden box for over ten hours. 他经历了一次漫长而又难受的旅程，因为他在那木箱里闷了18个多小时。</li>
<li>He didn’t attend the negotiation <code>in that</code> he was ill. 他因为有病，没有参加谈判</li>
</ul>
</li>
<li>because和because of的区别：because of是介词短语，后面只能接名词，不能接句子。类似的介词短语还有due to, in view of, thanks to, owning to<ul>
<li><code>Because of</code> this, he has not been able to get his own car into his garage even once.为此，他甚至一次也没能把自己的车开进车库。</li>
<li><code>Owning to</code> the heavy rain, there have been many mudslides in the hill lately.因为大雨，最近山区发生多起泥石流。</li>
<li><code>Thanks to</code> great public transportation, few people in the city need to own cars.因为有很好的公交系统，这个城市很少有人需要自己买车。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我们将取消音乐会，因为音乐家出了意外，现在人在医院里。<ul>
<li>1.We will cancel the concert because the musician had an accident and is in the hospital.</li>
</ul>
</li>
<li>2.由于下周一是法定假日，所有的政府机关都将休息。<ul>
<li>2.As next Monday is a national holiday, all government offices will be closed.</li>
</ul>
</li>
<li>3.既然你是英语专业的，我猜想你能帮助我学习这个句子。<ul>
<li>3.Since you are an English major, I guess you can help me study this sentence.</li>
</ul>
</li>
<li>4.这个问题的答案我很久都理解不透(eludeme),也许是因为问题太简单了。<ul>
<li>4.The answer to this question eluded me for a long time, perhaps because it was so simple.</li>
</ul>
</li>
<li>5.昨晚下雨了，因为今天早上地面是湿的。<ul>
<li>5.It rained last night, for the ground is wet this morning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="结果状语从句：就是中文里边说的”如此……-以至于……”。连接结果状语从句的连词有-so-that…-，-such-that…，-so-that"><a href="#结果状语从句：就是中文里边说的”如此……-以至于……”。连接结果状语从句的连词有-so-that…-，-such-that…，-so-that" class="headerlink" title="结果状语从句：就是中文里边说的”如此…….以至于……”。连接结果状语从句的连词有: so..that…..， such..that…， so that"></a>结果状语从句：就是中文里边说的”如此…….以至于……”。连接结果状语从句的连词有: so..that…..， such..that…， so that</h2><ul>
<li>so…that…: so后面要接形容词或副词，或相当于形容词的分词<ul>
<li>Mrs. Sterling got so angry that she ran after them.斯特林夫人非常气愤，向着他们追了过去。</li>
<li>My friend, Hugh, has always been fat, but things got so bad recently that he decided to go on a diet.我的朋友休一直很胖，但是近来情况变得越发糟糕，以致他决定节食。</li>
<li>He did the work so badly that I had to do it all over again myself. 他干的太差劲了，我只好亲自重做</li>
<li>本句型的so可用enough取代，但是enough要后置<ul>
<li>She is old enough that she can get married = She is so old that she can get married.她已达到可结婚的年龄。</li>
<li>In the new country he became absorbed in making a new life for the two of us, so that he gradually ceased to grieve. 在这个新的国家里，父亲专心致志地为我们俩开创一种新的生活，慢慢地不伤心了。</li>
</ul>
</li>
</ul>
</li>
<li>such…that…：such后面要接名词<ul>
<li>The men got <code>such</code> a fright <code>that</code> they dropped the bag and ran away.这两个人吓了一跳，扔下提包逃跑了。</li>
</ul>
</li>
<li>so是so that…的省略形式，so既可以是副词，也可以是连词。so引导的句子，不仅可以用逗号连接，也可以单独成句<ul>
<li>My brother has never been abroad before, so he is finding this trip very exciting. 我弟弟以前从未出过国，因此，他觉得这次旅行非常激动人心。</li>
<li>To make matters worse, the room is rather small, so I have temporarily put my books on the floor. 更糟糕的是，房间还非常小，所以我暂时把书放在了地板上。</li>
</ul>
</li>
<li>so作副词，其引导的句子，也可以和前面的句子分开。<ul>
<li>The children were at school, my husband was at work and the house was quiet. So I decided to make some meat pies. 孩子们在上学，我丈夫在上班，家里清静得很。于是我决定做些肉馅饼。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.湖面上的雾太浓，所以我们不能看到对岸。<ul>
<li>1.The fog on the lake was very thick, so we couldn’t see the other side.</li>
</ul>
</li>
<li>2.玛丽很贴心，以至于大家都很喜欢她。<ul>
<li>2.Mary is so sweet that everyone loves her.</li>
</ul>
</li>
<li>3.他们是很糟糕的厨师以至于没人去他们的餐厅。<ul>
<li>3.They are such terrible cooks that no one came to their restaurant.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="目的状语从句"><a href="#目的状语从句" class="headerlink" title="目的状语从句"></a>目的状语从句</h2><ul>
<li>一般翻译为“以便于”，常用连词有so that, in order that, that, 主句和从句一般没有逗号隔开，在目的状语从句中，常含有情态动词<ul>
<li>He worked hard at his lessons so that he could gain high grades in the exams.他努力学习功课，争取考试能获得好成绩。（目的状语从句）</li>
<li>He worked hard at his lessons, so that he could gain high grades in the exams.他努力学习，结果考试获得了好成绩。(结果状语从句)</li>
<li>This time he was barking <code>so that</code> someone would let him out! 这次它叫着让人把它放出去!</li>
<li>This time, he managed to climb into the mouth of Kituro <code>so that</code> he could take photographs and measure temperatures. 这次他设法爬进了基图罗火山口，以便能拍摄照片和测试温度。</li>
<li>They had taken special precautions <code>so that</code> no one should recognize them. 他们做了特别的预防措施以防别人认出他们。</li>
<li>I am saving money <code>in order that</code> I can buy a house.我正在攒钱，以便我能买一所房子。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.这位电影明星伪装自己，以便在人群中不被认出来。<ul>
<li>1.The movie star disguised himself so that he wouldn’t be recognized in the crowd.</li>
</ul>
</li>
<li>2.我们应该早起以便能看到日出。<ul>
<li>2.We should wake up early in the morning in order that we can see the sun rise.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="让步状语从句"><a href="#让步状语从句" class="headerlink" title="让步状语从句"></a>让步状语从句</h2><ul>
<li>表示“虽然。。。但是。。。”，副词连词有：though, although, even though, even if。但和中文不同，主语前不可再加but，但可用yet/still</li>
<li>though, although, even though是对事实的让步，翻译为“虽然，尽管”</li>
<li>even if是对假设的让步，翻译为“即使，哪怕是”<ul>
<li><code>Though</code> she hesitated for a moment, she finally went in and asked to see a dress that was in the window. 她虽然犹豫了片刻，但终于还是走进了商店，要求把陈列在橱窗里的一件衣服拿给她看。</li>
<li><code>Although</code> the bed was smashed to pieces, the man was miraculously unhurt. 尽管床摔成了碎片，但年轻人却奇迹地没有受伤。</li>
<li><code>Even though</code> it was still summer, it rained continually and it was often bitterly cold. 即使那时仍为夏季，但雨总是下个不停，而且常常冷得厉害。</li>
<li>The villagers have told him that they will not accept the pub <code>even if</code> he gives it away. 村里的人已经告诉他，即使他把小酒店白送人，他们也不要。</li>
</ul>
</li>
<li>while/whereas也可以引导让步状语从句，相当于though或although<ul>
<li><code>While</code> winning is not everything, trying to win is everything.尽管获胜并不重要，但是为了获胜而努力却很重要。</li>
<li><code>Whereas</code> you cannot turn back the clock, you can take control of your life.虽然你不能使时钟倒转，但却可以掌控自己的生活。</li>
</ul>
</li>
<li>no matter wh-(how, what, who, which, when, where)或者however, whatever..也可引导让步状语从句<ul>
<li><code>No matter how</code> busy you are, he always insists on coming with you. 不管你多忙，他总是坚持要跟你去。(No matter how=however)</li>
<li><code>No matter what</code> you do, do with your might. 无论你做什么，要尽力。(No matter what=whatever)</li>
<li><code>No matter who</code> he is, he must obey the law.无论他是谁，都必须遵守法律。(No matter who=whoever)</li>
<li><code>No matter which</code> people criticize you, don’t let them take your focus off your dream.无论什么人批评你，都不要让他们破坏你的梦想! (No matter which=whichever)</li>
<li><code>No matter where</code> you live, you would find it difficult not to laugh at, say, Charlie Chaplin’s early films.比如说，不管你生活在哪里，你看查理.卓别林的早期电影很难不发笑。</li>
<li><code>Whatever</code> may happen, you must keep calm.不论什么事发生，你必须保持冷静。</li>
<li>The business would be a success, <code>whoever</code> owned it.不论什么人经营，这生意都会成功。</li>
</ul>
</li>
<li>whether也可以引导让步状语从句，表示“无论…”常和or或or not一起使用<ul>
<li><code>Whether</code> we realize it or not, each of us has the strong desire to success.不管我们是否意识到，我们都有成功的愿望。</li>
<li><code>Whether</code> we win or lose, we should respect the election result.无论是输还是赢，我们应该尊重选举结果。</li>
<li><code>Whether or not</code> he will stay, I really don’t care.他要走还是要留，我真的不关心。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.虽然他是我兄弟，但我们长得不像。<ul>
<li>1.Though he is my brother, we don’t look alike.</li>
</ul>
</li>
<li>2.尽管我父亲已经到了退休年龄，却打算继续工作。<ul>
<li>2.My father plans to carry on working even though he is old enough to retire .</li>
</ul>
</li>
<li>3.尽全力去奋斗，不管是否喜欢。<ul>
<li>3.Try your best to fight, whether you enjoy it or not.</li>
</ul>
</li>
<li>4.无论是你做还是他做，这个工作今天都得做完。<ul>
<li>4.Whether you or he do it, the work must be finished today<h2 id="方式状语从句"><a href="#方式状语从句" class="headerlink" title="方式状语从句"></a>方式状语从句</h2></li>
</ul>
</li>
</ul>
</li>
<li>表示动作的方式，意思是“就像…一样，以…样的方式”，引导词有as, as if, as though, the way<ul>
<li>When in Rome, do <code>as</code> the Romans do. 入乡随俗。</li>
<li>The space shuttle, <code>as</code> we know it, is still imperfect. 航天飞机就像我们知道的一样仍然不完美。</li>
<li>He acted <code>as if</code> he had never lived in England before. 他的举动就好像他从未在英国生活过一样。</li>
<li>To achieve great things we must live <code>as though</code> we were never going to die. 做大事就要有永生的气概!</li>
<li>You should do it <code>the way</code> you were taught. 按照教你的那样去做</li>
</ul>
</li>
<li>美式英语可用like代替as if, as though，但是书面语中少用<ul>
<li>He studies English very hard, like he did Chinese some years ago. 他非常用功地学英语，就像多年前学中文一样。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.你应该像规划假期一样规划你的退休生活。<ul>
<li>1.You should plan your retirement as you plan your vacation.</li>
</ul>
</li>
<li>2.请照我这样，读这个单词<ul>
<li>2.Please pronounce the word the way I do</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="8-定语从句不一定是真定语，而是并列句的马甲"><a href="#8-定语从句不一定是真定语，而是并列句的马甲" class="headerlink" title="8.定语从句不一定是真定语，而是并列句的马甲"></a>8.定语从句不一定是真定语，而是并列句的马甲</h1><h2 id="定语从句是什么"><a href="#定语从句是什么" class="headerlink" title="定语从句是什么"></a>定语从句是什么</h2><p>一个句子，在另一个句子里边，作定语。</p>
<h2 id="定语从句的其实是两个并列句的合并"><a href="#定语从句的其实是两个并列句的合并" class="headerlink" title="定语从句的其实是两个并列句的合并"></a>定语从句的其实是两个并列句的合并</h2><ul>
<li>Captain Fawcett’s first passenger was a doctor <code>who</code> flew from Birmingham to a lonely village in the Welsh mountains.</li>
<li>这句话里边，who指的是主句提到的the doctor，那么，如果按照传统语法来翻译就是: Fawcett机长的第一个乘客是一个从伯明翰飞到南威尔士一个偏僻村子去的医生。</li>
<li>Captain Fawcett’s first passenger was a doctor and <code>the doctor</code> flew from Birmingham to a lonely village in the Welsh mountains.</li>
<li>因为后面分句的the doctor，其实就是主句里边的doctor，所以，后面那个句子的the doctor就可以改成who，然后去掉and，就变成定语从句了。</li>
</ul>
<h2 id="定语从句的连接词，叫关系词，分为两大类"><a href="#定语从句的连接词，叫关系词，分为两大类" class="headerlink" title="定语从句的连接词，叫关系词，分为两大类"></a>定语从句的连接词，叫关系词，分为两大类</h2><ul>
<li>1.代词类关系词<ul>
<li>(1)关系代词</li>
<li>(2)关系代词所有格</li>
<li>(3)复合关系代词</li>
</ul>
</li>
<li>2.副词类关系词<ul>
<li>(1)关系副词</li>
</ul>
</li>
</ul>
<h2 id="关系代词"><a href="#关系代词" class="headerlink" title="关系代词"></a>关系代词</h2><ul>
<li>概述<ul>
<li>替代前面的先行词，在定语从句中作主语，宾语，表语。</li>
<li>代替人时，坐主语用主格who，作宾语用宾格whom</li>
<li>代替物，或代替整个句子，无论作主语还是宾语，均用which</li>
</ul>
</li>
<li>限定性定语从句：先行词为一般名词，关系代词引导的定语从句<ul>
<li>Captain Fawcett’s first passenger was a doctor <code>who</code> flew from Birmingham to a lonely village in the Welsh mountains.(who作主格，代替doctor) 弗西特机长的第一名乘客是位医生，他从伯明翰飞往威尔士山区一个偏僻的村庄。</li>
<li>He is a man <code>whom</code> we should respect.他是一个我们应该尊重的人。(whom做宾语，代替man)注:在美国英语中，whom作宾语时，也可用who代替。把whom we should respect.直接翻译成定语“我们应该尊重的”比较好</li>
<li>In a few years the small workshop had become a large factory <code>which</code> employed 728 people.(which作主语，代替factory)几年之后，小铺子已经发展成了一个雇有728人的大工厂。把which employed 728 people.直接翻译成定语“雇有728人的“比较好</li>
<li>Forest fire often caused by cigarette ends <code>which</code> people carelessly throw away.(which作宾语，代替cigarette ends)森林火灾时常由人们随手扔掉的香烟头引起</li>
<li>In 1948, he went to Lake Kivu to observe a new volcano <code>which</code> he later named Kituro.(which作宾语，代替volcano, 而定语从句里边的Kituro是宾语补语)1948年他去了基伍湖，对一座后来被他命名为基图罗的新火山进行观察</li>
</ul>
</li>
<li>作介词的宾语时，可以将介词移动到关系词之前，一般正式的书面语，是把介词放在关系代词前面<ul>
<li>Peter is a man <code>whom</code> I enjoy working <code>with</code>.</li>
<li>Peter is a man <code>with whom</code> I enjoy working.</li>
<li>The city <code>in which</code> I live is very large.</li>
<li>The city <code>which</code> I live <code>in</code> is very large.</li>
</ul>
</li>
<li>非限定性定语从句：若定语从句只对先行词进行补充说明，则关系词前面可加上逗号</li>
<li>先行词为一般名词，但其前面已经有限定词或形容词修饰时，其后既可用限定性定语从句，也可用非限定性定语从句<ul>
<li>He waved desperately to his companion, <code>who</code> had been water-skiing for the last fifteen minutes.他绝望地向他的伙伴挥手，他的伙伴在过去的15分钟里一直在滑水</li>
</ul>
</li>
<li>先行词为专有名词（人名或地名）及独一性名词（如father, mother…）时，因为本身就具有特殊性，其后关系代词引导的定语从句，必须是非限定性定语从句<ul>
<li>Einstein, <code>who</code> was a great scientist, created the theory of relativity. 爱因斯坦这位伟大的科学家发明了相对论。</li>
<li>Beijing, <code>which</code> is the capital of China, has developed into an international city.北京，中国的首都，已经成为了一个国际大都市。</li>
<li>Among them will be Debbie’s mother, <code>who</code> swam the Channel herself when she was a girl.他们当中还会有黛比的母亲，她本人还是个女孩时，也曾横渡过英吉利海峡!</li>
</ul>
</li>
<li>先行词为整个主句时，定语从句也多是非限定性定语从句<ul>
<li>Jimmy is a naughty boy, <code>which</code> everyone knows. 吉米是一个顽皮的孩子，这点大家都知道</li>
</ul>
</li>
<li>that也可作关系代词，取代who, whom, which, 但that前不能有逗号，也不能有介词<ul>
<li>This is the sort of thing <code>that</code> Jeremy loves. 这正是杰里米喜欢做的事情。</li>
<li>A game <code>that</code> is very popular with these young swimmers is the underwater tricycle race.这些幼小的游泳运动员非常喜爱的一种游戏是水下三轮车比赛。</li>
</ul>
</li>
<li>只能用that的情况：<ul>
<li>1.先行词同时出现“人”和“物”时<ul>
<li>The scientist and his inventions <code>that</code> the article deals with are quite familiar to us.这篇文章里说的那位科学家和他的发明，我们都比较熟悉。</li>
</ul>
</li>
<li>2.先行词是不定代词（something, anything, nothing, everything）时<ul>
<li>I would much rather receive something <code>that</code> made me laugh.我更愿意接受能让我高兴的东西</li>
<li>A variable is something <code>that</code> can be changed and controlled.变量是能够被改变和控制的东西。(美国加州3年级科学课本)</li>
</ul>
</li>
<li>3.先行词被绝对性形容词修饰时（如序数词，形容词的最高级，the very, the only, all, every, no等修饰时）<ul>
<li>Of course, the Hubble is above the earth’s atmosphere, so it will soon be sending us <code>the clearest pictures that</code> we have ever seen.当然，哈勃位于地球的大气层之外，因此，它很快就会给我们传送我们所见到过的、有关行星和远距离星系的最清晰的照片。</li>
<li><code>All the students that</code> are studying in our class is hardworking.尽管有上述种种说法，但游客们还是照常摘树叶和把他们的名字刻在树干上。</li>
</ul>
</li>
<li>4.句中有两个相同关系代词引导的定语从句时，为避免重复，其中一个用that<ul>
<li>He works hard, <code>which</code> is a fact <code>that</code> is known to us.他很用功，这时我们都知道的事实。</li>
<li>My best friend was devastated by the letter <code>which</code> she received <code>that</code> rejected her application to university.[that和which也可互换]我最好的朋友被那封她收到的拒绝她入大学申请的信打击了。</li>
<li>There was no trace of fingerprints, but the inspector found a dirty red bundle <code>that</code> contained jewellery <code>which</code> the old lady said was not hers.巡官没有发现指纹，却发现了一个装有珠宝的、肮脏的红包袱。老妇人说那不是她的。</li>
</ul>
</li>
<li>5.限定性定语从句中，若关系代词作及物动词的宾语，该关系代词可省略。若作介词的宾语，则将介词放在词尾，再省略关系代词<ul>
<li>It is one of the ugliest faces I have ever seen.(定语从句前省略了作宾语的关系代词that) 这是我见过的最丑陋的头像之一。</li>
<li>That was all she remembered.(定语从句前省略了作宾语的关系代词that) 她所记得的就是这些。</li>
<li>The picture it sent us were very disappointing because its main mirror was faulty!(定语从句前省略了作直接宾语的关系代词that或which)它传送给我们的图像很令人失望，因为它的主要镜子有误差。</li>
<li>Peter is a man I enjoy working with.(定语从句前省略了whom)彼得是一个我喜欢和他共事的人。</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.双语人士(bilingual) 就是能说两种语言一样好的人。<ul>
<li>1.A bilingual is a person who can speak two languages equally well.</li>
</ul>
</li>
<li>2.不要和自己了解不充分的人交朋友。<ul>
<li>2.Don’t make friends with those whom(who) you do not know well.</li>
</ul>
</li>
<li>3.要参加比赛的人必须在本周五之前报名(signup)。<ul>
<li>3.People who want to attend the competition must sign up by this Friday.</li>
</ul>
</li>
<li>4.Lulu买了那件她想要的价值不菲的裙子。<ul>
<li>4.Lulu bought that expensive skirt which she wanted.</li>
</ul>
</li>
<li>5.我把我银行账户里边的最后一美元花掉了。<ul>
<li>5.I spent the last dollar that I had left in my bank account.</li>
</ul>
</li>
<li>6.我喜欢我的学校，它以优良的设施闻名。<ul>
<li>6.I like my school, which is famous for its excellent facilities.</li>
</ul>
</li>
<li>7.我在聚会上遇到很多小学同学，其中一些我都认不出来了。<ul>
<li>7.I met many elementary schoolmates at the party, some of whom I didn’t recognize.</li>
</ul>
</li>
<li>8.彼得是个非常优秀的工程师，这点我们都知道。<ul>
<li>8.Peter is a very excellent engineer, which we all know.</li>
</ul>
</li>
<li>9.这位是我的女朋友，她英语说得非常流利。<ul>
<li>9.This is my girlfriend, who can speak fluent English.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关系代词所有格"><a href="#关系代词所有格" class="headerlink" title="关系代词所有格"></a>关系代词所有格</h2><ul>
<li>由代词所有格his, her, their, my, your, its变化二来，关系代词所有格和后面的名词，共同作定语从句的主句，宾语</li>
<li>无论代替人还是代替物，关系代词所有格均可用whose</li>
<li>修饰物，也可用of which</li>
<li>of前面是代词的时候，不用whose，用of whom<ul>
<li>Many people <code>whose</code> homes are in town want to live in the country.(whose代替人)很多家在城里的人都想住在乡下。</li>
<li>Be a man <code>whose</code> word is as good as your bond.(whose代替人)做一个说话可靠的人。</li>
<li>Success is a journey <code>whose</code> initial step is paved with an inner stirring.(whose代替物)成功是以此旅程，第一步是由内心的热情铺就的。</li>
<li>也可改为：</li>
<li>Success is a journey <code>of which</code> the initial step is paved with an inner stirring.</li>
<li>Success is a journey, the initial step <code>of which</code> is paved with an inner stirring.</li>
</ul>
</li>
<li>名词/代词+of+whom/which这种结构，属于非限定性定语从句，表示从属关系<ul>
<li>Light is the fastest thing in the world, <code>the speed of which</code> is 300.000 kilometers per second.(这里的先行词是speed是名词，所以可改成whose speed)光是世界上最快的东西，它的速度是每秒30万公里。</li>
<li>The old man has three sons, <code>one of whom</code> is a doctor.(这里的先行词one是代词，所以不能改成whose one..)这个男人有三个儿子，其中一个是医生。</li>
<li>There are 300 college students in the small hall, <code>most of whom</code> are freshmen.(先行词most是代词，所以不能改成whose most…)这个小厅里边有300个大学生，他们中的大多数是大一学生。</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.这是玛丽，她的爸爸是我们学校的校长。<ul>
<li>1.This is Mary, whose father is the headmaster of our school.</li>
</ul>
</li>
<li>2.我们住在一栋老房子里，它的屋顶可能随时会崩塌(collapse)。<ul>
<li>2.We live in an old house whose roof may collapse anytime.</li>
</ul>
</li>
<li>3.这就是那台硬盘中病毒的电脑。<ul>
<li>3.This is the computer whose hard disk is infected with a virus </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="复合关系代词"><a href="#复合关系代词" class="headerlink" title="复合关系代词"></a>复合关系代词</h2><ul>
<li>复合关系代词what，是先行词和关系代词融为一体，形成的关系代词，相当于the thing that。所以复合关系代词引导的定语从句，前面绝对没有先行词<ul>
<li><code>What</code> John said may be true. = The thing that John said may be true. = <code>What</code> was said by john may be true.(也可用被动语态)约翰说的可能是真的。</li>
<li>He was astonished at what he found.看到的情景使他吃惊。</li>
<li>what也可由all that取代<ul>
<li>Now <code>all that</code> was needed were the parents, but they were absent.现在，我们需要我们的父母，但是他们却不在。</li>
<li><code>All that</code> Billy told us a year ago has become true.Billy一年前告诉我们的事情成真了</li>
</ul>
</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.我没有听到你刚才说的，能再说一遍吗?<ul>
<li>1.I didn’t hear what you just said. Could you say that again?</li>
</ul>
</li>
<li>2.我知道你的意思，但是我不同意。<ul>
<li>2.I know what you mean but I can’t agree with you.</li>
</ul>
</li>
</ul>
</li>
<li>其它不常用复合关系代词：<ul>
<li>1.代替人：<ul>
<li>whoever = anybody who(凡是…的人)</li>
<li>whomever = anybody whom(凡是…的人)</li>
</ul>
</li>
<li>2.代替物：<ul>
<li>whatever = anything which(…的任何东西)</li>
</ul>
</li>
<li>3.代替人或物：<ul>
<li>whichever = any one which/who(三者以上同类的任何一个)</li>
<li>= either which/who（二者同类的任何一个）</li>
</ul>
</li>
</ul>
</li>
<li>代词whatever是what的强调形式，相当于anything which<ul>
<li>She would do <code>whatever</code> she wanted to. = She would do <code>anything which</code> she wanted to.她想要做什么就做什么。</li>
</ul>
</li>
<li>代词whoever有时也可视为复合关系代词，相当于anybody who<ul>
<li><code>Whoever</code> plays with fire gets burnt. = <code>Anybody who</code> plays with fire gets burnt.玩火者必自焚。</li>
<li>I’ll teach English to <code>whoever</code> wants to learn it. = I’ll teach English to <code>anybody who</code> wants to learn it.谁想学英文，我就教他。</li>
</ul>
</li>
</ul>
<h2 id="副词类关系词"><a href="#副词类关系词" class="headerlink" title="副词类关系词"></a>副词类关系词</h2><ul>
<li>一共有3种，均由“介词+关系代词which”变化而来<ul>
<li>1.where = in which, on which, at which 代替表地方的名词</li>
<li>2.when = in which, on which, at which 代替表时间的名称</li>
<li>3.why = for which 代替the reason</li>
</ul>
</li>
<li>在限定性定语从句中，where不能省略，when和why可以省略<ul>
<li>Mrs. Brabante is talking to the manager of the local factory <code>where</code> the crop is processed.(where=in the factory=in which，在从句里边作地点状语)布拉班特太太现在正和负责通心粉加工的当地加工厂的经理交谈。</li>
<li>There will be moments in life <code>when</code> you are confronted with new options.(when = in these moments = in which在从句里边作时间状语)人生中总有会面对新选择的时候。</li>
<li>Unsuccessful people can always find reasons <code>why</code> they are not doing well.(why = for these reasons = for which, 在从句中作原因状语。而且这个句子中，不仅可以省略why。还可以保留why，省略reasons，此时变成宾语从句Unsuccessful people can always find <code>why</code> they are not doing well.)不成功的人总能找到自己表现不好的理由。</li>
</ul>
</li>
<li>the way后面的定语从句<ul>
<li>先行词是名词the way的时候，后面的关系副词是in which或者that，而且可省略<ul>
<li>The assistant who served her did not like the way she was dressed.(the way后面省略了in which/that)接待她的售货员不落欢她的那刚打扮。</li>
<li>I liked the way she organized the meeting.(the way后面省略了in which/that)我喜欢她组织会议的方法</li>
<li>I hate the way in which he stares at me.我讨厌他那样盯着我</li>
<li>The only way that they can preserve their history is to recount it as sagas.他们保存历史的唯一办法是将历史当作传说讲述。</li>
</ul>
</li>
<li>上面句型中的the way(in which/that)可被how取代，变成宾语从句，意思不变。但用得不多<ul>
<li>The assistant who served her did not like how she was dressed.</li>
<li>I liked how she organized the meeting.</li>
<li>I hate how he stares at me.</li>
</ul>
</li>
<li>the way也可作副词连词引导方式状语从句<ul>
<li>I admire the way you speak to your students.（定语从句）</li>
<li>You should do it the way you were taught.(方式状语从句)</li>
</ul>
</li>
</ul>
</li>
<li>where, when代替的先行词作be动词的表语时，可省略先行词，保留关系副词<ul>
<li>This is (the place) where he was born.这是他出生的地方。</li>
<li>That is (the day) when he will come.那就是他要来的日子。</li>
</ul>
</li>
<li>某些表示时间的名词短语，后面接着没有引导词的句子，其实就是省略了关系副词when。by the time, at the time, next time, every time, the first time, the day…<ul>
<li><code>Every time</code> he wanted to come into the garden he would bark until someone opened the gate.</li>
<li><code>By the time</code> you read this, the Hubble’s eagle eye will have sent us thousands and thousands of wonderful pictures.</li>
</ul>
</li>
<li>造句练习<ul>
<li>1.上午11点是考试结束时间，那时所有学生都必须放下笔(put down)。<ul>
<li>1.Eleven a.m. is the time when the exam will be over and all students must put their pens down.</li>
</ul>
</li>
<li>2.我想知道你今天上午，上学迟到的原因。<ul>
<li>2.I want to know the reason why you were late to school this morning.</li>
</ul>
</li>
<li>3.月球上有一个地方，是Neil Armstrong所踏出的第一 步。<ul>
<li>3.There is a spot on the moon where Neil Armstrong took his first step.</li>
</ul>
</li>
<li>4.这是他处理问题的方法。<ul>
<li>4.This is the way he handled problems. / This is how he handled problems.</li>
</ul>
</li>
<li>5.我们有时把荒岛想象成某种阳光终日普照的天堂。<ul>
<li>5.We sometimes imagine a desert island to be a sort of paradise where the sun always shines.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="9-英语长句子的简化方法"><a href="#9-英语长句子的简化方法" class="headerlink" title="9.英语长句子的简化方法"></a>9.英语长句子的简化方法</h1><h2 id="并列句的转化"><a href="#并列句的转化" class="headerlink" title="并列句的转化"></a>并列句的转化</h2><ul>
<li>分词短语的构成和功能<ul>
<li>分词，就是指动词的另外两种形式，一种是现在分词，另一种是过去分词</li>
</ul>
</li>
<li>并列句实质上就是两个简单句放在一起,并无主次之分<ul>
<li>请看下面两个句子:</li>
<li>We are sitting by the sea.我们坐在海边。</li>
<li>We can see the beautiful sunrise. 我们可以看到美丽的日出。</li>
<li>上述两个句子，如果放在一起， 形成并列句，那就是:</li>
<li>We are sitting by the sea and we can see the beautiful sunrise.</li>
<li>注意：连词and绝对不能换成逗号，这点要牢记，和我们汉语的标点符号是不同的。因为英语中一个句号只能有一个主语</li>
<li>We are sitting by the sea, we can see the beautiful sunrise. (X)</li>
</ul>
</li>
<li>句子中的简化方法<ul>
<li>要强调哪个句子，就把哪个句子作为主句，另外一个不重要的，简化为分词短语</li>
<li>前面句子不重要：<code>Sitting by the sea</code>, we can see the beautiful sunrise.</li>
<li>后面句子不重要：We are sitting by the sea <code>seeing the beautiful sunrise</code>.</li>
<li>并列句变成的分词短语，称为“伴随状语”，如果分词短语放在主句前面，一定要加上逗号，如果分词短语放在主句后面，逗号可要可不要</li>
</ul>
</li>
<li>分词短语：其实就是简化的句子<ul>
<li>两句主语相同时，被化简句子的主语要删除<ul>
<li>He glanced at her scornfully and he told her that the dress was sold.他轻蔑地看了她一眼后，便告诉她那件衣服已经卖出去了。</li>
<li>这是一个并列句，两个分词的主语都是he，所以可以将其中任何一个分句，化简为分词短语</li>
<li>1.Glancing at her scornfully, he told her that the dress was sold.</li>
<li>2.He glanced at her scornfully telling her that the dress was sold.</li>
</ul>
</li>
<li>两句主语不同的时候，被化简句子的主语要保留<ul>
<li>We tried three new meals and the tastiest meal was the Thai dish. 我们试过3种新菜品，最好吃的是泰国菜。</li>
<li>这个并列句第一个分句的主语是We, 第二个分句的主语是the tastiest meal。这时两个分句的主语不同，故必须保留下来</li>
<li>1.We trying three new meals, the tastiest meal was the Thai dish.</li>
<li>2.We tried three new meals, the tastiest meal being the Thai dish.</li>
</ul>
</li>
</ul>
</li>
<li>并列句化简为分词短语的经典例句<ul>
<li><code>Following in his father&#39;s footsteps many years later</code>, Donald, also set up a world record. 很多年之后，马尔科姆爵士的儿子唐纳德踏着父亲的足迹，也创造了一项世界纪录。(相当于Donald <code>followed in his father&#39;s footsteps many years later,</code>…)</li>
<li>Working rapidly in the darkness, he soon changed into the dead man’s clothes.他在黑暗中忙活了一阵儿，很快就换上了死者的衣服。(相当于He worked rapidly in the darkness…)</li>
<li>The Channel Tunnel was officially opened on March 7, 1994, finally connecting Britain to the European continent.英法海底隧道于1994年3月7日正式开通，将英国与欧洲大陆连到了一起。</li>
<li>When it grew dark, she turned a suitcase into a bed and put the children inside it, covering them with all the clothes she could find. 天黑下来的时候，她把提箱当作小床，把两个孩子放了进去，又把所有能找到的衣服都盖在了孩子们身上。</li>
<li>Thousands of lanterns slowly <code>drift</code> out to sea guiding the dead on their return journey to the other world.成千上万只灯笼慢慢漂向大海，指引着亡灵返回另一个世界。(相当于drift out to sea and guide the dead on..)</li>
<li>This is a moving spectacle, for crowds of people <code>stand</code> on the shore watching the lanterns drifting away until they can be seen no more.这是一个感人的场面，人们成群地伫立在海岸上，注视着灯笼远去，直到再也看不见为止。(相当于stand on the shore and watch the lanterns…)</li>
</ul>
</li>
<li>若要化简的分句的动词是be动词（主系表句型，或被动语态），化简为分词being，而且可以将being省略<ul>
<li><code>Sensitive to criticism</code>, the bull forgot all about the matador and charged at the drunk.对批评很敏感，这头公牛忘了斗牛士，冲向这个酒鬼。(相当于 The bull <code>was</code> sensitive to criticism,…)</li>
<li>Now, <code>dressed in a blue</code> uniform and with a rifle over his shoulder, the prisoner marched boldly up and down in front of the camp.现在他身穿蓝军装，肩扛步枪，在军营门前大胆地来回走看。(相当于The prisoner <code>was</code> dressed in a blue uniform…)</li>
<li><code>Being a pop fan</code>, she likes Jay Chou most.作为一个流行乐迷，周杰伦是她最喜欢的明星。</li>
</ul>
</li>
<li>注意事项<ul>
<li>进行时态be+现在分词的情况，这个时候的be动词不是系动词，而是助动词，不能简化成being</li>
<li>比如He was playing basketball and he had a good time.这个时候前面分句的动词是play, 而不是was。所以只能改成Playing basketball, he had a good time.</li>
</ul>
</li>
<li>造句练习(分别用并列句和分词短语造句)<ul>
<li>1.日本发生强烈地震，造成重大伤亡(heavy losses)。<ul>
<li>1.A strong earthquake took place in Japan and caused heavy losses.</li>
<li>A strong earthquake took place in Japan causing heavy losses.</li>
</ul>
</li>
<li>2.然后他跳进车里，以最快的速度把车开走了(drive off)。<ul>
<li>2.Then, he jumped into the car and drove off as quickly as he could.</li>
<li>Then, jumping into the car, he drove off as quickly as he could.</li>
</ul>
</li>
<li>3.这位女演员很开心能演这个角色，于是答应主演这部电影。<ul>
<li>3.The actress was happy to play the role and accepted the offer to star in the film. </li>
<li>(Being) happy to play the role, the actress accepted the offer to star in the film.</li>
</ul>
</li>
<li>4.然后，她拿着画板走进我的房间，同时唱着流行歌曲。<ul>
<li>4.Then she marched into my room with her drawing board, singing a popular song.</li>
<li>Then she marched into my room with her drawing board and sang a popular song.</li>
</ul>
</li>
<li>5.我环视了一下身旁，惊奇地发现车里就只剩我一个乘客了<ul>
<li>5.I looked round and realized with a shock that I was the only passenger left on the bus.</li>
<li>Looking round, I realized with a shock that I was the only passenger left on the bus.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="状语从句的化简"><a href="#状语从句的化简" class="headerlink" title="状语从句的化简"></a>状语从句的化简</h2><ul>
<li>在时间、条件、原因、结果、目的、让步、方式等状语从句中，其主语与主句的主语相同时，可化简为现在分词短语（being可省略）<ul>
<li><code>Hearing the joke</code>, we burst out laughing.听到这个笑话，我们大笑起来。(相当于时间状语从句When we heard the joke, we bust out laughing.)</li>
<li><code>Not realizing who she was</code>, the assistant was eager to serve her this time.那个售货员没有认出她是谁，这一回接待她的态度非常殷勤。(相当于Because the assistant didn’t realize who she was, …)注，否定分词结构，not要放在分词前面</li>
<li><code>Tired of sleeping on</code> the floor, a young man in Teheran saved up for years to buy a real bed.德黑兰的一个人年轻人由于对睡地板感到厌倦，于是积蓄多年买了一张真正的床。(Tired前面省略了being，化简之前为Because he was tired of…)</li>
<li><code>Not wanting</code> to frighten the poor man, Mrs. Richards quickly hid in the small storeroom under the stairs.理查兹夫人不想吓到这个可怜的人，便赶紧躲到了楼梯下的小储藏室里。(相当于Because Mrs. Richards didn’t want to frighten the poor man, …)</li>
<li>It rained for two weeks on end, completely <code>ruining our holiday</code>.我们假期的最后两个星期都在下雨，把我们的假期全毁了。(相当于结果状语从句so that it completely ruined our holiday)</li>
<li>She tried to explain the situation, <code>saying &#39;It&#39;s only me&#39;</code>, but it was too late.她试图解释现在的情况，于是说“是我，别怕”，但是太迟了。(相当于结果状语从句… so that she said…)</li>
<li>The Titanic turned just in time, narrowly <code>missing the immense wall</code> of ice which rose over 100 feet out of the water beside her.“泰坦尼克”拐弯很及时，紧贴着高出海面100英尺的巨大的冰墙擦过去。(相当于结果状语从句so that it missed the immense wall…)</li>
<li>Her first impulse was to go round all the rooms <code>looking for the thieves</code>.她的第冲动是走遍所有房间， 去寻找小偷。</li>
<li>Your time is limited, so don’t waste it <code>living someone else&#39;s</code> life. Don’t let the noise of others’ opinions drown out your own inner voice. 你的时间有限,所以不要浪费时间去过别人的生活。不要让别人的意见淹没了你内心的声音。(乔布斯名言)(相当于目的状语从…o that you can live someone else’s life.)</li>
<li>I bound the base of the tree with sticky tape, <code>making it impossible for the ants to reach the aphides</code>. 我用一条胶带把桃树底部包上，不让蚂蚁接近蚜虫。( 相当于目的状语从句…so that I could make it impossible for the ants to reach the aphides.)</li>
<li>I crossed the street to avoid meeting him, but he saw me and came <code>running</code> towards me. 我穿过马路以便避开他，但他看到我并朝我跑过来。(相当于方式状语从句the way he ran towards me)</li>
<li>He and his staff began throwing furniture out of the window. Chairs and tables went <code>flying</code> into the arcade. 他与店员动手向窗外投掷家具，椅子和桌子飞落到拱廊街上。(相当于方式状语从句the way they flew into the arcade)</li>
<li>He had a very sad look on his face. He walked <code>looking only at the ground</code>.他的脸色看起来非常悲伤。他走路时只看着地面。( 相当于方式状语从句，the way he looked only at the ground)</li>
<li>Every morning, he left home <code>dressed in a smart black suit</code>. 每天早晨，他穿上一身漂亮的黑色西装离家上班(相当于方式状语从句，the way he was dressed in a smart black suit.)</li>
<li>She enjoyed herself <code>making the assistant bring almost everything in the window</code> before finally buying the dress she had first asked for. 她开心地迫使那位售货员把橱窗里几乎所有的东西都拿了出来，最后才买下了她最先要看的那一件。(相当 于方式状语从句，the way she made the assistant…)</li>
<li>Mocked at by everybody, he had my sympathy. 尽管大家嘲笑他，但是我很同情他。(相当于让步状语从句Though he was mocked at by everybody, ..)</li>
</ul>
</li>
<li>when, after, before, while, for, once, if, unless, though这些副词连词引导的状语从句化简成分词短语时，可以保留这些副词连词(before和after不能省略)<ul>
<li>They have all been put to shame by a boy who, <code>while playing truant</code>, travelled 1,600 miles. 而有那么一个小男孩，他在逃学期间旅行了1,600英里，从而使上述所有逃学的孩子们都相形见绌了。(相当于时间状语从句while he played truant, …)</li>
<li>Even the bull seemed to feel sorry for him, for it looked on sympathetically until the drunk was out of the way <code>before</code> once more <code>turning its attention to the matador</code>. 好像连牛也在为他感到遗憾，因为它一直同情地看着醉汉，直到他的背影消逝，才重新将注意力转向斗牛士。(相当于时间状语从句before it once more turned its attention to the matador.)</li>
<li>He was sent to prison <code>for failing</code> to pay his debts and died in poverty in 1836. 他因无力还债而被捕入狱，最后于1836年在贫困中死去。(相当于原因状语从句for he failed to pay his debts…)</li>
<li>It is important that I do not despair <code>when faced with difficulties</code>.重要的是，当我面对困难的时候我不会绝望。(相当于时间状语从句…when I am faced with difficulties.)</li>
<li><code>Though a little suspicious this time</code>, the policeman gave him the same answer.虽然那位警察这次有点疑心，但还是对他作了同样的回答。(相当于让步状语从句Though the policeman was a little suspicious, …</li>
</ul>
</li>
<li>造句练习: (分别用状语从句和分词短语造句)<ul>
<li>1.我没事做，所以感到很无聊。<ul>
<li>1.Because I have nothing to do, I felt bored.</li>
<li>Having nothing to do, I felt bored.</li>
</ul>
</li>
<li>2.你尚未满18岁，不能在便利店购买烟和酒。<ul>
<li>2.Because you are not eighteen years old yet, you can’t buy cigarettes or wine at a convenience store.</li>
<li>Not (being) eighteen years old yet, you can’t buy cigarettes or wine at a convenience store.</li>
</ul>
</li>
<li>3.因为不满意工资，很多工人罢工了。<ul>
<li>3.Because they are not satisfied with their wages, many workers went on strike.</li>
<li>Not (being) satisfied with their wages, many workers went on strike.</li>
</ul>
</li>
<li>4.除非受到邀请，否则你不可以参加明晚的聚会。<ul>
<li>4.Unless you are invited, you may not attend the party tomorrow night.</li>
<li>Unless (being) invited, you may not attend the party tomorrow night.</li>
</ul>
</li>
<li>5.虽然我们都知道真相，却保持沉默。<ul>
<li>5.Although we all know the truth, we remain silent.</li>
<li>Although knowing the truth, we all remain silent.</li>
</ul>
</li>
<li>6.那位渔民意识到这不是一条普通的鱼，于是千方百计不让它受到丝毫伤害。<ul>
<li>6.Because the fisherman realized that this was no ordinary fish, he made every effort not to damage it in any way.</li>
<li>Realizing that this was no ordinary fish, the fisherman made every effort not to damage it in any way.</li>
</ul>
</li>
<li>7.当地的屠户Sam Benton在把存款送往邮局的途中把钱包丢了。<ul>
<li>7.Sam Benton, the local butcher, had lost his wallet while he was taking his savings to the post-office.</li>
<li>Sam Benton, the local butcher, had lost his wallet while taking his savings to the post-office.</li>
</ul>
</li>
<li>8.尽管查尔斯不懂汉语，但是还是能够和我们交流。<ul>
<li>8.Though he didn’t understand Chinese, Charles was able to communicate with us.</li>
<li>Though not understanding Chinese, Charles was able to communicate with us.</li>
</ul>
</li>
<li>9.这部电影深刻解释了东西方文化的差异，结果引起了美国观众的强烈反响。<ul>
<li>9.The film exposes cultural differences between the East and the West, so that it aroused tremendous response in American audiences.</li>
<li>The film exposes cultural differences between the East and the West, arousing tremendous response in American audiences.</li>
</ul>
</li>
<li>10.听到这个消息时，他们都高兴得跳了起来。<ul>
<li>10.When they heard the news, they all jumped with joy.</li>
<li>Hearing the news, they all jumped with joy.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定语从句的化简"><a href="#定语从句的化简" class="headerlink" title="定语从句的化简"></a>定语从句的化简</h2><ul>
<li>定语从句中，关系代词作主语时，可化简为现在分词短语。法则是：删除关系代词，其后动词变成现在分词<ul>
<li>Some children were playing games on the bank and there were some people <code>rowing on the river</code>.河岸上有些孩子正在玩耍，河面上有些人正在划船。(相当于定语从句，…who rowed on the river.)</li>
<li>Built in 1885, it was the oldest car taking part.该车造于1885年，是参赛车中最老的一辆。(相当于定语从句，…which took part)</li>
<li>I had all the usual symptoms of someone giving up smoking: a bad temper and an enormous appetite. 我具备了戒烟者通常表现出来的所有症状:脾气暴躁和食欲旺盛。(相当于定语从句，.. who give upsmoking..)</li>
<li>On a recent blog, Mr. Belinda wrote about VOA’s rules <code>demanding accuracy and objectivity</code>. 最近的一篇博客中，贝林达先生写了关于VOA要求客观性和准确性的规则。(相当于定语从句，… which demand..)</li>
</ul>
</li>
<li>如果定语从句是被动语态，或者主系表句型，be动词变成being后，可省略<ul>
<li>The ‘taxi’ is a small Swiss aeroplane <code>called a &#39;Pilatus Porter&#39;</code>. 这辆“出租汽车”是一架小型瑞士飞机，叫“皮勒特斯.波特“号。(called前省略了being, 如果用定语从句，则是…which is called a …)</li>
<li>Looking around, I realized with a shock that I was the only passenger left on the bus. 我环视了一下身旁，惊奇地发现车里就只剩我一个乘客了。(left前省略了being, 如果用定语从句，则是…who was left on the bus.)</li>
<li>Like his father, he was driving a car called Bluebird. 同他父亲一样，他也驾驶着一辆名 叫“蓝鸟”的汽车。</li>
<li>After reading an article entitled ‘Cigarette Smoking and Your Health’ I lit a cigarette to calm my nerves. 读完一篇题为《吸烟与健康》的文章之后，我点上了一枝香烟，来镇定一下自已紧张的神经。</li>
<li>I know an actor suitable for the part. 我认识一个适合扮演这个角色的演员。( 如果用定语从句，则是..who is suitable for the part.)</li>
</ul>
</li>
<li>造句练习 : (分别用定语从句和分词短语造句)<ul>
<li>1.乔治打开一个装着所有运动器材的大箱子。<ul>
<li>1.George opened a big box which contained all of his sports equipment.</li>
<li>George opened a big box containing all of his sports equipment.</li>
</ul>
</li>
<li>2.房主把贵重物品放在(keep)墙里边藏着的一个保险箱里。<ul>
<li>2.The owner of the house keeps his valuables in a safe which is hidden in the wall.</li>
<li>The owner of the house keeps his valuables in a safe hidden in the wall.</li>
</ul>
</li>
<li>3.那边那位正在同约翰说话的高个子男人是我的爸爸。<ul>
<li>3.The tall man who is talking to John over there is my father.</li>
<li>The tall man talking to John over there is my father.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分词短语的逻辑主语"><a href="#分词短语的逻辑主语" class="headerlink" title="分词短语的逻辑主语"></a>分词短语的逻辑主语</h2><ul>
<li>分词的主语和句子的主语不相同时，分词的主语必须保留！此时所形成的分词结构，称为分词的独立主格结构<ul>
<li><code>Nobody having</code> any more to say, the meeting was closed. 谁都无话可说，会议就结束了。(句子的主语是the meeting, 分词having的主语是nobody)</li>
<li>The village seemed deserted, the only sign of life being an ugly-looking black goat tied to a tree on a short length of rope in a field nearby. 村里似乎无人居住，唯一的生命迹象是附近田里一只面目可憎的黑山羊，用一截短绳拴在一棵树上。(句子的主语是The village, 分词being的主语是sign)</li>
<li>Because our 3D television installed, the whole family went into the living room. 因为我们的3D电视安装好了，全家人都进了客厅。(installed前面省略了being)</li>
</ul>
</li>
<li>独立主格结构也可由with引导，用于表示伴随状况、补充说明、具体举例等，或者表示原因<ul>
<li>It is possible that upon such an occasion a battle ensued, with the sharks being driven away or killed.双方可能随之发生搏斗，搏斗结果是海豚赶走或咬死鲨鱼。</li>
<li>A car roared past, with smoke pouring from the exhaust.一辆小汽车呼啸而过，排气管冒出一团团黑烟。</li>
<li>The silence was suddenly broken when a large car, <code>with its headlights on</code> and <code>its horn blaring</code>, roared down the arcade.宁静突然被打破，一辆大轿车亮着前灯，响着喇叭，呼啸着冲进了拱廊街。</li>
</ul>
</li>
<li>独立主格结构中分词为being 的时候，可以省略<ul>
<li>Last year, we were travelling across the Channel and Jane put a piece of paper <code>with her name and address on it</code> into a bottle. 去年，当我们横渡英吉利海峡时，简把写有她姓名和住址的一张纸条装进了一只瓶子。(her name and address后面省略了分词being，整个独立主格结构作定语修饰paper)</li>
<li>In the struggle, the strap broke and, with the bag in their possession, both men started running through the trees. 在争抢中，手提包的带断了，包落入这两个人手里，他们拔腿跑进了树林。(the bag后面省略了分词being, 整个独立主格结构作原因状语</li>
<li>She returned to the shop the following morning dressed in a fur coat, <code>with a handbag in one hand and a long umbrella in the other</code>. 第二天上午，她又来到这家商店，穿了一件裘皮大衣，一只手拎着一只手提包，另一只手拿着一把长柄伞。 (handbag和umbrella后面均省略了分词being,整个独立主格结构作伴随状语)</li>
<li>I sat down on one of those modern chairs with holes in it and waited. 我坐在一个新式的满是网眼儿的椅子上，等待着。(holes后面省略了分词being, 整个独立主格结构作定语，修饰chairs)</li>
<li>At that moment, a large black car with four officers inside it, stopped at the camp gates. 正在此时，一 辆黑色大轿车在军营门口停了下来。里面坐了4个军官。</li>
</ul>
</li>
<li>并列句简化为独立主格的时候，和普通分词短语一样，重要的分句作为主句，次要的作为独立主格<ul>
<li>比如：He came in and carried a book.</li>
<li>简化为分词短语：He came in carrying a book</li>
<li>也可以简化为独立主格：He came in with a book (being) in his hand.</li>
</ul>
</li>
<li>造句练习: (分别用从句和分词短语造句)<ul>
<li>1.由于房间很小，我们得站得非常靠近。<ul>
<li>1.Because the room is so small, we have to stand very close together.</li>
<li>The room being so small, we have to stand very close together.</li>
</ul>
</li>
<li>2.我们昨天吃了三顿饭，最好吃的是泰国料理。<ul>
<li>2.We had three meals yesterday and the tastiest was the Thai dish.</li>
<li>We had three meals yesterday, the tastiest being the Thai dish.</li>
</ul>
</li>
<li>3.这个男孩经常逃学，他爸爸很生气。<ul>
<li>3.The boy often play truant from school and his father get angry.</li>
<li>The boy often playing truant from school, his father gets angry.</li>
</ul>
</li>
<li>4.宁静突然被打破，一个凶恶的家伙(tough guy)瞪着眼睛拿着枪，闯进了(break into)银行。<ul>
<li>4.The silence was suddenly broken, when a tough guy whose eyes glared and who took a gun, broke into the bank.</li>
<li>The silence was suddenly broken, when a tough guy, with his eyes glaring and gun in his hand, broke into the bank.</li>
</ul>
</li>
</ul>
</li>
<li>形成固定用法的几个独立主格结构（前面的主语we省略了）<ul>
<li>Frankly speaking, ..：坦白说<ul>
<li>Frankly speaking, it is difficult for me to understand what he is saying. 坦率地说，理解他正在说的事情是很困难的。</li>
</ul>
</li>
<li>Broadly speaking…：泛泛地说<ul>
<li>Broadly speaking, human beings may be divided into three classes. 泛泛地说，人可以分为3类。</li>
</ul>
</li>
<li>Judging from…：有…看来<ul>
<li>Judging from her accent, she must be from the North. 从她的口音判断，她一定是北方人。</li>
</ul>
</li>
<li>Speaking of…：说道…<ul>
<li>Speaking of his lover, his eyes sparkled. 谈到他的情人时，他的双眼闪烁着光芒。</li>
</ul>
</li>
<li>Considering…：考虑到…<ul>
<li>Considering her age, the girl’s letter is very well put together. 就她的年龄而论，她的信可以说是写得很好的。</li>
</ul>
</li>
</ul>
</li>
<li>注意<ul>
<li>不管简化前的句子是什么时态，简化为分词短语时都是一样的V-ing形式。也就是说：不管简化前的句子是什么“时”，简化之后，通通不考虑其“时”，而只考虑其“态”。所以分词短语只有两种“态”：一般态和完成态。另外，定语从句简化为分词短语之后，绝对不能用完成态，所以绝对没有分词的完成态作定语的情况</li>
<li>以动词do为例</li>
<li><img src="https://img.shiqi-lu.tech/20201107163642.png?imageView2/2/h/100"></li>
<li>1.Singing a song, he sat down. 唱歌的时候，他就坐下了</li>
<li>2.Having sung a song, he sat down. 唱完歌后，他坐下了</li>
<li>第一句话是分词的一般态，表示“唱歌”这个动作（延续动作）和“坐下”这个动作同时发生。第二句话是分词的完成态，表示“唱歌”这个动作先发生</li>
</ul>
</li>
<li>构成分词短语的动词，不管延续还是非延续动词，简化成完成态以后都是having done。分词是没有<code>进行态</code>和<code>完成进行态</code>的。<ul>
<li><code>Having watered the garden</code>, he began to mow the lawn. 浇完花园以后，他开始修剪草坪。</li>
<li><code>Not having</code> done his homework, the boy went outside to play. 虽然这个男孩没有写完作业，他还是跑出去玩。</li>
<li><code>Having been bitten twice</code>, the postman refused to deliver our letters unless we chained our dog up. 被狗咬了两次以后，这个邮递员拒绝给我们送信，除非我们把狗锁起来。</li>
</ul>
</li>
<li>造句练习: (分别用从句和分词短语造句)<ul>
<li>1.已经失败了3次，他不想再尝试了。<ul>
<li>1.Because he has failed three times, he didn’t want to try again.</li>
<li>Having failed three times, he didn’t want to try again.</li>
</ul>
</li>
<li>2.因为在飓风中失去了他的货物，这个船长在船到达港口以后面临破产(bankruptcy)。<ul>
<li>2.Because he had lost his cargo in a hurricane, the captain faced bankruptcy after his vessel reached port.</li>
<li>Having lost his cargo in a hurricane, the captain faced bankruptcy after his vessel reached port.</li>
</ul>
</li>
<li>3.接到关于地震的警告，他把小孩留在了学校。<ul>
<li>3.He had been warned about the earthquake, he left his child in school.</li>
<li>Having been warned about the earthquake, he left his child at school.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
